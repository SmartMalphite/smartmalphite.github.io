<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 搭建 &amp; 使用指南</title>
    <url>/2022/05/17/Deploy/hexo/</url>
    <content><![CDATA[<h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><blockquote>
<p>Hexo 是一个可以易于上手、部署的静态博客架构。使用node.js作为构建引擎，插件库丰富，可扩展性好。支持MarkDown作为书写语言，可以满足日常博客编写需求</p>
</blockquote>
<h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>安装Hexo前，需要本地环境已经安装有这两个东西:</p>
<ul>
<li>Node.js</li>
<li>Git</li>
</ul>
<p>(这二者的安装就不在这里单独赘述了)</p>
<p>如果你的环境没有问题了，那么就可以开始安装Hexo了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>安装完成后，进入要作为博客资源的目录，执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog  <span class="comment"># 初始化配置</span></span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install  <span class="comment"># 安装依赖包</span></span><br><span class="line">hexo server  <span class="comment"># 在本地启动一个临时服务，可以用来预览和调试</span></span><br></pre></td></tr></table></figure>

<h2 id="撰写博文"><a href="#撰写博文" class="headerlink" title="撰写博文"></a>撰写博文</h2><p>撰写博文也非常简单，在<code>blog</code>目录下执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>例如想要创建一篇名为<code>hello</code>的博文:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post hello</span><br></pre></td></tr></table></figure>

<p>生成的文件路径是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO Created: &lt;blog-dir&gt;/source/_posts/hello.md</span><br></pre></td></tr></table></figure>

<p>打开文件，我们可以post模板已经自动帮我们生成了<code>yaml</code>文件头。其中<code>title</code>是文章的标题，<code>tags</code>是文章的标签。</p>
<p>编辑好文章内容后，执行<code>hexo server</code>就可以看见这篇文章已经发布到博客中了</p>
<h2 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h2><p>上文提到的<code>hexo server</code>的方式，只是在本地搭建了一个临时服务器，只能在本地访问。Hexo本身是一个静态页面的博客系统，因此对服务器的要求极低，Github免费提供的<code>Github Pages</code>就足以满足需求</p>
<h3 id="1-创建托管仓库"><a href="#1-创建托管仓库" class="headerlink" title="1.创建托管仓库"></a>1.创建托管仓库</h3><p>这里建议创建一个名为<code>&lt;username&gt;.github.io</code>的仓库来托管我们的网页(因为正常情况下，我们创建的仓库的github page的url是<code>&lt;username&gt;.github.io/&lt;repo name&gt;/</code>, 在域名之后会有一级仓库名称，这会导致很多页面、主题的相对路径功能出现问题；而使用这种仓库名和域名相同的方式创建的仓库的page的url中就不会包含仓库名)</p>
<h3 id="2-部署配置"><a href="#2-部署配置" class="headerlink" title="2. 部署配置"></a>2. 部署配置</h3><p>在博客的根目录下有一个<code>_config.yml</code>文件，这是博客的主配置文件。最后的<code>Deployment</code>配置项代表我们要使用的部署方式，如果我们要使用Git方式部署，那么需要安装一个hexo-deployer-git插件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后编辑这里的配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: &lt;repo url&gt;  <span class="comment"># 建议使用ssh的方式</span></span><br><span class="line">  branch: [branch]  <span class="comment"># 默认可不填</span></span><br><span class="line">  message: [message]  <span class="comment"># 默认可不填</span></span><br></pre></td></tr></table></figure>

<p>保存配置文件后，执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>上述命令可以简化成:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>现在已经将博客部署到Github了。可以用过<code>http://&lt;username&gt;.github.io</code>来访问自己的博客了</p>
<h2 id="Hexo-配置"><a href="#Hexo-配置" class="headerlink" title="Hexo 配置"></a>Hexo 配置</h2><p>在博客的主配置文件中除了配置部署相关的内容，还可以配置一些自定义的配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: <span class="string">&#x27;&#x27;</span>  <span class="comment"># 站名</span></span><br><span class="line">subtitle: <span class="string">&#x27;&#x27;</span>  <span class="comment"># 副标题</span></span><br><span class="line">description: <span class="string">&#x27;&#x27;</span>  <span class="comment"># 对搜索引擎收录博客会有帮助</span></span><br><span class="line">author: <span class="string">&#x27;&#x27;</span></span><br><span class="line">language: zh-Hans  <span class="comment"># 配置中文显示或者英文显示</span></span><br><span class="line">timezone: <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line">url: https://yoursite.com/ </span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  trailing_html: <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure>
<p>这部分配置只需要将url配置成自己的博客地址即可，例如部署在github page，就可以填 <code>https://&lt;username&gt;.github.io/project</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: ayer  </span><br></pre></td></tr></table></figure>
<p>主题配置，Hexo社区有大量的主题可供选择, 可以参考<a href="https://hexo.io/themes/">官方列表</a></p>
<h2 id="Hexo-主题"><a href="#Hexo-主题" class="headerlink" title="Hexo 主题"></a>Hexo 主题</h2><p>主题的使用也非常简单，这里以<code>AYER</code>主题为例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</span><br></pre></td></tr></table></figure>

<p>把你想要的主题<code>git clone</code>下来，放到<code>themes/</code>下对应的目录中，然后我们修改博客主配置中<code>theme</code>配置，保存后，再次执行<code>hexo server</code>命令，预览一下变化</p>
<p>主题的配置一般放在<code>themes/&lt;themename&gt;/_config.yml</code>文件下，具体配置参考<a href="https://shen-yu.gitee.io/2019/ayer/">官方文档</a>即可</p>
]]></content>
      <categories>
        <category>服务搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Go的字符串:编码与操作</title>
    <url>/2022/07/24/GoNote/Go%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="Go语言中字符串的编码"><a href="#Go语言中字符串的编码" class="headerlink" title="Go语言中字符串的编码:"></a>Go语言中字符串的编码:</h2><p>Go 语言在看待 Go 字符串组成这个问题上，有两种视角。</p>
<p>一种是<strong>字节视角</strong>，也就是和所有其它支持字符串的主流语言一样，Go 语言中的字符串值也是一个可空的字节序列，字节序列中的字节个数称为该字符串的长度。一个个的字节只是孤立数据，不表意</p>
<p>如果要表意，我们就需要从字符串的另外一个视角来看，也就是字符串是由一个可空的字符序列构成(即<strong>字符视角</strong>)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><br><span class="hljs-comment">// 字节视角</span><br>fmt.Printf(<span class="hljs-string">&quot;the length of s = %d\n&quot;</span>, <span class="hljs-built_in">len</span>(s)) <span class="hljs-comment">// 9</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, s[i]) <span class="hljs-comment">// 0xe4 0xb8 0xad 0xe5 0x9b 0xbd 0xe4 0xba 0xba</span><br>&#125;<br><br><br><span class="hljs-comment">// 字符视角</span><br>fmt.Println(<span class="hljs-string">&quot;the character count in s is&quot;</span>, utf8.RuneCountInString(s)) <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, c) <span class="hljs-comment">// 0x4e2d 0x56fd 0x4eba</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Go 采用的是 Unicode 字符集，每个字符都是一个 Unicode 字符，上述例子中字符视角下输出的 <code>0x4e2d</code>、<code>0x56fd</code> 和 <code>0x4eba</code> 就是 Unicode 字符的表示。以 <code>0x4e2d</code> 为例，它是汉字“中”在 Unicode 字符集表中的码点（Code Point）。Unicode字符集为绝大部分语言的字符提供了统一的编码集。</p>
<p>Unicode 字符集中的每个字符，都被分配了统一且唯一的字符编号。所谓 Unicode 码点，就是指将 Unicode 字符集中的所有字符“排成一队”，字符在这个“队伍”中的位次，就是它在 Unicode 字符集中的码点。也就说，一个码点唯一对应一个字符。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8 编码解决的是 Unicode 码点值在计算机中如何存储的问题。那么为什么不直接用unicode码点存储呢? 主要有如下几个问题:</p>
<ul>
<li>由于Unicode采用的是4个字节的固定长度编码，与ASCII无法兼容。</li>
<li>浪费存储空间</li>
</ul>
<p>UTF-8方案使用了变长设计，对Unicode的码点进行编码。其长度从1到4不等，并且前128个与ASCII兼容(即内存中如<code>A</code> <code>B</code> <code>C</code> 之类的字符时， ASCII字符编码可以被当做UTF-8编码直接使用)<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220724230323.png"></p>
<h3 id="Go语言如何表示一个码点"><a href="#Go语言如何表示一个码点" class="headerlink" title="Go语言如何表示一个码点"></a>Go语言如何表示一个码点</h3><p>Go 使用 rune 这个类型来表示一个 Unicode 码点。rune 本质上是 int32 类型的别名类型，它与 int32 类型是完全等价的</p>
<p>由于一个 Unicode 码点唯一对应一个 Unicode 字符。所以我们可以说，一个 rune 实例就是一个 Unicode 字符，一个 Go 字符串也可以被视为 rune 实例的集合。我们可以通过字符字面值来初始化一个 rune 变量。</p>
<p>那么现在我们就使用 Go 在标准库中提供的 UTF-8 包，对 Unicode 字符（rune）进行编解码试试看：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// rune -&gt; []byte                                                                            </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">encodeRune</span><span class="hljs-params">()</span></span> &#123;                                                                          <br>    <span class="hljs-keyword">var</span> r <span class="hljs-type">rune</span> = <span class="hljs-number">0x4E2D</span>                                                                      <br>    fmt.Printf(<span class="hljs-string">&quot;the unicode charactor is %c\n&quot;</span>, r) <span class="hljs-comment">// 中                                     </span><br>    buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">3</span>)                                                                   <br>    _ = utf8.EncodeRune(buf, r) <span class="hljs-comment">// 对rune进行utf-8编码                                                           </span><br>    fmt.Printf(<span class="hljs-string">&quot;utf-8 representation is 0x%X\n&quot;</span>, buf) <span class="hljs-comment">// 0xE4B8AD                            </span><br>&#125;                                                                                            <br>                                                                                             <br><span class="hljs-comment">// []byte -&gt; rune                                                                            </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeRune</span><span class="hljs-params">()</span></span> &#123;                                                                          <br>    <span class="hljs-keyword">var</span> buf = []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">0xE4</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0xAD</span>&#125;                                                       <br>    r, _ := utf8.DecodeRune(buf) <span class="hljs-comment">// 对buf进行utf-8解码</span><br>    fmt.Printf(<span class="hljs-string">&quot;the unicode charactor after decoding [0xE4, 0xB8, 0xAD] is %s\n&quot;</span>, <span class="hljs-type">string</span>(r)) <span class="hljs-comment">// 中</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Go字符串类型的底层实现"><a href="#Go字符串类型的底层实现" class="headerlink" title="Go字符串类型的底层实现"></a>Go字符串类型的底层实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// $GOROOT/src/reflect/value.go</span><br><br><span class="hljs-comment">// StringHeader是一个string的运行时表示</span><br><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>    Data <span class="hljs-type">uintptr</span><br>    Len  <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>从源码中和下面的图中可以看出string类型并不是单纯的”字符的数组”，而是有一个指向数据数据的指针和长度字段组成的结构体。<br>这也就很好的解释了string类型获取长度的时间复杂度是常数的原因。</p>
<p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220724230920.png"></p>
<h2 id="常用字符串操作"><a href="#常用字符串操作" class="headerlink" title="常用字符串操作"></a>常用字符串操作</h2><h3 id="下标操作"><a href="#下标操作" class="headerlink" title="下标操作"></a>下标操作</h3><p>在字符串的实现中，真正存储数据的是底层的数组。字符串的下标操作本质上等价于底层数组的下标操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;0x%x\n&quot;</span>, s[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 0xe4：字符“中” utf-8编码的第一个字节</span><br></code></pre></td></tr></table></figure>
<p>我们可以看到，通过下标操作，我们获取的是<strong>字符串中特定下标上的字节，而不是字符。</strong></p>
<h3 id="迭代操作"><a href="#迭代操作" class="headerlink" title="迭代操作"></a>迭代操作</h3><p>Go 有两种迭代形式：常规 for 迭代与 for range 迭代。需要注意的是，通过这两种形式的迭代对字符串进行操作得到的结果是不同的。<br>通过常规 for 迭代对字符串进行的操作是一种字节视角的迭代，而通过 for range 迭代，我们每轮迭代得到的是字符串中 Unicode 字符的码点值，以及该字符在字符串中的偏移值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><br><span class="hljs-comment">// for 迭代</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, s[i])<br>&#125;<br><br><span class="hljs-comment">// for range迭代</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, v)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行一下这段代码，我们得到:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// for 迭代</span><br>index: <span class="hljs-number">0</span>, value: <span class="hljs-number">0xe4</span><br>index: <span class="hljs-number">1</span>, value: <span class="hljs-number">0xb8</span><br>index: <span class="hljs-number">2</span>, value: <span class="hljs-number">0xad</span><br>index: <span class="hljs-number">3</span>, value: <span class="hljs-number">0xe5</span><br>index: <span class="hljs-number">4</span>, value: <span class="hljs-number">0x9b</span><br>index: <span class="hljs-number">5</span>, value: <span class="hljs-number">0xbd</span><br>index: <span class="hljs-number">6</span>, value: <span class="hljs-number">0xe4</span><br>index: <span class="hljs-number">7</span>, value: <span class="hljs-number">0xba</span><br>index: <span class="hljs-number">8</span>, value: <span class="hljs-number">0xba</span><br><br><span class="hljs-comment">// for range迭代</span><br>index: <span class="hljs-number">0</span>, value: <span class="hljs-number">0x4e2d</span><br>index: <span class="hljs-number">3</span>, value: <span class="hljs-number">0x56fd</span><br>index: <span class="hljs-number">6</span>, value: <span class="hljs-number">0x4eba</span><br></code></pre></td></tr></table></figure>

<h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><p>Go 原生支持通过 +&#x2F;+&#x3D; 操作符进行字符串连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;Rob Pike, &quot;</span><br>s = s + <span class="hljs-string">&quot;Robert Griesemer, &quot;</span><br>s += <span class="hljs-string">&quot; Ken Thompson&quot;</span><br><br>fmt.Println(s) <span class="hljs-comment">// Rob Pike, Robert Griesemer, Ken Thompson</span><br></code></pre></td></tr></table></figure>
<p>虽然通过 +&#x2F;+&#x3D; 进行字符串连接的开发体验是最好的, 但性能略差，Go 还提供了 strings.Builder、strings.Join、fmt.Sprintf 等函数来进行字符串连接操作以更好的解决性能问题</p>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>Go 字符串类型支持各种比较关系操作符，包括 &#x3D; &#x3D;、!&#x3D; 、&gt;&#x3D;、&lt;&#x3D;、&gt; 和 &lt;。在字符串的比较上，Go 采用字典序的比较策略，分别从每个字符串的起始处，开始逐个字节地对两个字符串类型变量进行比较。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// ==</span><br>        s1 := <span class="hljs-string">&quot;世界和平&quot;</span><br>        s2 := <span class="hljs-string">&quot;世界&quot;</span> + <span class="hljs-string">&quot;和平&quot;</span><br>        fmt.Println(s1 == s2) <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// !=</span><br>        s1 = <span class="hljs-string">&quot;Go&quot;</span><br>        s2 = <span class="hljs-string">&quot;C&quot;</span><br>        fmt.Println(s1 != s2) <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// &lt; and &lt;=</span><br>        s1 = <span class="hljs-string">&quot;12345&quot;</span><br>        s2 = <span class="hljs-string">&quot;23456&quot;</span><br>        fmt.Println(s1 &lt; s2)  <span class="hljs-comment">// true</span><br>        fmt.Println(s1 &lt;= s2) <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// &gt; and &gt;=</span><br>        s1 = <span class="hljs-string">&quot;12345&quot;</span><br>        s2 = <span class="hljs-string">&quot;123&quot;</span><br>        fmt.Println(s1 &gt; s2)  <span class="hljs-comment">// true</span><br>        fmt.Println(s1 &gt;= s2) <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h3><p>Go 支持字符串与字节切片、字符串与 rune 切片的双向转换，并且这种转换无需调用任何函数，只需使用显式类型转换即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;中国人&quot;</span><br>                      <br><span class="hljs-comment">// string -&gt; []rune</span><br>rs := []<span class="hljs-type">rune</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, rs) <span class="hljs-comment">// [4e2d 56fd 4eba]</span><br>                <br><span class="hljs-comment">// string -&gt; []byte</span><br>bs := []<span class="hljs-type">byte</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, bs) <span class="hljs-comment">// e4b8ade59bbde4baba</span><br>                <br><span class="hljs-comment">// []rune -&gt; string</span><br>s1 := <span class="hljs-type">string</span>(rs)<br>fmt.Println(s1) <span class="hljs-comment">// 中国人</span><br>                <br><span class="hljs-comment">// []byte -&gt; string</span><br>s2 := <span class="hljs-type">string</span>(bs)<br>fmt.Println(s2) <span class="hljs-comment">// 中国人</span><br></code></pre></td></tr></table></figure>

<h2 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h2><h3 id="UTF-8采用不定长的设计，如何辨别几个字节为一个字符"><a href="#UTF-8采用不定长的设计，如何辨别几个字节为一个字符" class="headerlink" title="UTF-8采用不定长的设计，如何辨别几个字节为一个字符?"></a>UTF-8采用不定长的设计，如何辨别几个字节为一个字符?</h3><table>
<thead>
<tr>
<th>unicode 符号范围</th>
<th>utf-8 编码方式</th>
</tr>
</thead>
<tbody><tr>
<td>00000000 ~ 0000007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>00000080 ~ 000007FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>00000800 ~ 0000FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>00010000 ~ 0010FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>总结下来，针对UTF8，编码规则其实只有两条：</p>
<ol>
<li>单字节规则： 对于 单字节 的符号，字节的第一位（最高位）设为 0，后面 7 位为这个符号的 unicode 码。</li>
<li>n字节规则： 对于 n 字节的符号（n&gt;1），第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。</li>
</ol>
]]></content>
      <categories>
        <category>Go学习笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>编解码</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus | PromQL</title>
    <url>/2022/07/05/Alert/prometheus-pql/</url>
    <content><![CDATA[<h2 id="0-什么是PromQL"><a href="#0-什么是PromQL" class="headerlink" title="0. 什么是PromQL"></a>0. 什么是PromQL</h2><blockquote>
<p>PromQL（Prometheus Query Language）是 Prometheus 内置的数据查询语言，它能实现对事件序列数据的查询、聚合、逻辑运算等。它并且被广泛应用在 Prometheus 的日常应用当中，包括对数据查询、可视化、告警处理当中。简单地说，PromQL 广泛存在于以 Prometheus 为核心的监控体系中。所以需要用到数据筛选的地方，就会用到 PromQL。例如：监控指标的设置、报警指标的设置等等。</p>
</blockquote>
<h2 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1. 基础用法"></a>1. 基础用法</h2><p>当我们直接使用监控指标名称查询时，可以查询该指标下的所有时间序列。<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220705202637.png"><br>可以看到我们查询出了所有指标名称为 <code>prometheus_http_requests_total</code> 的数据。<br>PromQL 支持户根据时间序列的标签匹配模式来对时间序列进行过滤，目前主要支持两种匹配模式：完全匹配和正则匹配。</p>
<h3 id="1-1-完全匹配"><a href="#1-1-完全匹配" class="headerlink" title="1.1 完全匹配"></a>1.1 完全匹配</h3><p>PromQL 支持使用 &#x3D; 和 !&#x3D; 两种完全匹配模式。</p>
<ul>
<li>等于。通过使用 <code>label=value</code> 可以选择那些标签满足表达式定义的时间序列。</li>
<li>不等于。通过使用 <code>label!=value</code> 则可以根据标签匹配排除时间序列。</li>
</ul>
<p>例如我们上面查询出了所有指标名称为 <code>prometheus_http_requests_total</code> 的数据。这时候我们希望只查看错误的请求，即过滤掉所有 code 标签不是 200 的数据。</p>
<p>那么我们的 PromQL 表达式可以修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;code!=&quot;200&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-正则匹配"><a href="#1-2-正则匹配" class="headerlink" title="1.2 正则匹配"></a>1.2 正则匹配</h3><p>PromQL 还可以使用正则表达式作为匹配条件，并且可以使用多个匹配条件。</p>
<ul>
<li>正向匹配。使用 <code>label=~regx</code> 表示选择那些标签符合正则表达式定义的时间序列。</li>
<li>反向匹配。使用 <code>label!~regx</code> 进行排除。</li>
</ul>
<p>例如我想查询指标 <code>prometheus_http_requests_total</code> 中，所有 handler 标签以 &#x2F;api&#x2F;v1 开头的记录。</p>
<p>那么我的表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;handler=~&quot;/api/v1/.*&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-范围查询"><a href="#1-3-范围查询" class="headerlink" title="1.3 范围查询"></a>1.3 范围查询</h3><p>我们上面直接通过类似 <code>prometheus_http_requests_total</code> 表达式查询时间序列时，同一个指标同一标签只会返回一条数据。这样的表达式我们称之为<code>瞬间向量表达式</code>，返回的结果称之为<code>瞬间向量</code></p>
<p>而如果我们想查询一段时间范围内的样本数据，那么我们就需要用到<code>区间向量表达式</code>，其查询出来的结果称之为<code>区间向量</code>。</p>
<p>时间范围通过时间范围选择器 <code>[]</code> 进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;&#125;[5m]</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220705204103.png"><br>通过查询结果可以看到，此时我们查询出了所有的样本数据，而不再是一个样本数据的统计值。</p>
<p>PromQL的时间范围选择器支持其它时间单位: </p>
<ul>
<li>s - 秒</li>
<li>m - 分</li>
<li>h - 时</li>
<li>d - 天</li>
<li>w - 周</li>
<li>y - 年</li>
</ul>
<h3 id="1-4-时间偏移"><a href="#1-4-时间偏移" class="headerlink" title="1.4 时间偏移"></a>1.4 时间偏移</h3><p>在瞬时向量表达式或者区间向量表达式中，都是以当前时间为基准。如果我们想查询 5 分钟前的瞬时样本数据，或昨天一天的区间内的样本数据呢? 这个时候我们就可以使用位移操作，位移操作的关键字为 <code>offset</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询 5 分钟前的最新数据</span><br><span class="line">http_request_total&#123;&#125; offset 5m</span><br><span class="line"></span><br><span class="line"># 往前移动 1 天，查询 1 天前的数据</span><br><span class="line">http_request_total&#123;&#125;[1d] offset 1d</span><br></pre></td></tr></table></figure>

<h3 id="1-5-聚合查询"><a href="#1-5-聚合查询" class="headerlink" title="1.5 聚合查询"></a>1.5 聚合查询</h3><p>一般情况下，我们通过 PromQL 查询到的数据都是很多的。PromQL 提供的聚合操作可以用来对这些时间序列进行处理，形成一条新的时间序列。</p>
<p>以我们的 <code>prometheus_http_requests_total</code> 指标为例，不加任何条件我们查询到的数据为：<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220705204914.png"></p>
<ul>
<li><p>第一个表达式，计算一共有几条数据: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count(prometheus_http_requests_total)</span><br><span class="line"># 查询结果为8，代表总共有8条数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个表达式，计算所有数据的 value 总和:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(prometheus_http_requests_total)</span><br><span class="line"># 查询结果为307，代表所有数据的value之和为307</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-常用函数"><a href="#2-常用函数" class="headerlink" title="2. 常用函数"></a>2. 常用函数</h2><p>scalar(v instance-vector)是我们第一个见过的函数， 他将瞬时向量转化成标量。</p>
<blockquote>
<p>标量可以用于运算和可视化。例如和瞬时向量可以和标量进行加减乘除运算。只有一个时间序列的瞬时变量可以通过函数scalar()转化为标量。有时候在监控中，我们只需要知道当前的系统是不是健康的，当前磁盘空间是多少，只是后就可以用scalar()得到标量并在可视化工具中展示。</p>
</blockquote>
<p>abs(v instant-vector)可以将瞬时变量中的值转变为绝对值。</p>
<p>increase(v range-vector) 求区间向量的增长量（最新值减最旧值）并返回一个瞬时向量。</p>
]]></content>
      <categories>
        <category>监控告警</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
        <tag>PromQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.139 | 单词拆分</title>
    <url>/2022/05/20/LeetCode/139-word-break/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode.cn/problems/word-break/">题目描述</a></h2><blockquote>
<p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。<br>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
</blockquote>
<p>示例 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>假如要判断字符串”catsanddog”是否满足条件，我们可以采取<code>分而治之</code>的思路去思考，比如将字符串切割成两部分去分别判断，当前后两部分都满足条件时则可以证明这个字符串整体也是满足条件的；</p>
<p>这种思路的本质是将字符串分为两部分去看，后半部分为<code>本次待判断</code>的字符串，前半部分为不包括最后一个字符串的其余部分。那么如何求前半部分是否满足条件呢? 也可以通过相同的方式在进行一次分割判断。</p>
<p>此时已经将此问题翻译成了一个标准的动态规划题目</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>代码实现上可以采取两层循环的方式: <code>外层循环</code>设置变量i作为每个<code>待判断子串</code>(即s[0,i])的结尾。从1开始，循环至字符串最后一个字符，逐步判断每个子串是否满足条件，并将结果记录下来方便对下个子串进行判断时的搜索。即逐步判断’c’, ‘ca’, ‘cat’, ‘cats’ … ‘catsanddog’是否满足条件。 </p>
<p><code>内层循环</code>设置变量j在每个由外层循环切割出的子串内进行<code>遍历切割</code>，根据记忆化搜索的结果判断当前子串是否满足条件。比如待判断子串为’catsanddog’时，将其切割为[‘c’, ‘atsanddog’]、[‘ca’, ‘tsanddog’]等等，最终发现切割为[‘catsand’, ‘dog’]时可以满足条件(‘catsand’子串命中记忆化搜索，’dog’命中字典)</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    wordDictSet := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> wordDict&#123;</span><br><span class="line">        wordDictSet[v] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="built_in">len</span>(s);i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;i;j++&#123;</span><br><span class="line">            <span class="keyword">if</span> dp[j] &amp;&amp; wordDictSet[s[j:i]]&#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(s)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>收藏从未停止 ⏹</title>
    <url>/2022/07/24/Other/%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>速查表</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td>MarkDown</td>
<td><a href="https://markdown.com.cn/">https://markdown.com.cn/</a></td>
</tr>
<tr>
<td>Go面试宝典</td>
<td><a href="https://golang.design/go-questions/slice/vs-array/">https://golang.design/go-questions/slice/vs-array/</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>速查</tag>
      </tags>
  </entry>
  <entry>
    <title>Python单元测试</title>
    <url>/2022/08/10/PythonNote/PythonUnitTest/</url>
    <content><![CDATA[<h2 id="1-PyTest安装"><a href="#1-PyTest安装" class="headerlink" title="1. PyTest安装:"></a>1. PyTest安装:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pip install pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用插件安装</span></span><br><span class="line">&gt;&gt;&gt; pip install pytest-mock  <span class="comment"># mocker插件</span></span><br><span class="line">&gt;&gt;&gt; pip install pytest-cov   <span class="comment"># 单测覆盖率插件</span></span><br></pre></td></tr></table></figure>

<h2 id="2-基础用法"><a href="#2-基础用法" class="headerlink" title="2. 基础用法"></a>2. 基础用法</h2><p>定义一个函数如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_sum</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;calling get_sum function&quot;</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>

<p>为了验证其功能，我们可以编写单测用例如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">test_sum</span>(<span class="params">self</span>):</span><br><span class="line">		result = get_sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">		<span class="built_in">print</span> result</span><br><span class="line">		<span class="keyword">assert</span> result == <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>运行用例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; python -m pytest -v test_tmp.py -s</span><br></pre></td></tr></table></figure>

<h3 id="2-1-命令行参数"><a href="#2-1-命令行参数" class="headerlink" title="2.1 命令行参数"></a>2.1 命令行参数</h3><p>可以通过<code>pytest -help</code> 查看支持的参数。以下是一些常用的参数:</p>
<ul>
<li><code>-v</code>: 输出更详细的用例执行信息, 不使用 -v 参数，运行时不会显示运行的具体测试用例名称；</li>
<li><code>-s</code>: 显示print内容 在运行测试用例时，为了调试或打印一些内容，我们会在代码中加一些print内容，但是这些内容默认不会显示出来。如果带上-s，就可以显示了。</li>
<li><code>-x</code>: 出现一条测试用例失败就退出测试。 </li>
<li><code>-m</code>: 用表达式指定多个标记名。 pytest 提供了一个装饰器 @pytest.mark.xxx，用于标记测试并分组，以便你快速选中并运行，各个分组直接用 and、or 来分割。</li>
</ul>
<h3 id="2-2-选择执行的测试用例-静态"><a href="#2-2-选择执行的测试用例-静态" class="headerlink" title="2.2 选择执行的测试用例(静态)"></a>2.2 选择执行的测试用例(静态)</h3><p>按文件夹执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行指定文件夹及子文件夹下的所有测试用例</span></span><br><span class="line">pytest ../tests</span><br></pre></td></tr></table></figure>

<p>按文件执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行test_tmp.py下的所有的测试用例</span></span><br><span class="line">pytest test_tmp.py</span><br></pre></td></tr></table></figure>

<p>按测试类执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pytest 文件名.py::测试类</span></span><br><span class="line">pytest test_tmp.py::TestTmp</span><br></pre></td></tr></table></figure>

<p>按测试方法执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pytest 文件名.py::测试类::测试方法</span></span><br><span class="line">pytest test_tmp.py::TestTmpFunction::test_sum</span><br></pre></td></tr></table></figure>

<h3 id="选择执行的测试用例-动态"><a href="#选择执行的测试用例-动态" class="headerlink" title="选择执行的测试用例(动态)"></a>选择执行的测试用例(动态)</h3><p>如要使用动态指定测试用例的方式，首先需要给测试用例打标签（mark），比如在 <code>class</code>、<code>method</code> 上加上如下装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.dev_test</span></span><br></pre></td></tr></table></figure>
<p>在运行时，可以根据标签来动态的选择哪些用例需要执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同时选中带有这两个标签的所有测试用例运行</span></span><br><span class="line">pytest -m &quot;mark1 and mark2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选中带有mark1的测试用例，不运行mark2的测试用例</span></span><br><span class="line">pytest -m &quot;mark1 and not mark2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选中带有mark1或 mark2标签的所有测试用例</span></span><br><span class="line">pytest -m &quot;mark1 or mark2&quot;</span><br></pre></td></tr></table></figure>

<p>除此之外还提供了一种通过模糊匹配的方式选择测试用例的方式:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-k 参数是按照文件名、类名、方法名、标签名来模糊匹配的</span></span><br><span class="line">pytest -k xxxPattern</span><br></pre></td></tr></table></figure>

<h2 id="3-mock使用"><a href="#3-mock使用" class="headerlink" title="3. mock使用"></a>3. mock使用</h2><p>pytest自带的unittest框架中默认集成了mock库，PyTest的mock支持是通过插件实现的。相对来讲PyTest使用起来更简单(PyTest的mocker是对原生mock的一个兼容，原生mock支持的功能mocker基本都可以支持)</p>
<h3 id="3-1-基础用法"><a href="#3-1-基础用法" class="headerlink" title="3.1 基础用法"></a>3.1 基础用法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_sum</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;calling get_sum function&quot;</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">test_sum_with_mock</span>(<span class="params">self, mocker</span>):</span><br><span class="line">		mocker.patch(<span class="string">&#x27;test_tmp.get_sum&#x27;</span>, return_value=<span class="number">3</span>)</span><br><span class="line">		result = get_sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">		<span class="built_in">print</span> result</span><br><span class="line">		<span class="keyword">assert</span> result == <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>运行后可以发现，原本<code>get_sum</code>的print内容并没有被打印出来，我们通过<code>mocker.patch</code>方法屏蔽掉了原函数，转而直接返回我们指定的返回结果</p>
<h3 id="3-2-其他用法"><a href="#3-2-其他用法" class="headerlink" title="3.2 其他用法"></a>3.2 其他用法</h3><p>mocker.patch的函数定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unittest.mock.patch(target, new=DEFAULT, spec=<span class="literal">None</span>, create=<span class="literal">False</span>, spec_set=<span class="literal">None</span>, autospec=<span class="literal">None</span>, new_callable=<span class="literal">None</span>, **kwargs)</span><br></pre></td></tr></table></figure>
<p>常用参数含义：</p>
<ul>
<li><code>target</code>: 模拟对象的路径，参数必须是一个str,格式为’package.module.ClassName’，注意这里的格式一定要写对。如果对象和mock函数在同一个文件中，路径要加文件名</li>
<li><code>return_value</code>: 模拟函数返回的结果</li>
<li><code>side_effect</code>: 调用mock时的返回值，可以是函数，异常类，可迭代对象。当设置了该方法时，如果该方法返回值是DEFAULT，那么返回return_value的值，如果不是，则返回该方法的值。 return_value 和 side_effect 同时存在，side_effect会返回。(如果 side_effect 是异常类或实例时，调用模拟程序时将引发异常。如果 side_effect 是可迭代对象，则每次调用 mock 都将返回可迭代对象的下一个值。如果设置为函数时其具体表现会替换被mock函数）</li>
</ul>
<h2 id="4-MagicMock"><a href="#4-MagicMock" class="headerlink" title="4. MagicMock"></a>4. MagicMock</h2><p>在mock的过程中，有时我们需要构造相对复杂的返回值，比如对db操作函数的mock，返回值往往是一个对象。这时候常规做法我们就需要定义一个类，并且将其实例化。<br>这种做法较为麻烦，且不够灵活。Python提供了一个MagicMock方法，我们可以较为方便的构造我们想要的数据类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">test_sum_with_magic_mock</span>(<span class="params">self, mocker</span>):</span><br><span class="line">		o1 = MagicMock(a=<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">print</span> o1.a</span><br><span class="line"></span><br><span class="line">		o2 = MagicMock()</span><br><span class="line">		<span class="built_in">print</span> <span class="built_in">list</span>(o2)</span><br><span class="line">		o2.__iter__.return_value = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">		<span class="built_in">print</span> <span class="built_in">list</span>(o2)</span><br></pre></td></tr></table></figure>
<p>在工程实践中，我们一般对MagicMock在进行一次封装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factory</span>(<span class="params">attrs=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">	kwargs[<span class="string">&#x27;return_value&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">	o = MagicMock(**kwargs)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> attrs:</span><br><span class="line">		<span class="keyword">return</span> o</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">		<span class="built_in">setattr</span>(o, k, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> o</span><br></pre></td></tr></table></figure>

<h2 id="5-数据驱动"><a href="#5-数据驱动" class="headerlink" title="5. 数据驱动"></a>5. 数据驱动</h2><p>某些时候，我们希望我们的单测可以覆盖多种逻辑分支，这时为每一种case都单独写一个测试明显也是不现实的。PyTest为单测提供了参数化功能，也就是数据驱动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">	@pytest.mark.parametrize(<span class="params"><span class="string">&#x27;a, b, sum_result&#x27;</span>, [</span></span></span><br><span class="line"><span class="params"><span class="meta">		(<span class="params"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">		(<span class="params"><span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">	]</span>)</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">test_sum_with_param</span>(<span class="params">self, mocker, a, b, sum_result</span>):</span><br><span class="line">		result = get_sum(a, b)</span><br><span class="line">		<span class="built_in">print</span> result</span><br><span class="line">		<span class="keyword">assert</span> result == sum_result</span><br></pre></td></tr></table></figure>

<h2 id="6-代码覆盖率"><a href="#6-代码覆盖率" class="headerlink" title="6. 代码覆盖率"></a>6. 代码覆盖率</h2><p>PyTest提供了pytest-cov插件来实现代码覆盖率的统计.</p>
<h3 id="6-1-基础用法"><a href="#6-1-基础用法" class="headerlink" title="6.1 基础用法"></a>6.1 基础用法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pytest --cov --cov-report=xml</span><br></pre></td></tr></table></figure>

<h3 id="6-2-生成差异报表"><a href="#6-2-生成差异报表" class="headerlink" title="6.2 生成差异报表"></a>6.2 生成差异报表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; diff-cover coverage.xml --compare-branch=origin/master --html-report report.html --fail-under=80</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.139 | 单词拆分</title>
    <url>/2022/05/20/LeetCode/209-minimum-size-subarray-sum/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode.cn/problems/word-break/">题目描述</a></h2><blockquote>
<p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。<br>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
</blockquote>
<p>示例 ：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以由 <span class="hljs-string">&quot;leet&quot;</span> 和 <span class="hljs-string">&quot;code&quot;</span> 拼接成。<br></code></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>假如要判断字符串”catsanddog”是否满足条件，我们可以采取<code>分而治之</code>的思路去思考，比如将字符串切割成两部分去分别判断，当前后两部分都满足条件时则可以证明这个字符串整体也是满足条件的；</p>
<p>这种思路的本质是将字符串分为两部分去看，后半部分为<code>本次待判断</code>的字符串，前半部分为不包括最后一个字符串的其余部分。那么如何求前半部分是否满足条件呢? 也可以通过相同的方式在进行一次分割判断。</p>
<p>此时已经将此问题翻译成了一个标准的动态规划题目</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>代码实现上可以采取两层循环的方式: <code>外层循环</code>设置变量i作为每个<code>待判断子串</code>(即s[0,i])的结尾。从1开始，循环至字符串最后一个字符，逐步判断每个子串是否满足条件，并将结果记录下来方便对下个子串进行判断时的搜索。即逐步判断’c’, ‘ca’, ‘cat’, ‘cats’ … ‘catsanddog’是否满足条件。 </p>
<p><code>内层循环</code>设置变量j在每个由外层循环切割出的子串内进行<code>遍历切割</code>，根据记忆化搜索的结果判断当前子串是否满足条件。比如待判断子串为’catsanddog’时，将其切割为[‘c’, ‘atsanddog’]、[‘ca’, ‘tsanddog’]等等，最终发现切割为[‘catsand’, ‘dog’]时可以满足条件(‘catsand’子串命中记忆化搜索，’dog’命中字典)</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(s <span class="hljs-type">string</span>, wordDict []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    wordDictSet := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> wordDict&#123;<br>        wordDictSet[v] = <span class="hljs-literal">true</span><br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(s);i++&#123;<br>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;i;j++&#123;<br>            <span class="hljs-keyword">if</span> dp[j] &amp;&amp; wordDictSet[s[j:i]]&#123;<br>                dp[i] = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.919 | 完全二叉树插入器</title>
    <url>/2022/08/09/LeetCode/919-complete-binary-tree-inserter/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode.cn/problems/complete-binary-tree-inserter/">题目描述</a></h2><p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220809230841.png"></p>
<h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>实现一个算法，支持初始化、数据插入和返回根节点。其中初始化阶段的入参是一个已有的完全二叉树。</p>
<h2 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h2><h3 id="第一问-怎样的节点可以插入数据"><a href="#第一问-怎样的节点可以插入数据" class="headerlink" title="第一问: 怎样的节点可以插入数据?"></a>第一问: 怎样的节点可以插入数据?</h3><p>该节点的左右节点任一节点为空</p>
<h3 id="第二问-怎样找到这样的节点"><a href="#第二问-怎样找到这样的节点" class="headerlink" title="第二问: 怎样找到这样的节点?"></a>第二问: 怎样找到这样的节点?</h3><p>自然而然的想法就是遍历这颗完全二叉树。但是遍历一颗树的方法有很多，在本题中我们应该采用哪种方法呢?<br>其实很容易想到我们在自己动手插入数据的时候，一定是逐层、从左向右的插入。即先填充最后一行非叶子结点中尚未饱和的节点，再在叶子结点的行从左到右依次添加子节点。<br><strong>(注意: 以上说法的前提是这是一颗完全二叉树)</strong></p>
<h4 id="落地-怎么横向遍历一颗完全二叉树"><a href="#落地-怎么横向遍历一颗完全二叉树" class="headerlink" title="落地: 怎么横向遍历一颗完全二叉树?"></a>落地: 怎么横向遍历一颗完全二叉树?</h4><ol>
<li>将根节点放到一个list中。</li>
<li>将其左右节点(如果存在)也放到list末尾</li>
<li>将根节点从list中踢出，list中的原2号位作为新的根节点</li>
<li>重复2-3，直到list为空</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">nodeList := []*TreeNode&#123;root&#125; <span class="hljs-comment">//step 1</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(nodeList) &gt; <span class="hljs-number">0</span>&#123;<br>    currentRoot := nodeList[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment">//step 2</span><br>    <span class="hljs-keyword">if</span> currentRoot.Left != <span class="hljs-literal">nil</span>&#123;<br>        nodeList = <span class="hljs-built_in">append</span>(nodeList, currentRoot.Left)<br>    &#125;<br>    <span class="hljs-keyword">if</span> currentRoot.Right != <span class="hljs-literal">nil</span>&#123;<br>        nodeList = <span class="hljs-built_in">append</span>(nodeList, currentRoot.Right)<br>    &#125;<br><br>    nodeList = nodeList[<span class="hljs-number">1</span>:] <span class="hljs-comment">// step 3</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="第三问-找到这些节点后怎么用"><a href="#第三问-找到这些节点后怎么用" class="headerlink" title="第三问: 找到这些节点后怎么用?"></a>第三问: 找到这些节点后怎么用?</h3><p>组织一个候选list，按照遍历的顺序将满足条件的节点依次插入其中。Insert函数调用时，只需要取第一个节点判断向左插还是向右插:</p>
<ol>
<li>向左插: 完成后无需其他操作</li>
<li>向右插: 完成后list第一个节点已经饱和，将其移出list<br>最后，不论向左还是向右插入数据后，都需要在候选list的最后加入本次插入的child节点<br><strong>因为遍历得到的候选list是逐层、从左到右的顺序。直接向后追加child依旧能保证此顺序</strong></li>
</ol>
<h3 id="第四问-初始化时数据结构如何"><a href="#第四问-初始化时数据结构如何" class="headerlink" title="第四问: 初始化时数据结构如何?"></a>第四问: 初始化时数据结构如何?</h3><p>综上所述，为了实现根节点返回函数，显然我们需要在数据结构中记录根节点root;<br>为了实现Insert方法，我们需要记录候选节点的list</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CBTInserter <span class="hljs-keyword">struct</span> &#123;<br>    root *TreeNode<br>    candidate []*TreeNode<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="整体代码实现"><a href="#整体代码实现" class="headerlink" title="整体代码实现"></a>整体代码实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CBTInserter <span class="hljs-keyword">struct</span> &#123;<br>    root *TreeNode<br>    candidate []*TreeNode<br>&#125;<br><br><span class="hljs-comment">// 初始化函数需要做的就是将root记录下来，并计算出第一版候选人名单</span><br><span class="hljs-comment">// 如何计算候选人名单: 根据上述第二步的思路，在遍历的过程中找到符合第一步要求的节点，并将其记录下来</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(root *TreeNode)</span></span> CBTInserter &#123;<br>    nodeList := []*TreeNode&#123;root&#125;<br>    candidate := []*TreeNode&#123;&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(nodeList) &gt; <span class="hljs-number">0</span>&#123;<br>        currentRoot := nodeList[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> currentRoot.Left != <span class="hljs-literal">nil</span>&#123;<br>            nodeList = <span class="hljs-built_in">append</span>(nodeList, currentRoot.Left)<br>        &#125;<br>        <span class="hljs-keyword">if</span> currentRoot.Right != <span class="hljs-literal">nil</span>&#123;<br>            nodeList = <span class="hljs-built_in">append</span>(nodeList, currentRoot.Right)<br>        &#125;<br>        nodeList = nodeList[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">if</span> currentRoot.Left == <span class="hljs-literal">nil</span> || currentRoot.Right == <span class="hljs-literal">nil</span>&#123; <span class="hljs-comment">// 找到目标节点，记录在候选名单末尾</span><br>            candidate = <span class="hljs-built_in">append</span>(candidate, currentRoot)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> CBTInserter&#123;root, candidate&#125;<br>&#125;<br><br><span class="hljs-comment">// 插入数据，按照第三步实现即可</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CBTInserter)</span></span> Insert(val <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    child := &amp;TreeNode&#123;val, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>    node := this.candidate[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span>&#123;<br>        node.Left = child<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        node.Right = child<br>        this.candidate = this.candidate[<span class="hljs-number">1</span>:]<br>    &#125;<br>    this.candidate = <span class="hljs-built_in">append</span>(this.candidate, child)<br>    <span class="hljs-keyword">return</span> node.Val<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CBTInserter)</span></span> Get_root() *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> this.root<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>完全二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Go的哈希表</title>
    <url>/2022/09/06/GoNote/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="map-的底层实现"><a href="#map-的底层实现" class="headerlink" title="map 的底层实现"></a>map 的底层实现</h2><p>在源码中，表示 map 的结构体是 hmap，它是 hashmap 的“缩写”：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A header for a Go map.</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 元素个数，调用 len(map) 时，直接返回此值</span><br>	count     <span class="hljs-type">int</span><br>	flags     <span class="hljs-type">uint8</span><br>	<span class="hljs-comment">// buckets 的对数 log_2</span><br>	B         <span class="hljs-type">uint8</span><br>	<span class="hljs-comment">// overflow 的 bucket 近似数</span><br>	noverflow <span class="hljs-type">uint16</span><br>	<span class="hljs-comment">// 计算 key 的哈希的时候会传入哈希函数</span><br>	hash0     <span class="hljs-type">uint32</span><br>    <span class="hljs-comment">// 指向 buckets 数组，大小为 2^B</span><br>    <span class="hljs-comment">// 如果元素个数为0，就为 nil</span><br>	buckets    unsafe.Pointer<br>	<span class="hljs-comment">// 等量扩容的时候，buckets 长度和 oldbuckets 相等</span><br>	<span class="hljs-comment">// 双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍</span><br>	oldbuckets unsafe.Pointer<br>	<span class="hljs-comment">// 指示扩容进度，小于此地址的 buckets 迁移完成</span><br>	nevacuate  <span class="hljs-type">uintptr</span><br>	extra *mapextra <span class="hljs-comment">// optional fields</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>buckets 是一个指针，最终它指向的是一个结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    topbits  [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span><br>    keys     [<span class="hljs-number">8</span>]keytype<br>    values   [<span class="hljs-number">8</span>]valuetype<br>    pad      <span class="hljs-type">uintptr</span><br>    overflow <span class="hljs-type">uintptr</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。</p>
<p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220924231449.png"></p>
<p>每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 overflow 指针连接起来。</p>
<h2 id="Key的定位流程"><a href="#Key的定位流程" class="headerlink" title="Key的定位流程"></a>Key的定位流程</h2><p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220926131214.png"><br>上图中，假定 B &#x3D; 5，所以 bucket 总数就是 2^5 &#x3D; 32。首先计算出待查找 key 的哈希，使用低 5 位 00110，找到对应的 6 号 bucket，使用高 8 位 10010111，对应十进制 151，在 6 号 bucket 中寻找 tophash 值（HOB hash）为 151 的 key，找到了 2 号槽位，这样整个查找过程就结束了。</p>
<p>如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1-slice与map作为函数参数时的区别"><a href="#1-slice与map作为函数参数时的区别" class="headerlink" title="1. slice与map作为函数参数时的区别?"></a>1. slice与map作为函数参数时的区别?</h3><p>makemap返回的是一个指针，makeslice返回的是一个Slice结构体. 结合Go的参数传递是值传递这个特性，在函数内部操作map是会影响对原始map产生影响的。而Slice需要视情况分析(因为虽然值传递的特性使其在传参时copy了一个新的结构体，但是底层数据是一个指针，依旧指向同一个底层数组)</p>
<h3 id="2-topHash的偏移值"><a href="#2-topHash的偏移值" class="headerlink" title="2. topHash的偏移值"></a>2. topHash的偏移值</h3><p>topHash除了记录某一key的hash值的高八位外，还具备了标识状态的作用。为了和正常的哈希值区分开，会给 key 计算出来的哈希值一个增量：minTopHash。这样就能区分正常的 top hash 值和表示状态的哈希值。(状态标识的值分别为0-4，如果一个key的hash值高八位是1，那么为了区分开来，就会将其偏移为6)</p>
]]></content>
      <categories>
        <category>Go学习笔记</category>
      </categories>
      <tags>
        <tag>GoLang数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Go的数组、切片</title>
    <url>/2022/09/06/GoNote/%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<h2 id="数组与切片介绍"><a href="#数组与切片介绍" class="headerlink" title="数组与切片介绍"></a>数组与切片介绍</h2><p>slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。</p>
<p>数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。</p>
<p>而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。</p>
<p>数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime/slice.go</span><br><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>	array unsafe.Pointer <span class="hljs-comment">// 元素指针</span><br>	<span class="hljs-built_in">len</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// 长度 </span><br>	<span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// 容量</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。</p>
</blockquote>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="问题1-3-int-和-4-int-是同一个类型吗？"><a href="#问题1-3-int-和-4-int-是同一个类型吗？" class="headerlink" title="问题1: [3]int 和 [4]int 是同一个类型吗？"></a>问题1: [3]int 和 [4]int 是同一个类型吗？</h3><p>不是。因为数组的长度是类型的一部分，这是与 slice 不同的一点。</p>
<h3 id="问题2-切片的长度与容量"><a href="#问题2-切片的长度与容量" class="headerlink" title="问题2: 切片的长度与容量?"></a>问题2: 切片的长度与容量?</h3><p>Go语言的切片拥有长度和容量。长度是他所包含的元素个数，容量是其底层数组的元素个数。append是切片的长度大于容量后，切片会自动扩容。</p>
<h4 id="问题2-1-下面的代码输出是什么？"><a href="#问题2-1-下面的代码输出是什么？" class="headerlink" title="问题2.1: 下面的代码输出是什么？"></a>问题2.1: 下面的代码输出是什么？</h4><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>	s1 := slice[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>	s2 := s1[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>:<span class="hljs-number">7</span>]<br><br>	s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">100</span>)<br>	s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">200</span>)<br><br>	s1[<span class="hljs-number">2</span>] = <span class="hljs-number">20</span><br><br>	fmt.Println(s1)<br>	fmt.Println(s2)<br>	fmt.Println(slice)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">[<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">20</span>]<br>[<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">100</span> <span class="hljs-number">200</span>]<br>[<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">20</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">100</span> <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure>
<p>s1 从 slice 索引2（闭区间）到索引5（开区间，元素真正取到索引4），长度为3，容量默认到数组结尾，为8。 s2 从 s1 的索引2（闭区间）到索引6（开区间，元素真正取到索引5），容量到索引7（开区间，真正到索引6），为5。<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220906231135.png"></p>
<p>接着，向 s2 尾部追加一个元素 100.s2 容量刚好够，直接追加。不过，这会修改原始数组对应位置的元素。这一改动，数组和 s1 都可以看得到。<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220906231309.png"></p>
<p>再次向 s2 追加元素200. 这时，s2 的容量不够用，该扩容了。于是，s2 另起炉灶，将原来的元素复制新的位置，扩大自己的容量。并且为了应对未来可能的 append 带来的再一次扩容，s2 会在此次扩容的时候多留一些 buffer，将新的容量将扩大为原始容量的2倍，也就是10了。<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220906231411.png"></p>
<p>最后，修改 s1 索引为2位置的元素.这次只会影响原始数组相应位置的元素。它影响不到 s2 了，人家已经远走高飞了。<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220906231432.png"></p>
<p>总结:</p>
<ul>
<li>数组&#x2F;切片在截取时，如不显示指定容量，默认到数组结尾</li>
<li>截取得到的数组&#x2F;切片，只会打印和访问其长度以内的元素，但是实际底层数组可能不止这些元素(不可访问，但是可继续参与截取)</li>
</ul>
<h3 id="问题3-切片扩容策略"><a href="#问题3-切片扩容策略" class="headerlink" title="问题3: 切片扩容策略?"></a>问题3: 切片扩容策略?</h3><p>1.18版本以前: 当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。<br>1.18版本更新后: 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap &#x3D; oldcap+(oldcap+3*256)&#x2F;4</p>
<blockquote>
<p>在进行上述计算后，对长度又进行了一次内存对齐，所以实际容量会大于等于按上述方法计算出的数值。</p>
</blockquote>
<h4 id="问题3-1-下面的代码输出是什么？"><a href="#问题3-1-下面的代码输出是什么？" class="headerlink" title="问题3.1: 下面的代码输出是什么？"></a>问题3.1: 下面的代码输出是什么？</h4><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>&#125;<br>    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">7</span>)<br>    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">9</span>)<br>    x := <span class="hljs-built_in">append</span>(s, <span class="hljs-number">11</span>)<br>    y := <span class="hljs-built_in">append</span>(s, <span class="hljs-number">12</span>)<br>    fmt.Println(s, x, y)<br>&#125;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>代码</th>
<th>切片对应状态</th>
</tr>
</thead>
<tbody><tr>
<td>s:&#x3D;[]int{5}</td>
<td>s 只有一个元素，[5]</td>
</tr>
<tr>
<td>s&#x3D;append(s, 7)</td>
<td>s 扩容，容量变为2，[5, 7]</td>
</tr>
<tr>
<td>s&#x3D;append(s, 9)</td>
<td>s 扩容，容量变为4，[5, 7, 9]。注意，这时 s 长度是3，容量为4</td>
</tr>
<tr>
<td>x:&#x3D;append(s, 11)</td>
<td>由于 s 的底层数组仍然有空间，因此并不会扩容。这样，底层数组就变成了 [5, 7, 9, 11]。注意，此时 s &#x3D; [5, 7, 9]，容量为4；x &#x3D; [5, 7, 9, 11]，容量为4。这里 s 不变</td>
</tr>
<tr>
<td>y:&#x3D;append(s, 12)</td>
<td>这里还是在 s 元素的尾部追加元素，由于 s 的长度为3，容量为4，所以直接在底层数组索引为3的地方填上12。结果：s &#x3D; [5, 7, 9]，y &#x3D; [5, 7, 9, 12]，x &#x3D; [5, 7, 9, 12]，x，y 的长度均为4，容量也均为4</td>
</tr>
</tbody></table>
<blockquote>
<p>这里要注意的是，append函数执行完后，返回的是一个全新的 slice，并且对传入的 slice 并不影响。（但是底层数组是同一个）</p>
</blockquote>
]]></content>
      <categories>
        <category>Go学习笔记</category>
      </categories>
      <tags>
        <tag>GoLang数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法专题</title>
    <url>/2022/09/22/LeetCode/%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h2 id="二分法常见的几种题目类型"><a href="#二分法常见的几种题目类型" class="headerlink" title="二分法常见的几种题目类型"></a>二分法常见的几种题目类型</h2><ul>
<li>查找特定值</li>
<li>查找第一个大于(或等于)特定值的元素  – 「找下界」</li>
<li>查找最后一个小于(或等于)特定值的元素 – 「找上界」</li>
</ul>
<h2 id="二分法通用模板"><a href="#二分法通用模板" class="headerlink" title="二分法通用模板"></a>二分法通用模板</h2><p>二分查找无论是找下界、还是找上界、还是找特定值，都可以套用「找下界」的模板代码：</p>
<ul>
<li>循环条件为 left &lt;&#x3D; right，表示闭区间不为空</li>
<li>if 的判定条件和给定的比较规则是一致的：比如要找满足 x &gt;&#x3D; target 的第一个元素，就令 if nums[m] &gt;&#x3D; target；要找满足 x &gt; target 的第一个元素，就令 if nums[m] &gt; target</li>
<li>if 为真时，更新 right：right &#x3D; mid - 1；否则 left &#x3D; mid + 1</li>
<li>当循环结束时，left 就指向下界，right 指向「互补条件」的上界</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123;<br>        mid := (left + right) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= target &#123;  <span class="hljs-comment">// 此处需要条件与题目要求一致</span><br>            right = mid<span class="hljs-number">-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid+<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>互补条件: 上述模板中left代表的是大于等于target的第一个元素， right代表的是小于target的最后一个元素。因此可以将取上界问题转换为其互补的取下界问题，并将返回值改为right</p>
</blockquote>
<h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><table>
<thead>
<tr>
<th>题目链接</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode.cn/problems/kth-missing-positive-number/">1539. 第 k 个缺失的正整数</a></td>
<td>二分法取上界问题变形</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>Go逃逸分析</title>
    <url>/2022/10/04/GoNote/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-什么是逃逸分析"><a href="#1-什么是逃逸分析" class="headerlink" title="1. 什么是逃逸分析"></a>1. 什么是逃逸分析</h2><p>在C&#x2F;C++中，对内存的操作经常需要小心翼翼，比如下面这段代码就隐藏了一个陷阱: 函数内部定义的局部变量，其内存是在栈上分配的(静态内存分布)，函数执行完毕后内存会被销毁。因此这段代码会直接崩溃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//c++</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> &amp;t;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了避免这个问题，需要对这段代码做一点改进. 通过new创建的变量位于堆上，不会随着函数执行完成销毁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* t = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    *t = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是这样依旧有一个问题，调用者依旧需要记得在适当的时候删除这个对象，不然就会造成内存泄露。</p>
<p>综上，C&#x2F;C++等语言的内存分配有两个痛点:</p>
<ol>
<li>需要时刻注意内存的分配位置，是在栈上还是堆上</li>
<li>堆上的内存需要手动释放</li>
</ol>
<p>Go优雅的解决了这两个问题: 通过<code>逃逸分析</code>决定内存分配的位置； 通过<code>垃圾回收</code>自动释放堆上的内存。</p>
<blockquote>
<p>在编译原理中，分析指针动态范围的方法被称之为逃逸分析。当一个对象的指针被多个方法或线程引用时，则称这个指针发生了逃逸，逃逸分析决定一个变量分配在堆上还是栈上。</p>
</blockquote>
<h2 id="2-逃逸分析的作用"><a href="#2-逃逸分析的作用" class="headerlink" title="2. 逃逸分析的作用"></a>2. 逃逸分析的作用</h2><p>逃逸分析把变量合理的分配到它该去的地方。即使是new函数申请的内存，如果函数退出后就没有用了，那么就会将内存分配到栈上。反之，即使一个普通变量，发现函数退出之后依旧还有引用，那就分配到堆上。</p>
<p>如果变量都分配到堆上，堆上的内存分配速度较慢，并且因为堆无法像栈一样自动释放内存，就会引起频繁的垃圾回收，从而消耗较多的性能。</p>
<h2 id="3-逃逸分析的原则"><a href="#3-逃逸分析的原则" class="headerlink" title="3. 逃逸分析的原则"></a>3. 逃逸分析的原则</h2><p>编译器会分析代码的特征和生命周期，只有在编译器<code>可以证明函数返回后不会再被引用</code>的变量才会分配到栈上，其他情况下都是分配到堆。分配原则如下:</p>
<ol>
<li>如果变量在函数外部没有引用，则<code>优先</code>放到栈上</li>
<li>如果变量在函数外部存在引用，则<code>一定</code>放到堆上</li>
</ol>
<p>第一条原则中，为什么是优先，而不是一定呢? 加入我们申请了一个很大的数组，申请内存过大，超过了栈的存储能力，这时候就会放到堆上。</p>
<h2 id="4-如何确定发生逃逸"><a href="#4-如何确定发生逃逸" class="headerlink" title="4. 如何确定发生逃逸"></a>4. 如何确定发生逃逸</h2><p>Go提供了相关命令，可以查看是否发生逃逸</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build -gcflags <span class="hljs-string">&#x27;-m -I&#x27;</span> main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure>
<ul>
<li>-m 用于输出编译器的优化细节</li>
<li>-I 关闭内联优化，避免逃逸被编译器的内联优化抹除</li>
</ul>
<h2 id="5-Go的堆栈与C-x2F-C-的区别"><a href="#5-Go的堆栈与C-x2F-C-的区别" class="headerlink" title="5. Go的堆栈与C&#x2F;C++的区别"></a>5. Go的堆栈与C&#x2F;C++的区别</h2><p>C&#x2F;C++中提到的堆与栈本质上是<code>操作系统级别</code>的概念，在程序启动时，操作系统会自动维护一个程序消耗内存的地址空间，并从逻辑上划分为堆内存和栈内存。此时申请一个局部变量，会执行压栈，当离开作用域后自动释放(自动释放的本质是该位置可被下次压栈覆盖)；对于堆而言，每次申请会将所需的地址从维护的堆内存地址空间中分配出去，归还时再合并到所维护的地址空间中</p>
<p>Go既然也运行在操作系统上，自然也拥有上述堆与栈的概念。但是传统意义上的<code>栈</code>被Go的运行时全部消耗了，用于维护各个组件间的协调，例如调度器、垃圾回收等。对于用户态的Go代码，所消耗的堆和栈，实际上都是Go运行时向操作系统申请的堆内存，构成逻辑上的堆和栈。因此Go程序的栈空间相对只有1M的C&#x2F;C++而言大得多(1GB)</p>
]]></content>
      <categories>
        <category>Go学习笔记</category>
      </categories>
      <tags>
        <tag>逃逸分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Go延迟语句</title>
    <url>/2022/10/05/GoNote/%E5%BB%B6%E8%BF%9F%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="1-延迟语句是什么"><a href="#1-延迟语句是什么" class="headerlink" title="1.延迟语句是什么"></a>1.延迟语句是什么</h2><p><code>defer</code>语句是Go语言提供的一种用于注册延迟调用的机制: 让函数或语句可以在当前函数执行完成后(包括return和panic)执行。可以借助defer的特性方便的在函数结束前做一些清理操作(例如释放数据库连接等)</p>
<p>defer的使用也可以解决一些异常场景下的资源释放问题</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">t.mu.Lock()<br>rand.Intn(param)<br>r.mu.Unlock()<br></code></pre></td></tr></table></figure>
<p>在正常情况下，不使用defer没什么问题。但是当rand函数发生panic时，Unlock将不会被执行，进而导致程序异常。</p>
<h2 id="2-延迟语句的执行"><a href="#2-延迟语句的执行" class="headerlink" title="2.延迟语句的执行"></a>2.延迟语句的执行</h2><p>每次遇到defer语句时，会把函数压栈，函数参数会被复制下来，当外层函数退出时，defer函数会按照定义的顺序<code>逆序执行</code>。</p>
<blockquote>
<p>注意，在return后定义的defer不会起作用</p>
</blockquote>
<p>defer函数定义时，对外部变量有两种引用方式:</p>
<ol>
<li>函数参数: 定义时就把参数传递给defer，并cache起来。相当于快照机制</li>
<li>闭包引用: 真正执行的时候根据上下文确定具体的值。是动态变化的</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br>  <span class="hljs-keyword">defer</span> fmt.Println(n)  <span class="hljs-comment">// 函数传参</span><br>  <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;fmt.Println(n)&#125;()  <span class="hljs-comment">// 闭包引用</span><br><br>  n = <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">3<br>0<br></code></pre></td></tr></table></figure>

<h2 id="3-延迟语句拆解"><a href="#3-延迟语句拆解" class="headerlink" title="3. 延迟语句拆解"></a>3. 延迟语句拆解</h2><p>想要理解defer语句的执行时机，需要先理解下面这条语句</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">return</span> xxx<br></code></pre></td></tr></table></figure>
<p>上面这条语句编译之后，实际上执变成了三条语句</p>
<ol>
<li>返回值 &#x3D; xxx</li>
<li>调用defer</li>
<li>空的return</li>
</ol>
<p>通过一个例子来具体解释下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>)&#123;<br>  t := <span class="hljs-number">5</span><br>  <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;t = t + <span class="hljs-number">5</span>&#125;()<br>  <span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure>
<p>拆解后代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>)&#123;<br>  t := <span class="hljs-number">5</span><br><br>  <span class="hljs-comment">// 1. 赋值指令</span><br>  r = t<br><br>  <span class="hljs-comment">// 2. defer语句被插入其中</span><br>  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    t = t + <span class="hljs-number">5</span><br>  &#125;()<br><br>  <span class="hljs-comment">// 3. 空的return</span><br>  <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-延迟语句与recover配合使用"><a href="#4-延迟语句与recover配合使用" class="headerlink" title="4. 延迟语句与recover配合使用"></a>4. 延迟语句与recover配合使用</h2><p>当我们的程序在遇到严重问题导致panic时，会停掉当前正在执行的程序(不只是出问题的线程)，他会有序的执行完当前线程的defer语句，其他线程的defer不做保证。所以需要在线程或协程的defer语句中增加<code>revocer</code>语句，防止程序直接挂掉(类似Python的try语句)。</p>
<blockquote>
<p>需要注意的是，recover语句只在defer函数中调用才有效</p>
</blockquote>
<p>使用方法如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">defer</span> f()<br>  <span class="hljs-built_in">panic</span>&#123;<span class="hljs-number">1</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); e != <span class="hljs-literal">nil</span>&#123;<br>    fmt.Println(<span class="hljs-string">&quot;recover&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go学习笔记</category>
      </categories>
      <tags>
        <tag>延迟语句</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础架构</title>
    <url>/2022/10/09/MySQL/1.MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h2><h3 id="1-MySQL基本架构梳理"><a href="#1-MySQL基本架构梳理" class="headerlink" title="1. MySQL基本架构梳理"></a>1. MySQL基本架构梳理</h3><p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p>
<p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>
<img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" style="zoom: 33%;" />

<h3 id="2-各模块细分特性"><a href="#2-各模块细分特性" class="headerlink" title="2.各模块细分特性"></a>2.各模块细分特性</h3><h4 id="2-1-连接器"><a href="#2-1-连接器" class="headerlink" title="2.1 连接器"></a>2.1 连接器</h4><p>验证完用户名密码后会查询拥有的权限，之后该连接中所有的权限判断逻辑都依赖此时读到的权限(也就是说修改权限之后重新登陆才会生效)</p>
<h4 id="2-2-查询缓存"><a href="#2-2-查询缓存" class="headerlink" title="2.2 查询缓存"></a>2.2 查询缓存</h4><p>查询请求会优先在缓存中查找数据，之前执行过的语句与结果会以key-value的形式储存在内存中；</p>
<p>不建议使用，一个表上主要有更新，所有的查询缓存都会被清空，对于更新频率较高的表性价比很低，可以设置为显示指定是否使用缓存；</p>
<p>MySQL 8.0已整体移除；</p>
<h4 id="2-3-分析器"><a href="#2-3-分析器" class="headerlink" title="2.3 分析器"></a>2.3 分析器</h4><p>词法解析+语法解析</p>
<h4 id="2-4-优化器"><a href="#2-4-优化器" class="headerlink" title="2.4 优化器"></a>2.4 优化器</h4><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>
<h4 id="2-5-执行器"><a href="#2-5-执行器" class="headerlink" title="2.5 执行器"></a>2.5 执行器</h4><p>鉴权并根据表的引擎定义，去使用这个引擎提供的接口。</p>
<ol>
<li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
]]></content>
      <categories>
        <category>MySQL学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL基础架构</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引模型</title>
    <url>/2022/10/09/MySQL/3.MySQL%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="MySQL的索引模型"><a href="#MySQL的索引模型" class="headerlink" title="MySQL的索引模型"></a>MySQL的索引模型</h2><blockquote>
<p>索引的出现其实就是为了提高数据查询的效率，就像字典的目录一样。一本 500 页的字典，如果你想快速找到其中的某一个汉子的内容，在不借助目录的情况下，只能慢慢的翻阅很浪费时间，而使用拼音查找目录就会快很多。同样，对于数据库的表而言，索引其实就是它的“目录”。</p>
</blockquote>
<h3 id="1-索引的常见模型"><a href="#1-索引的常见模型" class="headerlink" title="1.索引的常见模型"></a>1.索引的常见模型</h3><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里先介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。</p>
<h4 id="1-1-哈希表"><a href="#1-1-哈希表" class="headerlink" title="1.1 哈希表"></a>1.1 哈希表</h4><p>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p>
<p>不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p>
<p>需要注意的是，在哈希表中插入新的key点位是直接追加的，而不是有序的，因此新增节点的速度会很快，但是区间查询的速度会很慢，因此这种模型适用于只有等值查询的场景(Memcached 及其他一些 NoSQL 引擎)。</p>
<h4 id="1-2-有序数组"><a href="#1-2-有序数组" class="headerlink" title="1.2 有序数组"></a>1.2 有序数组</h4><p>有序数组顾名思义，就是一个排好序列表，这种模型的等值查询和范围查询性能都很好(根据二分法找到对应的值或范围的起点)，但是因为每次插入都要保证数组是有序的，所以更新性能较差。</p>
<h4 id="1-3-搜索树"><a href="#1-3-搜索树" class="headerlink" title="1.3 搜索树"></a>1.3 搜索树</h4><p>二叉搜索树同时拥有较高的查询和更新性能，但是如果数据量较大，树的层级会比较深，一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间。</p>
<p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<h3 id="2-Innodb的索引模型"><a href="#2-Innodb的索引模型" class="headerlink" title="2.Innodb的索引模型"></a>2.Innodb的索引模型</h3><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。</p>
<p>假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。索引的组织结构的示意图如下</p>
<img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/dcda101051f28502bd5c4402b292e38d.png" alt="img" style="zoom:50%;" />

<p>索引类型可分为主键索引和非主键索引:</p>
<ul>
<li><p>主键索引的叶子节点存的是整行数据，在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</p>
</li>
<li><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p>
</li>
</ul>
<p>根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？</p>
<ol>
<li><p>如果语句是 select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</p>
</li>
<li><p>如果语句是 select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</p>
</li>
</ol>
<p>可以看出，使用主键索引可以尽量减少扫描次数，提高查询速度</p>
<h3 id="3-索引的维护"><a href="#3-索引的维护" class="headerlink" title="3.索引的维护"></a>3.索引的维护</h3><blockquote>
<p> B+树为了维护索引的有序，插入新值是需要做相应的维护工作，如果依次向后增加数据，逻辑和成本都相对简单。但以上面索引结构的示意图为例，如果要在300和500之间插入数据，则会影响后面的节点，在某些场景下，则还会发生”页分裂”，对性能产生较大影响；同样如果要删除某些数据，也可能会出现”页合并”。</p>
</blockquote>
<h4 id="3-1-MySQL数据表存储结构"><a href="#3-1-MySQL数据表存储结构" class="headerlink" title="3.1 MySQL数据表存储结构"></a>3.1 MySQL数据表存储结构</h4><p>假设你已经装好了MySQL最新的5.7版本，并且你创建了一个<code>windmills</code>库（schema）和<code>wmills</code>表。在文件目录（通常是<code>/var/lib/mysql/</code>）你会看到以下内容：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">data/<br>  windmills/<br>      wmills.ibd<br>      wmills.frm<br></code></pre></td></tr></table></figure>

<p>目录下要注意的是这个叫<code>wmills.ibd</code>的文件。这个文件由多个段（segments）组成，每个段和一个索引相关。段则由更小一级单位–区 组成，每个区的默认大小为1M，页则是区的下一级构成单位，默认体积为16KB。<strong>页是MySQL的最小存储单元</strong></p>
<p>按这样算，一个区可以容纳最多64个页，一个页可以容纳2-N个行。行的数量取决于它的大小，由你的表结构定义 (InnoDB要求页至少要有两个行)</p>
<img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/image-20210630235552804-20210630235741726.png" style="zoom:50%;" />

<h4 id="3-2-InnoDB中的一颗B-树能存储多少行数据"><a href="#3-2-InnoDB中的一颗B-树能存储多少行数据" class="headerlink" title="3.2 InnoDB中的一颗B+树能存储多少行数据"></a>3.2 InnoDB中的一颗B+树能存储多少行数据</h4><p>这里以一颗高度为3的B+树为例(B+树中每行的完整数据都存储在叶子节点，非叶子结点只存储<strong>索引键值</strong>和指向孩子节点的<strong>指针</strong>)</p>
<p>假设主键ID为bigint类型，长度8字节，指针在InnoDB中设置为6字节，这样一个单元总共14字节，一页中可以存储16384&#x2F;14&#x3D;1170个指针，换而言之，<strong>每个非叶子节点中最多可以存储约1200个指针</strong>。</p>
<p>假设一行记录的大小约为1K，一页中则可以存储16&#x2F;1&#x3D;16行数据。</p>
<p>因此可以得出，一颗高度为3的B+树，在行数据为1K左右时，最多可以存储 1200 * 1200 * 16 约 2000万条数据。</p>
<p><img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/image-20210701000330687.png" alt="image-20210701000330687"></p>
<p>参考链接 : <a href="https://zhuanlan.zhihu.com/p/86137284">如何查看根页的Page No以及树高</a></p>
<h4 id="3-3-行数据溢出"><a href="#3-3-行数据溢出" class="headerlink" title="3.3 行数据溢出"></a>3.3 行数据溢出</h4><p>Innodb页的默认大小是16kb, 并且要求一页最少有两行数据(如果只有一行数据, B+TREE就失去了意义，退化成了一条双向链表)，因此一行数据的最大长度是8k;</p>
<p>为了尽量保证一页能存储两行数据，innodb自动将字段中超过768字节的部分存储到另外页中并指向溢出页；但需要注意的是，假如有20个大字段，20 * 768 &gt; 8000，此时依旧超过了一行8k的限制，因此会产生报错</p>
<h4 id="3-4-页分裂和页合并"><a href="#3-4-页分裂和页合并" class="headerlink" title="3.4 页分裂和页合并"></a>3.4 页分裂和页合并</h4><p>根据B+树的特性，为了维护索引的有序性，如果我们插入数据的是有序的，那么只需依次写满数据页，并在写满后切换到下一页继续写入；而当我们不按顺序随机插入数据时，如果插在多条记录之间，则会导致此页内后面的<code>数据依次向后移动</code>，甚至如果页已经满了，则会发生<code>页分裂</code>(例如当前页记录主键id为10、12、14的3条数据且已写满，这时插入一个11，则会在此页之后再增加一个页并改变相邻页之间的指针指向，并将部分数据移动到新页 )，而顺序写入写满页后就不会有移动数据以及页分裂的问题；</p>
<p>与之对应的还有页合并操作，当我们删除一定数量的数据使相邻页的数据分别低于一定比例之后为了节省空间则会发生<code>页合并</code>，移动数据并改变相邻页之间的指针指向，类似于活页本把本页内容摘抄到上一页并将此页拿掉，也是比较消耗性能的；</p>
<blockquote>
<p>因此建议使用自增主键id避免页分裂，使用逻辑删除代替物理删除避免页合并</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL学习笔记</category>
      </categories>
      <tags>
        <tag>索引模型</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL日志模块</title>
    <url>/2022/10/10/MySQL/2.MySQL%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="MySQL-的日志模块"><a href="#MySQL-的日志模块" class="headerlink" title="MySQL 的日志模块"></a>MySQL 的日志模块</h2><h3 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1. redo log"></a>1. redo log</h3><h4 id="1-1-为什么需要-redo-log"><a href="#1-1-为什么需要-redo-log" class="headerlink" title="1.1 为什么需要 redo log"></a>1.1 为什么需要 redo log</h4><p>如果数据更新的过程采用”来一条写入一条”的方式进行更新，会因为数据库的查询&#x2F;写入是随机IO导致时间成本较高；因此记录会先写入redo log(顺序IO)，并在适当的时候写入磁盘，这样就会提升mysql的吞吐性能</p>
<h4 id="1-2-redo-log的具体如何工作-WAL"><a href="#1-2-redo-log的具体如何工作-WAL" class="headerlink" title="1.2 redo log的具体如何工作(WAL)"></a>1.2 redo log的具体如何工作(WAL)</h4><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。这样的一套流程也就是MySQL经常提到的WAL技术(Write-Ahead Logging)</p>
<h4 id="1-3-redo-log的大小以及写满后如何操作"><a href="#1-3-redo-log的大小以及写满后如何操作" class="headerlink" title="1.3 redo log的大小以及写满后如何操作"></a>1.3 redo log的大小以及写满后如何操作</h4><p>redo log是循环写且固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写；write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>
<img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/image-20210606175307845.png" style="zoom: 50%;" />

<h3 id="2-binlog"><a href="#2-binlog" class="headerlink" title="2. binlog"></a>2. binlog</h3><h4 id="2-1-为什么同时有两套日志"><a href="#2-1-为什么同时有两套日志" class="headerlink" title="2.1 为什么同时有两套日志"></a>2.1 为什么同时有两套日志</h4><p> redo log 是InnoDB引擎独有的日志，而binlog是MySQL的Server层独有的日志</p>
<h4 id="2-2-与redo-log的区别"><a href="#2-2-与redo-log的区别" class="headerlink" title="2.2 与redo log的区别"></a>2.2 与redo log的区别</h4><ol>
<li><p>redo log是物理日志，记录的是在某个数据页上做了什么修改，而binlog是逻辑日志，记录的是语句的原始逻辑，比如给id&#x3D;2的这一行某字段+1； </p>
</li>
<li><p>redo log是循环写的，binlog是追加写的</p>
</li>
</ol>
<h3 id="3-两阶段提交"><a href="#3-两阶段提交" class="headerlink" title="3.两阶段提交"></a>3.两阶段提交</h3><p>以 update T set c&#x3D;c+1 where ID&#x3D;1; 语句为例</p>
<h4 id="3-1-内部流程描述"><a href="#3-1-内部流程描述" class="headerlink" title="3.1 内部流程描述"></a>3.1 内部流程描述</h4><ul>
<li>执行器调用存储引擎取到ID&#x3D;1的记录，如果记录本来就在内存中则直接返回，否则先从磁盘读到内存再返回</li>
<li>执行器拿到数据，将对应值+1，调用存储引擎接口将新的数据写入</li>
<li>存储引擎拿到数据后将其更新到内存同时记录到redo log中,并告知执行器执行完成，可以提交(此时redo log的日志状态处于prepare状态)</li>
<li>执行器生成binlog，并写入磁盘</li>
<li>调用事务提交接口，将redolog的日志状态改为commit状态</li>
</ul>
<img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/image-20210606175813038.png" alt="image-20210606175813038" style="zoom:50%;" />

<h4 id="3-2-为什么需要两阶段提交"><a href="#3-2-为什么需要两阶段提交" class="headerlink" title="3.2 为什么需要两阶段提交"></a>3.2 为什么需要两阶段提交</h4><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。</p>
<p>这里可以用反证法进行解释，由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题：</p>
<p>假设当前故障如下，update过程中写完第一个日志，在写第二个日志之前发生crash，会出现什么问题呢?</p>
<ol>
<li><strong>先写redo log 后写binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。</li>
<li><strong>先写binlog后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li>
</ol>
<p>那么两阶段提交下的工作模式，在异常发生时是怎么保证一致性的呢？</p>
<h4 id="3-3-两阶段提交是如何保证一致性的"><a href="#3-3-两阶段提交是如何保证一致性的" class="headerlink" title="3.3 两阶段提交是如何保证一致性的"></a>3.3 两阶段提交是如何保证一致性的</h4><p>已知log的写入顺序可简化为: 写redo log(prepare) -&gt; 写binlog -&gt; 写redo log(commit)</p>
<ol>
<li>在第一步、第二步之间crash: redo log有记录(prepare状态), binlog无记录。此时数据库重启恢复后发现redo log中对应数据未commit因此会回滚，并不会执行更新。而使用binlog恢复备份数据时，因为没有记录因此更新也没有生效。数据一致</li>
<li>在第二步、第三步之间crash: redo log有记录(prepare状态), binlog有记录。此时数据库重启恢复后发现redo log中对应数据未commit但有完整的binlog记录，因此会自动commit，数据最终更新入db。使用binlog恢复备份时，因为有对应的记录所以数据同样更新成功。数据一致</li>
</ol>
]]></content>
      <categories>
        <category>MySQL学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL日志模块</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL缓存机制</title>
    <url>/2022/10/09/MySQL/4.MySQL%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="1-BufferPool"><a href="#1-BufferPool" class="headerlink" title="1. BufferPool"></a>1. BufferPool</h2><h3 id="1-1-什么是BufferPool"><a href="#1-1-什么是BufferPool" class="headerlink" title="1.1 什么是BufferPool"></a>1.1 什么是BufferPool</h3><p>buffer pool 就是内存中的一块缓冲池，用来缓存表和索引的数据。MySQL的数据都是存储在磁盘上的，因此如果每次读写数据都去和磁盘交互的话性能开销较大，所以 innodb 自己维护了一个 buffer pool，在读取数据的时候，会把数据加载到缓冲池中，这样下次再获取就不需要从磁盘读了，直接访问内存中的 buffer pool 即可。更新数据也是一样，直接修改内存中的数据，然后到一定时机才会将这些脏数据刷到磁盘上。</p>
<p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20221011222909.png"></p>
<h3 id="1-2-BufferPool如何保证数据不丢"><a href="#1-2-BufferPool如何保证数据不丢" class="headerlink" title="1.2 BufferPool如何保证数据不丢"></a>1.2 BufferPool如何保证数据不丢</h3><p>在更新内存的同时会将更新操作写入redolog, 这样即使在数据落盘前宕机，数据也可以通过redolog恢复</p>
<h3 id="1-3-BufferPool如何维护数据"><a href="#1-3-BufferPool如何维护数据" class="headerlink" title="1.3 BufferPool如何维护数据"></a>1.3 BufferPool如何维护数据</h3><p>缓冲池维护的是页数据，也就是说，即使你只想从磁盘中获取一条数据，但是 innodb 也会加载一页的数据到缓冲池中，一页默认是 16k。</p>
<p>正常情况下，内存放不下全部的数据库数据，那说明缓冲池需要有淘汰机制，淘汰那些不常被访问的数据页。</p>
<p>按照这个需求，我们很容易想到 <code>LRU</code> 机制，最近最少使用的页面将被淘汰，即维护一个链表，被访问的页面移动到头部，新加的页面也加到头部，同时根据内存使用情况淘汰尾部的页面。</p>
]]></content>
      <categories>
        <category>MySQL学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL缓存机制</tag>
      </tags>
  </entry>
  <entry>
    <title>0x00 靶场搭建</title>
    <url>/2022/12/29/NetworkSafe/0.%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="一、OWASP靶场搭建"><a href="#一、OWASP靶场搭建" class="headerlink" title="一、OWASP靶场搭建"></a>一、OWASP靶场搭建</h1><h2 id="1-靶场介绍"><a href="#1-靶场介绍" class="headerlink" title="1.靶场介绍"></a>1.靶场介绍</h2><p>OWASP Juice shop，该漏洞靶场是由owasp开发的，包含了owasp的十大漏洞，以闯关的模式来进行安全技能训练</p>
<h2 id="2-搭建"><a href="#2-搭建" class="headerlink" title="2.搭建"></a>2.搭建</h2><p>Juice shop是个开源项目，源码可在github上获取. 最方便的方式是使用docker进行安装. (这里使用的版本是<code>v14.3.1</code>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull bkimminich/juice-shop</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p 3000:3000 bkimminich/juice-shop</span><br></code></pre></td></tr></table></figure>

<h2 id="3-预览"><a href="#3-预览" class="headerlink" title="3.预览"></a>3.预览</h2><p>容器启动后访问 <a href="http://localhost:3000/">http://localhost:3000/</a> 界面如下<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20221229143054.png"></p>
<h2 id="4-第一关-Score-Board"><a href="#4-第一关-Score-Board" class="headerlink" title="4.第一关: Score Board"></a>4.第一关: Score Board</h2><blockquote>
<p>考察点: 代码分析</p>
</blockquote>
<p>分析页面源码, 通过搜索关键字等方式找到隐藏的闯关入口以开始闯关。进入<code>开发者模式</code>查看页面源码以及js文件后发现隐藏的<code>/score-board</code>页面</p>
<p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20221229150024.png"></p>
<p>进入此页面后可以正式开始闯关~<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20221229150312.png"></p>
<h1 id="二、DVWA靶场搭建"><a href="#二、DVWA靶场搭建" class="headerlink" title="二、DVWA靶场搭建"></a>二、DVWA靶场搭建</h1><h2 id="1-靶场介绍-1"><a href="#1-靶场介绍-1" class="headerlink" title="1.靶场介绍"></a>1.靶场介绍</h2><p>DVWA 是一套易受攻击的由 PHP&#x2F;Mysql 搭建的 Web 安全测试平台，其主要目标是帮助安全专业人员在法律环境中测试他们的技能和工具，帮助 Web 开发人员更好地了解保护 Web 应用程序的过程</p>
<h2 id="2-搭建-1"><a href="#2-搭建-1" class="headerlink" title="2.搭建"></a>2.搭建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull citizenstig/dvwa</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p 8080:80 citizenstig/dvwa</span><br></code></pre></td></tr></table></figure>

<h2 id="3-配置-amp-预览"><a href="#3-配置-amp-预览" class="headerlink" title="3.配置 &amp; 预览"></a>3.配置 &amp; 预览</h2><p>浏览器打开 <a href="http://localhost:8080/">http://localhost:8080/</a> 就可以看到页面了。这里需要初始化数据库，之后输入自己的用户名和密码。登录成功之后看到下图表示成功</p>
<p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20221229171011.png"></p>
]]></content>
      <categories>
        <category>网安笔记</category>
      </categories>
      <tags>
        <tag>OWASP靶场</tag>
        <tag>DVWA靶场</tag>
      </tags>
  </entry>
  <entry>
    <title>0x03 注入攻击 (理论篇)</title>
    <url>/2022/12/29/NetworkSafe/3.SQL%E6%B3%A8%E5%85%A5(%E7%90%86%E8%AE%BA)/</url>
    <content><![CDATA[<h1 id="一、SQL注入攻击介绍"><a href="#一、SQL注入攻击介绍" class="headerlink" title="一、SQL注入攻击介绍"></a>一、SQL注入攻击介绍</h1><p>Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击。SQL注入是发生于应用程序与数据库层的安全漏洞。注入的漏洞本质是代码和数据未分离，通过在用户可控参数中注入SQL语法，程序未对输入的指令进行合法性判断，注入进去的恶意指令就会被数据库服务器误认为是正常的SQL指令而运行，破坏原有 SQL 结构，达到编写程序时意料之外结果的攻击行为。</p>
<h1 id="二、SQL注入分类"><a href="#二、SQL注入分类" class="headerlink" title="二、SQL注入分类"></a>二、SQL注入分类</h1><ul>
<li><p>回显注入：攻击者可以直接在当前界面内容中获取想要的内容或者通过报错信息 获取想要的内容。</p>
</li>
<li><p>盲注：数据库查询结果无法从直观页面中获取，攻击者通过使用数据库逻辑或使 数据库执行延时等方法获取想要的内容。</p>
</li>
</ul>
<h1 id="三、SQL注入危害"><a href="#三、SQL注入危害" class="headerlink" title="三、SQL注入危害"></a>三、SQL注入危害</h1><ul>
<li>猜解后台数据库，盗取网站的敏感信息。</li>
<li>绕过认证，列如绕过验证登录网站后台。</li>
<li>注入可以借助数据库的存储过程进行提权等操作</li>
</ul>
<h1 id="四、注入攻击的预防"><a href="#四、注入攻击的预防" class="headerlink" title="四、注入攻击的预防"></a>四、注入攻击的预防</h1><p>针对 SQL 注入漏洞的防护，主要是要意识到这种漏洞的存在，不信任任何来自客户端的数据。<br>可以通过过滤一些 SQL 关键字的方式进行防护，比如“select”、“insert”这一类 关键字，“&#96;” （反引号） 、“ ””（双引号）、“–”（ SQL 注释开头）这一类保留字符等。当然因为各种编码和绕过技术，手工进行过滤是不够的，容易遗漏，比较安全的方式是采用语言 预置的功能，例如，用 Java 的 PreparedStatment 进行 SQL 操作。</p>
<p>当然，现在还有很多框架类的数据操作工具可以给我们帮助，常见的数据库持久化框架，都会自动完成对相关数据的过滤和校验。最后，千万不要使用字符串拼接的方式进行 SQL 语句的组装和操作。 </p>
<h1 id="五、盲注技巧"><a href="#五、盲注技巧" class="headerlink" title="五、盲注技巧"></a>五、盲注技巧</h1><blockquote>
<p><a href="https://www.cnblogs.com/zane-s/articles/12371820.html">盲注技巧汇总</a></p>
</blockquote>
<h2 id="1-布尔盲注"><a href="#1-布尔盲注" class="headerlink" title="1. 布尔盲注"></a>1. 布尔盲注</h2><p>常用函数</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">mid</span><span class="hljs-params">(str,start,length)</span></span>  :字符串截取<br><span class="hljs-function"><span class="hljs-title">ORD</span><span class="hljs-params">()</span></span>                  :转换成ascii码<br><span class="hljs-function"><span class="hljs-title">Length</span><span class="hljs-params">()</span></span>               :统计长度<br><span class="hljs-function"><span class="hljs-title">version</span><span class="hljs-params">()</span></span>              :查看数据库版本<br><span class="hljs-function"><span class="hljs-title">database</span><span class="hljs-params">()</span></span>             :查看当前数据库名<br><span class="hljs-function"><span class="hljs-title">user</span><span class="hljs-params">()</span></span>                 :查看当前用户<br></code></pre></td></tr></table></figure>

<p>猜解获取数据库长度:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; or length(database()) &gt; 8 --+    :符合条件返回正确，反之返回错误</span><br></code></pre></td></tr></table></figure>

<p>猜解数据库名:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;or mid(database(),1,1)= &#x27;</span>z<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure>

<p>猜解表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;Or mid(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database() limit 0,1),1,1) = &#x27;</span>a<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure>

<p>猜解字段名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; or (select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;</span>表名<span class="hljs-string">&#x27; limit 1,1)</span><br></code></pre></td></tr></table></figure>

<h2 id="2-延迟盲注"><a href="#2-延迟盲注" class="headerlink" title="2. 延迟盲注"></a>2. 延迟盲注</h2><p>常用函数</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Sleep</span><span class="hljs-params">()</span></span>                           :延迟函数<br><span class="hljs-function"><span class="hljs-title">If</span><span class="hljs-params">(condition,true,false)</span></span>          :条件语句<br><span class="hljs-function"><span class="hljs-title">mid</span><span class="hljs-params">(str,start,length)</span></span>             :字符串截取<br><span class="hljs-function"><span class="hljs-title">ORD</span><span class="hljs-params">()</span></span>                             :转换成ascii码<br><span class="hljs-function"><span class="hljs-title">Length</span><span class="hljs-params">()</span></span>                          :统计长度<br><span class="hljs-function"><span class="hljs-title">version</span><span class="hljs-params">()</span></span>                         :查看数据库版本<br><span class="hljs-function"><span class="hljs-title">database</span><span class="hljs-params">()</span></span>                        :查看当前数据库名<br><span class="hljs-function"><span class="hljs-title">user</span><span class="hljs-params">()</span></span>                            :查看当前用户<br></code></pre></td></tr></table></figure>

<p>猜解数据库总数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; and sleep(if((select count(SCHEMA_NAME) from information_schema.SCHEMATA)= 7,0,5))</span><br></code></pre></td></tr></table></figure>

<h2 id="3-报错盲注"><a href="#3-报错盲注" class="headerlink" title="3. 报错盲注"></a>3. 报错盲注</h2>]]></content>
      <categories>
        <category>网安笔记</category>
      </categories>
      <tags>
        <tag>注入攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>0x02 XSS攻击 (实战篇)</title>
    <url>/2022/12/29/NetworkSafe/2.XSS%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86(%E5%AE%9E%E6%88%98)/</url>
    <content><![CDATA[<h2 id="Juice-Shop-Bonus-Payload-与-DOM-XSS"><a href="#Juice-Shop-Bonus-Payload-与-DOM-XSS" class="headerlink" title="Juice Shop: Bonus Payload 与 DOM XSS"></a>Juice Shop: Bonus Payload 与 DOM XSS</h2><blockquote>
<p>考察点: DOM型XSS攻击<br>难度: 一星</p>
</blockquote>
<p>这两道题的考察点类似，都是对DOM型XSS攻击的练习</p>
<ol>
<li>找到输入框，随意输入内容进行测试<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20221229155444.png"></li>
</ol>
<p>通过试探可以发现一下线索: </p>
<ul>
<li>搜索内容会拼接在url中; </li>
<li>前端html展示时会拼接搜索内容</li>
</ul>
<ol start="2">
<li>构造恶意代码尝试进行注入<br>将题目中提供的payload输入搜索框，回车后注入成功，恶意代码执行成功。此时将浏览器中的url发给他人并诱导点开，即可进行攻击。(比如可以将恶意代码替换为盗取用户cookie逻辑等)<br><code>http://localhost:3000/#/search?q=%3Ciframe%20src%3D%22javascript:alert(%60xss%60)%22%3E</code></li>
</ol>
<p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20221229161831.png"></p>
]]></content>
      <categories>
        <category>网安笔记</category>
      </categories>
      <tags>
        <tag>XSS攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>0x01 XSS攻击 (理论篇)</title>
    <url>/2022/12/29/NetworkSafe/1.XSS%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86(%E7%90%86%E8%AE%BA)/</url>
    <content><![CDATA[<h1 id="一、XSS攻击介绍"><a href="#一、XSS攻击介绍" class="headerlink" title="一、XSS攻击介绍"></a>一、XSS攻击介绍</h1><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p>
<p>为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。</p>
<p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p>
<p>而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。</p>
<h1 id="二、XSS的分类"><a href="#二、XSS的分类" class="headerlink" title="二、XSS的分类"></a>二、XSS的分类</h1><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p>
<h2 id="1-存储型-XSS"><a href="#1-存储型-XSS" class="headerlink" title="1.存储型 XSS"></a>1.存储型 XSS</h2><p>存储型 XSS 的攻击步骤：</p>
<p>攻击者将恶意代码提交到目标网站的数据库中。<br>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。<br>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。<br>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。<br>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<h2 id="2-反射型-XSS"><a href="#2-反射型-XSS" class="headerlink" title="2.反射型 XSS"></a>2.反射型 XSS</h2><p>反射型 XSS 的攻击步骤：</p>
<p>攻击者构造出特殊的 URL，其中包含恶意代码。<br>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。<br>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。<br>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。<br>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p>
<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p>
<h2 id="3-DOM型-XSS"><a href="#3-DOM型-XSS" class="headerlink" title="3.DOM型 XSS"></a>3.DOM型 XSS</h2><p>DOM 型 XSS 的攻击步骤：</p>
<p>攻击者构造出特殊的 URL，其中包含恶意代码。<br>用户打开带有恶意代码的 URL。<br>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。<br>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p>
<blockquote>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p>
</blockquote>
<h1 id="三、XSS的预防"><a href="#三、XSS的预防" class="headerlink" title="三、XSS的预防"></a>三、XSS的预防</h1><h2 id="1-预防存储型和反射型-XSS-攻击"><a href="#1-预防存储型和反射型-XSS-攻击" class="headerlink" title="1.预防存储型和反射型 XSS 攻击"></a>1.预防存储型和反射型 XSS 攻击</h2><h3 id="1-1-纯前端渲染"><a href="#1-1-纯前端渲染" class="headerlink" title="1.1 纯前端渲染"></a>1.1 纯前端渲染</h3><p>浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。然后浏览器执行 HTML 中的 JavaScript。JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。</p>
<p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码</p>
<p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。</p>
<h3 id="1-2-HTML转义"><a href="#1-2-HTML转义" class="headerlink" title="1.2 HTML转义"></a>1.2 HTML转义</h3><p>如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。</p>
<p>常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 &amp; &lt; &gt; “ ‘ &#x2F; 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善。要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。(例如 Java 工程里，常用的转义库为 org.owasp.encoder)</p>
<h2 id="2-预防-DOM型-XSS-攻击"><a href="#2-预防-DOM型-XSS-攻击" class="headerlink" title="2.预防 DOM型 XSS 攻击"></a>2.预防 DOM型 XSS 攻击</h2><p>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。</p>
<p>在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。</p>
<p>如果用 Vue&#x2F;React 技术栈，并且不使用 v-html&#x2F;dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。</p>
<p>DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，<a> 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p>
]]></content>
      <categories>
        <category>网安笔记</category>
      </categories>
      <tags>
        <tag>XSS攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>0x04 注入攻击 (实战篇)</title>
    <url>/2022/12/29/NetworkSafe/4.SQL%E6%B3%A8%E5%85%A5(%E5%AE%9E%E6%88%98)/</url>
    <content><![CDATA[<h2 id="DVWA-回显注入获取敏感数据"><a href="#DVWA-回显注入获取敏感数据" class="headerlink" title="DVWA: 回显注入获取敏感数据"></a>DVWA: 回显注入获取敏感数据</h2><ol>
<li>首先试探所查询的表有多少字段<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20221229183524.png"><br>当执行到 <code>1&#39; order by 3#</code> 时sql语句报错, 说明该查询语句涉及到两个字段</li>
<li>知道列的数量后，接下来我们使用 union select联合查询继续获取信息 <code>1&#39; union select database(),user()#</code><br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20221229184159.png"><br>通过上图返回信息，我们成功获取到：</li>
</ol>
<ul>
<li>当前网站使用数据库为 <code>dvwa</code></li>
<li>当前执行查询用户名为 root@localhost</li>
</ul>
<ol start="3">
<li>下一步是获取该数据库中有哪些表，可以使用以下注入语句<br><code>1&#39; union select table_name,table_schema from information_schema.tables where table_schema= &#39;dvwa&#39;#</code><br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20221229184644.png"><br>此时可以知道dvwa数据库有两个数据表，分别是 guestbook 和 users</li>
<li>推测user表中用户名和密码的字段名称，命中后可以获取完整的用户名&#x2F;密码信息<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20221229185456.png"></li>
</ol>
]]></content>
      <categories>
        <category>网安笔记</category>
      </categories>
      <tags>
        <tag>注入攻击</tag>
      </tags>
  </entry>
</search>
