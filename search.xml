<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 搭建 &amp; 使用指南</title>
    <url>/2022/05/17/Deploy/hexo/</url>
    <content><![CDATA[<h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><blockquote>
<p>Hexo 是一个可以易于上手、部署的静态博客架构。使用node.js作为构建引擎，插件库丰富，可扩展性好。支持MarkDown作为书写语言，可以满足日常博客编写需求</p>
</blockquote>
<h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>安装Hexo前，需要本地环境已经安装有这两个东西:</p>
<ul>
<li>Node.js</li>
<li>Git</li>
</ul>
<p>(这二者的安装就不在这里单独赘述了)</p>
<p>如果你的环境没有问题了，那么就可以开始安装Hexo了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>安装完成后，进入要作为博客资源的目录，执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog  <span class="comment"># 初始化配置</span></span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install  <span class="comment"># 安装依赖包</span></span><br><span class="line">hexo server  <span class="comment"># 在本地启动一个临时服务，可以用来预览和调试</span></span><br></pre></td></tr></table></figure>

<h2 id="撰写博文"><a href="#撰写博文" class="headerlink" title="撰写博文"></a>撰写博文</h2><p>撰写博文也非常简单，在<code>blog</code>目录下执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>例如想要创建一篇名为<code>hello</code>的博文:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post hello</span><br></pre></td></tr></table></figure>

<p>生成的文件路径是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO Created: &lt;blog-dir&gt;/source/_posts/hello.md</span><br></pre></td></tr></table></figure>

<p>打开文件，我们可以post模板已经自动帮我们生成了<code>yaml</code>文件头。其中<code>title</code>是文章的标题，<code>tags</code>是文章的标签。</p>
<p>编辑好文章内容后，执行<code>hexo server</code>就可以看见这篇文章已经发布到博客中了</p>
<h2 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h2><p>上文提到的<code>hexo server</code>的方式，只是在本地搭建了一个临时服务器，只能在本地访问。Hexo本身是一个静态页面的博客系统，因此对服务器的要求极低，Github免费提供的<code>Github Pages</code>就足以满足需求</p>
<h3 id="1-创建托管仓库"><a href="#1-创建托管仓库" class="headerlink" title="1.创建托管仓库"></a>1.创建托管仓库</h3><p>这里建议创建一个名为<code>&lt;username&gt;.github.io</code>的仓库来托管我们的网页(因为正常情况下，我们创建的仓库的github page的url是<code>&lt;username&gt;.github.io/&lt;repo name&gt;/</code>, 在域名之后会有一级仓库名称，这会导致很多页面、主题的相对路径功能出现问题；而使用这种仓库名和域名相同的方式创建的仓库的page的url中就不会包含仓库名)</p>
<h3 id="2-部署配置"><a href="#2-部署配置" class="headerlink" title="2. 部署配置"></a>2. 部署配置</h3><p>在博客的根目录下有一个<code>_config.yml</code>文件，这是博客的主配置文件。最后的<code>Deployment</code>配置项代表我们要使用的部署方式，如果我们要使用Git方式部署，那么需要安装一个hexo-deployer-git插件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后编辑这里的配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: &lt;repo url&gt;  <span class="comment"># 建议使用ssh的方式</span></span><br><span class="line">  branch: [branch]  <span class="comment"># 默认可不填</span></span><br><span class="line">  message: [message]  <span class="comment"># 默认可不填</span></span><br></pre></td></tr></table></figure>

<p>保存配置文件后，执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>上述命令可以简化成:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>现在已经将博客部署到Github了。可以用过<code>http://&lt;username&gt;.github.io</code>来访问自己的博客了</p>
<h2 id="Hexo-配置"><a href="#Hexo-配置" class="headerlink" title="Hexo 配置"></a>Hexo 配置</h2><p>在博客的主配置文件中除了配置部署相关的内容，还可以配置一些自定义的配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: <span class="string">&#x27;&#x27;</span>  <span class="comment"># 站名</span></span><br><span class="line">subtitle: <span class="string">&#x27;&#x27;</span>  <span class="comment"># 副标题</span></span><br><span class="line">description: <span class="string">&#x27;&#x27;</span>  <span class="comment"># 对搜索引擎收录博客会有帮助</span></span><br><span class="line">author: <span class="string">&#x27;&#x27;</span></span><br><span class="line">language: zh-Hans  <span class="comment"># 配置中文显示或者英文显示</span></span><br><span class="line">timezone: <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line">url: https://yoursite.com/ </span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  trailing_html: <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure>
<p>这部分配置只需要将url配置成自己的博客地址即可，例如部署在github page，就可以填 <code>https://&lt;username&gt;.github.io/project</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: ayer  </span><br></pre></td></tr></table></figure>
<p>主题配置，Hexo社区有大量的主题可供选择, 可以参考<a href="https://hexo.io/themes/">官方列表</a></p>
<h2 id="Hexo-主题"><a href="#Hexo-主题" class="headerlink" title="Hexo 主题"></a>Hexo 主题</h2><p>主题的使用也非常简单，这里以<code>AYER</code>主题为例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</span><br></pre></td></tr></table></figure>

<p>把你想要的主题<code>git clone</code>下来，放到<code>themes/</code>下对应的目录中，然后我们修改博客主配置中<code>theme</code>配置，保存后，再次执行<code>hexo server</code>命令，预览一下变化</p>
<p>主题的配置一般放在<code>themes/&lt;themename&gt;/_config.yml</code>文件下，具体配置参考<a href="https://shen-yu.gitee.io/2019/ayer/">官方文档</a>即可</p>
]]></content>
      <categories>
        <category>服务搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus | PromQL</title>
    <url>/2022/07/05/Alert/prometheus-pql/</url>
    <content><![CDATA[<h2 id="0-什么是PromQL"><a href="#0-什么是PromQL" class="headerlink" title="0. 什么是PromQL"></a>0. 什么是PromQL</h2><blockquote>
<p>PromQL（Prometheus Query Language）是 Prometheus 内置的数据查询语言，它能实现对事件序列数据的查询、聚合、逻辑运算等。它并且被广泛应用在 Prometheus 的日常应用当中，包括对数据查询、可视化、告警处理当中。简单地说，PromQL 广泛存在于以 Prometheus 为核心的监控体系中。所以需要用到数据筛选的地方，就会用到 PromQL。例如：监控指标的设置、报警指标的设置等等。</p>
</blockquote>
<h2 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1. 基础用法"></a>1. 基础用法</h2><p>当我们直接使用监控指标名称查询时，可以查询该指标下的所有时间序列。<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220705202637.png"><br>可以看到我们查询出了所有指标名称为 <code>prometheus_http_requests_total</code> 的数据。<br>PromQL 支持户根据时间序列的标签匹配模式来对时间序列进行过滤，目前主要支持两种匹配模式：完全匹配和正则匹配。</p>
<h3 id="1-1-完全匹配"><a href="#1-1-完全匹配" class="headerlink" title="1.1 完全匹配"></a>1.1 完全匹配</h3><p>PromQL 支持使用 &#x3D; 和 !&#x3D; 两种完全匹配模式。</p>
<ul>
<li>等于。通过使用 <code>label=value</code> 可以选择那些标签满足表达式定义的时间序列。</li>
<li>不等于。通过使用 <code>label!=value</code> 则可以根据标签匹配排除时间序列。</li>
</ul>
<p>例如我们上面查询出了所有指标名称为 <code>prometheus_http_requests_total</code> 的数据。这时候我们希望只查看错误的请求，即过滤掉所有 code 标签不是 200 的数据。</p>
<p>那么我们的 PromQL 表达式可以修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;code!=&quot;200&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-正则匹配"><a href="#1-2-正则匹配" class="headerlink" title="1.2 正则匹配"></a>1.2 正则匹配</h3><p>PromQL 还可以使用正则表达式作为匹配条件，并且可以使用多个匹配条件。</p>
<ul>
<li>正向匹配。使用 <code>label=~regx</code> 表示选择那些标签符合正则表达式定义的时间序列。</li>
<li>反向匹配。使用 <code>label!~regx</code> 进行排除。</li>
</ul>
<p>例如我想查询指标 <code>prometheus_http_requests_total</code> 中，所有 handler 标签以 &#x2F;api&#x2F;v1 开头的记录。</p>
<p>那么我的表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;handler=~&quot;/api/v1/.*&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-范围查询"><a href="#1-3-范围查询" class="headerlink" title="1.3 范围查询"></a>1.3 范围查询</h3><p>我们上面直接通过类似 <code>prometheus_http_requests_total</code> 表达式查询时间序列时，同一个指标同一标签只会返回一条数据。这样的表达式我们称之为<code>瞬间向量表达式</code>，返回的结果称之为<code>瞬间向量</code></p>
<p>而如果我们想查询一段时间范围内的样本数据，那么我们就需要用到<code>区间向量表达式</code>，其查询出来的结果称之为<code>区间向量</code>。</p>
<p>时间范围通过时间范围选择器 <code>[]</code> 进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;&#125;[5m]</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220705204103.png"><br>通过查询结果可以看到，此时我们查询出了所有的样本数据，而不再是一个样本数据的统计值。</p>
<p>PromQL的时间范围选择器支持其它时间单位: </p>
<ul>
<li>s - 秒</li>
<li>m - 分</li>
<li>h - 时</li>
<li>d - 天</li>
<li>w - 周</li>
<li>y - 年</li>
</ul>
<h3 id="1-4-时间偏移"><a href="#1-4-时间偏移" class="headerlink" title="1.4 时间偏移"></a>1.4 时间偏移</h3><p>在瞬时向量表达式或者区间向量表达式中，都是以当前时间为基准。如果我们想查询 5 分钟前的瞬时样本数据，或昨天一天的区间内的样本数据呢? 这个时候我们就可以使用位移操作，位移操作的关键字为 <code>offset</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询 5 分钟前的最新数据</span><br><span class="line">http_request_total&#123;&#125; offset 5m</span><br><span class="line"></span><br><span class="line"># 往前移动 1 天，查询 1 天前的数据</span><br><span class="line">http_request_total&#123;&#125;[1d] offset 1d</span><br></pre></td></tr></table></figure>

<h3 id="1-5-聚合查询"><a href="#1-5-聚合查询" class="headerlink" title="1.5 聚合查询"></a>1.5 聚合查询</h3><p>一般情况下，我们通过 PromQL 查询到的数据都是很多的。PromQL 提供的聚合操作可以用来对这些时间序列进行处理，形成一条新的时间序列。</p>
<p>以我们的 <code>prometheus_http_requests_total</code> 指标为例，不加任何条件我们查询到的数据为：<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220705204914.png"></p>
<ul>
<li><p>第一个表达式，计算一共有几条数据: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count(prometheus_http_requests_total)</span><br><span class="line"># 查询结果为8，代表总共有8条数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个表达式，计算所有数据的 value 总和:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(prometheus_http_requests_total)</span><br><span class="line"># 查询结果为307，代表所有数据的value之和为307</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-常用函数"><a href="#2-常用函数" class="headerlink" title="2. 常用函数"></a>2. 常用函数</h2><p>scalar(v instance-vector)是我们第一个见过的函数， 他将瞬时向量转化成标量。</p>
<blockquote>
<p>标量可以用于运算和可视化。例如和瞬时向量可以和标量进行加减乘除运算。只有一个时间序列的瞬时变量可以通过函数scalar()转化为标量。有时候在监控中，我们只需要知道当前的系统是不是健康的，当前磁盘空间是多少，只是后就可以用scalar()得到标量并在可视化工具中展示。</p>
</blockquote>
<p>abs(v instant-vector)可以将瞬时变量中的值转变为绝对值。</p>
<p>increase(v range-vector) 求区间向量的增长量（最新值减最旧值）并返回一个瞬时向量。</p>
]]></content>
      <categories>
        <category>监控告警</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
        <tag>PromQL</tag>
      </tags>
  </entry>
  <entry>
    <title>收藏从未停止 ⏹</title>
    <url>/2022/07/24/Other/%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>速查表</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td>MarkDown</td>
<td><a href="https://markdown.com.cn/">https://markdown.com.cn/</a></td>
</tr>
<tr>
<td>Go面试宝典</td>
<td><a href="https://golang.design/go-questions/slice/vs-array/">https://golang.design/go-questions/slice/vs-array/</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>速查</tag>
      </tags>
  </entry>
  <entry>
    <title>Python单元测试</title>
    <url>/2022/08/10/PythonNote/PythonUnitTest/</url>
    <content><![CDATA[<h2 id="1-PyTest安装"><a href="#1-PyTest安装" class="headerlink" title="1. PyTest安装:"></a>1. PyTest安装:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pip install pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用插件安装</span></span><br><span class="line">&gt;&gt;&gt; pip install pytest-mock  <span class="comment"># mocker插件</span></span><br><span class="line">&gt;&gt;&gt; pip install pytest-cov   <span class="comment"># 单测覆盖率插件</span></span><br></pre></td></tr></table></figure>

<h2 id="2-基础用法"><a href="#2-基础用法" class="headerlink" title="2. 基础用法"></a>2. 基础用法</h2><p>定义一个函数如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_sum</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;calling get_sum function&quot;</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>

<p>为了验证其功能，我们可以编写单测用例如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">test_sum</span>(<span class="params">self</span>):</span><br><span class="line">		result = get_sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">		<span class="built_in">print</span> result</span><br><span class="line">		<span class="keyword">assert</span> result == <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>运行用例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; python -m pytest -v test_tmp.py -s</span><br></pre></td></tr></table></figure>

<h3 id="2-1-命令行参数"><a href="#2-1-命令行参数" class="headerlink" title="2.1 命令行参数"></a>2.1 命令行参数</h3><p>可以通过<code>pytest -help</code> 查看支持的参数。以下是一些常用的参数:</p>
<ul>
<li><code>-v</code>: 输出更详细的用例执行信息, 不使用 -v 参数，运行时不会显示运行的具体测试用例名称；</li>
<li><code>-s</code>: 显示print内容 在运行测试用例时，为了调试或打印一些内容，我们会在代码中加一些print内容，但是这些内容默认不会显示出来。如果带上-s，就可以显示了。</li>
<li><code>-x</code>: 出现一条测试用例失败就退出测试。 </li>
<li><code>-m</code>: 用表达式指定多个标记名。 pytest 提供了一个装饰器 @pytest.mark.xxx，用于标记测试并分组，以便你快速选中并运行，各个分组直接用 and、or 来分割。</li>
</ul>
<h3 id="2-2-选择执行的测试用例-静态"><a href="#2-2-选择执行的测试用例-静态" class="headerlink" title="2.2 选择执行的测试用例(静态)"></a>2.2 选择执行的测试用例(静态)</h3><p>按文件夹执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行指定文件夹及子文件夹下的所有测试用例</span></span><br><span class="line">pytest ../tests</span><br></pre></td></tr></table></figure>

<p>按文件执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行test_tmp.py下的所有的测试用例</span></span><br><span class="line">pytest test_tmp.py</span><br></pre></td></tr></table></figure>

<p>按测试类执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pytest 文件名.py::测试类</span></span><br><span class="line">pytest test_tmp.py::TestTmp</span><br></pre></td></tr></table></figure>

<p>按测试方法执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pytest 文件名.py::测试类::测试方法</span></span><br><span class="line">pytest test_tmp.py::TestTmpFunction::test_sum</span><br></pre></td></tr></table></figure>

<h3 id="选择执行的测试用例-动态"><a href="#选择执行的测试用例-动态" class="headerlink" title="选择执行的测试用例(动态)"></a>选择执行的测试用例(动态)</h3><p>如要使用动态指定测试用例的方式，首先需要给测试用例打标签（mark），比如在 <code>class</code>、<code>method</code> 上加上如下装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.dev_test</span></span><br></pre></td></tr></table></figure>
<p>在运行时，可以根据标签来动态的选择哪些用例需要执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同时选中带有这两个标签的所有测试用例运行</span></span><br><span class="line">pytest -m &quot;mark1 and mark2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选中带有mark1的测试用例，不运行mark2的测试用例</span></span><br><span class="line">pytest -m &quot;mark1 and not mark2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选中带有mark1或 mark2标签的所有测试用例</span></span><br><span class="line">pytest -m &quot;mark1 or mark2&quot;</span><br></pre></td></tr></table></figure>

<p>除此之外还提供了一种通过模糊匹配的方式选择测试用例的方式:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-k 参数是按照文件名、类名、方法名、标签名来模糊匹配的</span></span><br><span class="line">pytest -k xxxPattern</span><br></pre></td></tr></table></figure>

<h2 id="3-mock使用"><a href="#3-mock使用" class="headerlink" title="3. mock使用"></a>3. mock使用</h2><p>pytest自带的unittest框架中默认集成了mock库，PyTest的mock支持是通过插件实现的。相对来讲PyTest使用起来更简单(PyTest的mocker是对原生mock的一个兼容，原生mock支持的功能mocker基本都可以支持)</p>
<h3 id="3-1-基础用法"><a href="#3-1-基础用法" class="headerlink" title="3.1 基础用法"></a>3.1 基础用法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_sum</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;calling get_sum function&quot;</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">test_sum_with_mock</span>(<span class="params">self, mocker</span>):</span><br><span class="line">		mocker.patch(<span class="string">&#x27;test_tmp.get_sum&#x27;</span>, return_value=<span class="number">3</span>)</span><br><span class="line">		result = get_sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">		<span class="built_in">print</span> result</span><br><span class="line">		<span class="keyword">assert</span> result == <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>运行后可以发现，原本<code>get_sum</code>的print内容并没有被打印出来，我们通过<code>mocker.patch</code>方法屏蔽掉了原函数，转而直接返回我们指定的返回结果</p>
<h3 id="3-2-其他用法"><a href="#3-2-其他用法" class="headerlink" title="3.2 其他用法"></a>3.2 其他用法</h3><p>mocker.patch的函数定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unittest.mock.patch(target, new=DEFAULT, spec=<span class="literal">None</span>, create=<span class="literal">False</span>, spec_set=<span class="literal">None</span>, autospec=<span class="literal">None</span>, new_callable=<span class="literal">None</span>, **kwargs)</span><br></pre></td></tr></table></figure>
<p>常用参数含义：</p>
<ul>
<li><code>target</code>: 模拟对象的路径，参数必须是一个str,格式为’package.module.ClassName’，注意这里的格式一定要写对。如果对象和mock函数在同一个文件中，路径要加文件名</li>
<li><code>return_value</code>: 模拟函数返回的结果</li>
<li><code>side_effect</code>: 调用mock时的返回值，可以是函数，异常类，可迭代对象。当设置了该方法时，如果该方法返回值是DEFAULT，那么返回return_value的值，如果不是，则返回该方法的值。 return_value 和 side_effect 同时存在，side_effect会返回。(如果 side_effect 是异常类或实例时，调用模拟程序时将引发异常。如果 side_effect 是可迭代对象，则每次调用 mock 都将返回可迭代对象的下一个值。如果设置为函数时其具体表现会替换被mock函数）</li>
</ul>
<h2 id="4-MagicMock"><a href="#4-MagicMock" class="headerlink" title="4. MagicMock"></a>4. MagicMock</h2><p>在mock的过程中，有时我们需要构造相对复杂的返回值，比如对db操作函数的mock，返回值往往是一个对象。这时候常规做法我们就需要定义一个类，并且将其实例化。<br>这种做法较为麻烦，且不够灵活。Python提供了一个MagicMock方法，我们可以较为方便的构造我们想要的数据类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">test_sum_with_magic_mock</span>(<span class="params">self, mocker</span>):</span><br><span class="line">		o1 = MagicMock(a=<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">print</span> o1.a</span><br><span class="line"></span><br><span class="line">		o2 = MagicMock()</span><br><span class="line">		<span class="built_in">print</span> <span class="built_in">list</span>(o2)</span><br><span class="line">		o2.__iter__.return_value = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">		<span class="built_in">print</span> <span class="built_in">list</span>(o2)</span><br></pre></td></tr></table></figure>
<p>在工程实践中，我们一般对MagicMock在进行一次封装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factory</span>(<span class="params">attrs=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">	kwargs[<span class="string">&#x27;return_value&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">	o = MagicMock(**kwargs)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> attrs:</span><br><span class="line">		<span class="keyword">return</span> o</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">		<span class="built_in">setattr</span>(o, k, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> o</span><br></pre></td></tr></table></figure>

<h2 id="5-数据驱动"><a href="#5-数据驱动" class="headerlink" title="5. 数据驱动"></a>5. 数据驱动</h2><p>某些时候，我们希望我们的单测可以覆盖多种逻辑分支，这时为每一种case都单独写一个测试明显也是不现实的。PyTest为单测提供了参数化功能，也就是数据驱动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">	@pytest.mark.parametrize(<span class="params"><span class="string">&#x27;a, b, sum_result&#x27;</span>, [</span></span></span><br><span class="line"><span class="params"><span class="meta">		(<span class="params"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">		(<span class="params"><span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">	]</span>)</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">test_sum_with_param</span>(<span class="params">self, mocker, a, b, sum_result</span>):</span><br><span class="line">		result = get_sum(a, b)</span><br><span class="line">		<span class="built_in">print</span> result</span><br><span class="line">		<span class="keyword">assert</span> result == sum_result</span><br></pre></td></tr></table></figure>

<h2 id="6-代码覆盖率"><a href="#6-代码覆盖率" class="headerlink" title="6. 代码覆盖率"></a>6. 代码覆盖率</h2><p>PyTest提供了pytest-cov插件来实现代码覆盖率的统计.</p>
<h3 id="6-1-基础用法"><a href="#6-1-基础用法" class="headerlink" title="6.1 基础用法"></a>6.1 基础用法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pytest --cov --cov-report=xml</span><br></pre></td></tr></table></figure>

<h3 id="6-2-生成差异报表"><a href="#6-2-生成差异报表" class="headerlink" title="6.2 生成差异报表"></a>6.2 生成差异报表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; diff-cover coverage.xml --compare-branch=origin/master --html-report report.html --fail-under=80</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法专题</title>
    <url>/2022/09/22/LeetCode/%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h2 id="二分法常见的几种题目类型"><a href="#二分法常见的几种题目类型" class="headerlink" title="二分法常见的几种题目类型"></a>二分法常见的几种题目类型</h2><ul>
<li>查找特定值</li>
<li>查找第一个大于(或等于)特定值的元素  – 「找下界」</li>
<li>查找最后一个小于(或等于)特定值的元素 – 「找上界」</li>
</ul>
<h2 id="二分法通用模板"><a href="#二分法通用模板" class="headerlink" title="二分法通用模板"></a>二分法通用模板</h2><p>二分查找无论是找下界、还是找上界、还是找特定值，都可以套用「找下界」的模板代码：</p>
<ul>
<li>循环条件为 left &lt;&#x3D; right，表示闭区间不为空</li>
<li>if 的判定条件和给定的比较规则是一致的：比如要找满足 x &gt;&#x3D; target 的第一个元素，就令 if nums[m] &gt;&#x3D; target；要找满足 x &gt; target 的第一个元素，就令 if nums[m] &gt; target</li>
<li>if 为真时，更新 right：right &#x3D; mid - 1；否则 left &#x3D; mid + 1</li>
<li>当循环结束时，left 就指向下界，right 指向「互补条件」的上界</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123;<br>        mid := (left + right) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= target &#123;  <span class="hljs-comment">// 此处需要条件与题目要求一致</span><br>            right = mid<span class="hljs-number">-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid+<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>互补条件: 上述模板中left代表的是大于等于target的第一个元素， right代表的是小于target的最后一个元素。因此可以将取上界问题转换为其互补的取下界问题，并将返回值改为right</p>
</blockquote>
<h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><table>
<thead>
<tr>
<th>题目链接</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode.cn/problems/kth-missing-positive-number/">1539. 第 k 个缺失的正整数</a></td>
<td>二分法取上界问题变形</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>Go逃逸分析</title>
    <url>/2022/10/04/GoNote/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-什么是逃逸分析"><a href="#1-什么是逃逸分析" class="headerlink" title="1. 什么是逃逸分析"></a>1. 什么是逃逸分析</h2><p>在C&#x2F;C++中，对内存的操作经常需要小心翼翼，比如下面这段代码就隐藏了一个陷阱: 函数内部定义的局部变量，其内存是在栈上分配的(静态内存分布)，函数执行完毕后内存会被销毁。因此这段代码会直接崩溃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//c++</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> &amp;t;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了避免这个问题，需要对这段代码做一点改进. 通过new创建的变量位于堆上，不会随着函数执行完成销毁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* t = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    *t = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是这样依旧有一个问题，调用者依旧需要记得在适当的时候删除这个对象，不然就会造成内存泄露。</p>
<p>综上，C&#x2F;C++等语言的内存分配有两个痛点:</p>
<ol>
<li>需要时刻注意内存的分配位置，是在栈上还是堆上</li>
<li>堆上的内存需要手动释放</li>
</ol>
<p>Go优雅的解决了这两个问题: 通过<code>逃逸分析</code>决定内存分配的位置； 通过<code>垃圾回收</code>自动释放堆上的内存。</p>
<blockquote>
<p>在编译原理中，分析指针动态范围的方法被称之为逃逸分析。当一个对象的指针被多个方法或线程引用时，则称这个指针发生了逃逸，逃逸分析决定一个变量分配在堆上还是栈上。</p>
</blockquote>
<h2 id="2-逃逸分析的作用"><a href="#2-逃逸分析的作用" class="headerlink" title="2. 逃逸分析的作用"></a>2. 逃逸分析的作用</h2><p>逃逸分析把变量合理的分配到它该去的地方。即使是new函数申请的内存，如果函数退出后就没有用了，那么就会将内存分配到栈上。反之，即使一个普通变量，发现函数退出之后依旧还有引用，那就分配到堆上。</p>
<p>如果变量都分配到堆上，堆上的内存分配速度较慢，并且因为堆无法像栈一样自动释放内存，就会引起频繁的垃圾回收，从而消耗较多的性能。</p>
<h2 id="3-逃逸分析的原则"><a href="#3-逃逸分析的原则" class="headerlink" title="3. 逃逸分析的原则"></a>3. 逃逸分析的原则</h2><p>编译器会分析代码的特征和生命周期，只有在编译器<code>可以证明函数返回后不会再被引用</code>的变量才会分配到栈上，其他情况下都是分配到堆。分配原则如下:</p>
<ol>
<li>如果变量在函数外部没有引用，则<code>优先</code>放到栈上</li>
<li>如果变量在函数外部存在引用，则<code>一定</code>放到堆上</li>
</ol>
<p>第一条原则中，为什么是优先，而不是一定呢? 加入我们申请了一个很大的数组，申请内存过大，超过了栈的存储能力，这时候就会放到堆上。</p>
<h2 id="4-如何确定发生逃逸"><a href="#4-如何确定发生逃逸" class="headerlink" title="4. 如何确定发生逃逸"></a>4. 如何确定发生逃逸</h2><p>Go提供了相关命令，可以查看是否发生逃逸</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build -gcflags <span class="hljs-string">&#x27;-m -I&#x27;</span> main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure>
<ul>
<li>-m 用于输出编译器的优化细节</li>
<li>-I 关闭内联优化，避免逃逸被编译器的内联优化抹除</li>
</ul>
<h2 id="5-Go的堆栈与C-x2F-C-的区别"><a href="#5-Go的堆栈与C-x2F-C-的区别" class="headerlink" title="5. Go的堆栈与C&#x2F;C++的区别"></a>5. Go的堆栈与C&#x2F;C++的区别</h2><p>C&#x2F;C++中提到的堆与栈本质上是<code>操作系统级别</code>的概念，在程序启动时，操作系统会自动维护一个程序消耗内存的地址空间，并从逻辑上划分为堆内存和栈内存。此时申请一个局部变量，会执行压栈，当离开作用域后自动释放(自动释放的本质是该位置可被下次压栈覆盖)；对于堆而言，每次申请会将所需的地址从维护的堆内存地址空间中分配出去，归还时再合并到所维护的地址空间中</p>
<p>Go既然也运行在操作系统上，自然也拥有上述堆与栈的概念。但是传统意义上的<code>栈</code>被Go的运行时全部消耗了，用于维护各个组件间的协调，例如调度器、垃圾回收等。对于用户态的Go代码，所消耗的堆和栈，实际上都是Go运行时向操作系统申请的堆内存，构成逻辑上的堆和栈。因此Go程序的栈空间相对只有1M的C&#x2F;C++而言大得多(1GB)</p>
]]></content>
      <categories>
        <category>Go学习笔记</category>
      </categories>
      <tags>
        <tag>逃逸分析</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2023/04/09/Redis/bloomFilter/</url>
    <content><![CDATA[<h2 id="一、布隆过滤器简介"><a href="#一、布隆过滤器简介" class="headerlink" title="一、布隆过滤器简介"></a>一、布隆过滤器简介</h2><p>布隆过滤器，英文叫BloomFilter，可以说是一个二进制向量和一系列随机映射函数实现。 可以用于检索一个元素是否在一个集合中。</p>
<p>下图是一个例子，来看一下布隆过滤器的工作流程<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20230409224818.png"></p>
<p>有三个hash函数和一个位数组，例如单词<code>oracle</code>经过三个hash函数，得到第1、4、5位为1，在初始化时将数组的1、4、5位置为1. 后续如果我们需要判断<code>oracle</code>是否在此位数组中，则通过hash函数判断位数组的1、4、5位是否均为1，如果均为1，则判断<code>oracle</code>在此位数组中。这就是布隆过滤器判断元素是否在集合中的原理。</p>
<h2 id="二、布隆过滤器存在的问题"><a href="#二、布隆过滤器存在的问题" class="headerlink" title="二、布隆过滤器存在的问题"></a>二、布隆过滤器存在的问题</h2><p>了解了原理之后，也很容易发现它存在的两个问题: 误判 &amp; 不可删除</p>
<h3 id="1-误判"><a href="#1-误判" class="headerlink" title="1. 误判"></a>1. 误判</h3><p>还是上面的例子，如果<code>bloom</code>经过三个hash算法，需要判断 1、5、10位是否为1，恰好因为位数组中添加<code>oracle</code>和<code>database</code>导致1、5、10位为1，则布隆过滤器会判断<code>bloom</code>在集合中，导致误判。</p>
<p>因此，高效插入和查询的代价就是，它是一个基于概率的数据结构，<em>只能告诉我们一个元素绝对不在集合内，对于存在集合内有一定的误判率。</em></p>
<p>但是布隆过滤器的空间效率和查询时间都远远高于一般的算法，使得这个缺点在某些应用场景中是可以接受的</p>
<h3 id="2-不可删除"><a href="#2-不可删除" class="headerlink" title="2. 不可删除"></a>2. 不可删除</h3><p>布隆过滤器判断一个元素存在就是判断对应位置是否为 1 来确定的，但是如果要删除掉一个元素是不能直接把 1 改成 0 的，因为这个位置可能存在其他元素，直接删除会对其他元素的判定结果产生影响。</p>
<h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><ul>
<li>网页黑名单过滤：由于互联网上存在大量的恶意网站和垃圾网站，为了保护用户的隐私和安全，很多网站都会采用布隆过滤器来过滤黑名单中的网站。</li>
<li>垃圾邮件过滤：在邮件服务器中，需要对接收到的邮件进行分类，将垃圾邮件过滤掉，保证用户只接收到有用的邮件。布隆过滤器可以对邮件进行快速过滤，提高过滤的效率。</li>
<li>缓存过滤：在缓存中，需要快速判断某个键值对是否存在。如果缓存中的键值对非常多，使用线性搜索的方式会非常耗时。这时可以使用布隆过滤器对键进行过滤，减少无用的搜索。</li>
<li>URL去重：爬虫在爬取网页时需要去重，防止重复下载同一个页面。布隆过滤器可以快速判断URL是否已经被爬取过。</li>
</ul>
<h2 id="四、实践中遇到的问题"><a href="#四、实践中遇到的问题" class="headerlink" title="四、实践中遇到的问题"></a>四、实践中遇到的问题</h2><h3 id="1-如何降低误判率-fpp-？"><a href="#1-如何降低误判率-fpp-？" class="headerlink" title="1.如何降低误判率(fpp)？"></a>1.如何降低误判率(fpp)？</h3><p>我们可以提高数组长度以及 hash 计算次数来降低误报率，但是相应的 CPU、内存的消耗也会相应的提高；这需要我们根据自己的业务需要去权衡选择。</p>
<h4 id="1-1-布隆过滤器应该设计为多大？"><a href="#1-1-布隆过滤器应该设计为多大？" class="headerlink" title="1.1 布隆过滤器应该设计为多大？"></a>1.1 布隆过滤器应该设计为多大？</h4><p>假设在布隆过滤器里面有 k 个哈希函数，m 个比特位（也就是位数组长度），以及 n 个已插入元素，错误率会近似于 (1-ekn&#x2F;m)k，所以你只需要先确定可能插入的数据集的容量大小 n，然后再调整 k 和 m 来为你的应用配置过滤器。</p>
<h4 id="1-2-布隆过滤器应该使用多少个哈希函数？"><a href="#1-2-布隆过滤器应该使用多少个哈希函数？" class="headerlink" title="1.2 布隆过滤器应该使用多少个哈希函数？"></a>1.2 布隆过滤器应该使用多少个哈希函数？</h4><p>对于给定的 m（比特位个数）和 n（集合元素个数），最优的 k（哈希函数个数）值为: (m&#x2F;n)ln(2)</p>
<h3 id="2-如何支持删除"><a href="#2-如何支持删除" class="headerlink" title="2.如何支持删除"></a>2.如何支持删除</h3><p>如果要支持删除，最简单的做法就是加一个计数器，就是说位数组的每个位如果不存在就是 0，存在几个元素就存具体的数字，而不仅仅只是存 1。<br>那么这就有一个问题，本来存 1 就是一位就可以满足了，但是如果要存具体的数字比如说 2，那就需要 2 位了，所以带有计数器的布隆过滤器会<code>占用更大的空间</code>。</p>
]]></content>
      <categories>
        <category>Redis学习笔记</category>
      </categories>
      <tags>
        <tag>高性能开发</tag>
      </tags>
  </entry>
  <entry>
    <title>TCC的基本原理与常见问题</title>
    <url>/2024/05/13/SystemDesign/tcc/</url>
    <content><![CDATA[<h2 id="一、TCC基础介绍"><a href="#一、TCC基础介绍" class="headerlink" title="一、TCC基础介绍"></a>一、TCC基础介绍</h2><p>TCC 模式是最经典的分布式事务解决方案，它将分布式事务分为两个阶段来执行，try 阶段对每个分支事务进行预留资源，如果所有分支事务都预留资源成功，则进入 commit 阶段提交全局事务，如果有一个节点预留资源失败则进入 cancel 阶段回滚全局事务。</p>
<p>以传统的订单、库存、账户服务为例，在 try 阶段尝试预留资源，插入订单、扣减库存、扣减金额，这三个服务都是要提交本地事务的，这里可以把资源转入中间表。在 commit 阶段，再把 try 阶段预留的资源转入最终表。而在 cancel 阶段，把 try 阶段预留的资源进行释放，比如把账户金额返回给客户的账户。</p>
<p>注意：try 阶段必须是要提交本地事务的，比如扣减订单金额，必须把钱从客户账户扣掉，如果不扣掉，在 commit 阶段客户账户钱不够了，就会出问题。</p>
<h2 id="二、TCC模型的工作流程"><a href="#二、TCC模型的工作流程" class="headerlink" title="二、TCC模型的工作流程"></a>二、TCC模型的工作流程</h2><p>在分布式事务中，TCC（Try-Confirm-Cancel）是一种常见的事务控制机制，用于确保在分布式系统中事务的一致性和完整性。TCC 模型主要由以下三个角色组成：</p>
<p>TM（Transaction Manager）：事务管理器<br>RM（Resource Manager）：资源管理器<br>TC（Transaction Coordinator）：事务协调器</p>
<h3 id="1-TM（Transaction-Manager）-事务管理器"><a href="#1-TM（Transaction-Manager）-事务管理器" class="headerlink" title="1. TM（Transaction Manager）- 事务管理器"></a>1. TM（Transaction Manager）- 事务管理器</h3><p>事务管理器负责管理整个事务的生命周期。它主要负责以下任务：</p>
<ul>
<li>启动事务</li>
<li>协调事务的执行</li>
<li>决定事务的提交或回滚</li>
</ul>
<p>在 TCC 模型中，事务管理器会调用各个资源管理器的 Try、Confirm 和 Cancel 接口来控制事务的执行。</p>
<h3 id="2-RM（Resource-Manager）-资源管理器"><a href="#2-RM（Resource-Manager）-资源管理器" class="headerlink" title="2. RM（Resource Manager）- 资源管理器"></a>2. RM（Resource Manager）- 资源管理器</h3><p>资源管理器负责具体资源的管理和操作。它主要负责以下任务：</p>
<ul>
<li>实现 Try、Confirm 和 Cancel 接口</li>
<li>执行实际的业务操作</li>
</ul>
<p>在 TCC 模型中，每个资源管理器负责一个或多个资源（例如数据库、文件系统等）的操作，并通过 Try、Confirm 和 Cancel 接口来参与事务的控制。</p>
<h3 id="3-TC（Transaction-Coordinator）-事务协调器"><a href="#3-TC（Transaction-Coordinator）-事务协调器" class="headerlink" title="3. TC（Transaction Coordinator）- 事务协调器"></a>3. TC（Transaction Coordinator）- 事务协调器</h3><p>事务协调器负责协调多个资源管理器，以确保分布式事务的一致性和完整性。它主要负责以下任务：</p>
<ul>
<li>协调各个资源管理器的操作</li>
<li>确保所有资源管理器成功执行 Try 操作后，才能执行 Confirm 操作</li>
<li>如果任何一个资源管理器的 Try 操作失败，则执行 Cancel 操作</li>
</ul>
<h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><p>假设有一个分布式事务，需要在两个系统中分别扣减库存和扣减余额。以下是 TCC 模型的工作流程：</p>
<h3 id="Try-阶段："><a href="#Try-阶段：" class="headerlink" title="Try 阶段："></a>Try 阶段：</h3><ul>
<li>事务管理器（TM）调用库存系统的 Try 接口，预留库存。</li>
<li>事务管理器（TM）调用余额系统的 Try 接口，预留余额。</li>
</ul>
<h3 id="Confirm-阶段："><a href="#Confirm-阶段：" class="headerlink" title="Confirm 阶段："></a>Confirm 阶段：</h3><ul>
<li>如果库存系统和余额系统的 Try 操作都成功，事务管理器（TM）调用库存系统的 Confirm 接口，正式扣减库存。</li>
<li>事务管理器（TM）调用余额系统的 Confirm 接口，正式扣减余额。</li>
</ul>
<h3 id="Cancel-阶段："><a href="#Cancel-阶段：" class="headerlink" title="Cancel 阶段："></a>Cancel 阶段：</h3><ul>
<li>如果库存系统或余额系统的 Try 操作失败，事务管理器（TM）调用库存系统的 Cancel 接口，取消预留的库存。</li>
<li>事务管理器（TM）调用余额系统的 Cancel 接口，取消预留的余额。</li>
</ul>
<h3 id="Demo代码"><a href="#Demo代码" class="headerlink" title="Demo代码"></a>Demo代码</h3><h4 id="1-定义资源管理器（RM）"><a href="#1-定义资源管理器（RM）" class="headerlink" title="1. 定义资源管理器（RM）"></a>1. 定义资源管理器（RM）</h4><figure class="highlight golang"><table><tr><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// RM 接口定义了资源管理器的 Try、Confirm 和 Cancel 操作</span><br><span class="hljs-keyword">type</span> RM <span class="hljs-keyword">interface</span> &#123;<br>	Try() <span class="hljs-type">error</span><br>	Confirm() <span class="hljs-type">error</span><br>	Cancel() <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">// InventoryManager 模拟库存管理器</span><br><span class="hljs-keyword">type</span> InventoryManager <span class="hljs-keyword">struct</span> &#123;<br>	mu      sync.Mutex<br>	stock   <span class="hljs-type">int</span><br>	reserve <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewInventoryManager</span><span class="hljs-params">(stock <span class="hljs-type">int</span>)</span></span> *InventoryManager &#123;<br>	<span class="hljs-keyword">return</span> &amp;InventoryManager&#123;stock: stock&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(im *InventoryManager)</span></span> Try() <span class="hljs-type">error</span> &#123;<br>	im.mu.Lock()<br>	<span class="hljs-keyword">defer</span> im.mu.Unlock()<br>	<span class="hljs-keyword">if</span> im.stock &gt; <span class="hljs-number">0</span> &#123;<br>		im.reserve++<br>		im.stock--<br>		fmt.Println(<span class="hljs-string">&quot;Inventory Try: reserved 1 item&quot;</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Inventory Try: out of stock&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(im *InventoryManager)</span></span> Confirm() <span class="hljs-type">error</span> &#123;<br>	im.mu.Lock()<br>	<span class="hljs-keyword">defer</span> im.mu.Unlock()<br>	<span class="hljs-keyword">if</span> im.reserve &gt; <span class="hljs-number">0</span> &#123;<br>		im.reserve--<br>		fmt.Println(<span class="hljs-string">&quot;Inventory Confirm: confirmed 1 item&quot;</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Inventory Confirm: no item to confirm&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(im *InventoryManager)</span></span> Cancel() <span class="hljs-type">error</span> &#123;<br>	im.mu.Lock()<br>	<span class="hljs-keyword">defer</span> im.mu.Unlock()<br>	<span class="hljs-keyword">if</span> im.reserve &gt; <span class="hljs-number">0</span> &#123;<br>		im.reserve--<br>		im.stock++<br>		fmt.Println(<span class="hljs-string">&quot;Inventory Cancel: canceled 1 item&quot;</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Inventory Cancel: no item to cancel&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// BalanceManager 模拟余额管理器</span><br><span class="hljs-keyword">type</span> BalanceManager <span class="hljs-keyword">struct</span> &#123;<br>	mu      sync.Mutex<br>	balance <span class="hljs-type">int</span><br>	reserve <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBalanceManager</span><span class="hljs-params">(balance <span class="hljs-type">int</span>)</span></span> *BalanceManager &#123;<br>	<span class="hljs-keyword">return</span> &amp;BalanceManager&#123;balance: balance&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bm *BalanceManager)</span></span> Try() <span class="hljs-type">error</span> &#123;<br>	bm.mu.Lock()<br>	<span class="hljs-keyword">defer</span> bm.mu.Unlock()<br>	<span class="hljs-keyword">if</span> bm.balance &gt; <span class="hljs-number">0</span> &#123;<br>		bm.reserve++<br>		bm.balance--<br>		fmt.Println(<span class="hljs-string">&quot;Balance Try: reserved 1 unit&quot;</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Balance Try: insufficient balance&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bm *BalanceManager)</span></span> Confirm() <span class="hljs-type">error</span> &#123;<br>	bm.mu.Lock()<br>	<span class="hljs-keyword">defer</span> bm.mu.Unlock()<br>	<span class="hljs-keyword">if</span> bm.reserve &gt; <span class="hljs-number">0</span> &#123;<br>		bm.reserve--<br>		fmt.Println(<span class="hljs-string">&quot;Balance Confirm: confirmed 1 unit&quot;</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Balance Confirm: no unit to confirm&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bm *BalanceManager)</span></span> Cancel() <span class="hljs-type">error</span> &#123;<br>	bm.mu.Lock()<br>	<span class="hljs-keyword">defer</span> bm.mu.Unlock()<br>	<span class="hljs-keyword">if</span> bm.reserve &gt; <span class="hljs-number">0</span> &#123;<br>		bm.reserve--<br>		bm.balance++<br>		fmt.Println(<span class="hljs-string">&quot;Balance Cancel: canceled 1 unit&quot;</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Balance Cancel: no unit to cancel&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-定义事务管理器（TM）和事务协调器（TC）"><a href="#2-定义事务管理器（TM）和事务协调器（TC）" class="headerlink" title="2. 定义事务管理器（TM）和事务协调器（TC）"></a>2. 定义事务管理器（TM）和事务协调器（TC）</h4><figure class="highlight golang"><table><tr><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// TransactionManager 负责管理事务的生命周期</span><br><span class="hljs-keyword">type</span> TransactionManager <span class="hljs-keyword">struct</span> &#123;<br>	rms []RM<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTransactionManager</span><span class="hljs-params">(rms []RM)</span></span> *TransactionManager &#123;<br>	<span class="hljs-keyword">return</span> &amp;TransactionManager&#123;rms: rms&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TransactionManager)</span></span> Execute() <span class="hljs-type">error</span> &#123;<br>	<span class="hljs-comment">// Try 阶段</span><br>	<span class="hljs-keyword">for</span> _, rm := <span class="hljs-keyword">range</span> tm.rms &#123;<br>		<span class="hljs-keyword">if</span> err := rm.Try(); err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-comment">// 如果 Try 失败，执行 Cancel 阶段</span><br>			tm.Cancel()<br>			<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Transaction failed in Try phase: %v&quot;</span>, err)<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// Confirm 阶段</span><br>	<span class="hljs-keyword">for</span> _, rm := <span class="hljs-keyword">range</span> tm.rms &#123;<br>		<span class="hljs-keyword">if</span> err := rm.Confirm(); err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-comment">// 如果 Confirm 失败，执行 Cancel 阶段</span><br>			tm.Cancel()<br>			<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Transaction failed in Confirm phase: %v&quot;</span>, err)<br>		&#125;<br>	&#125;<br><br>	fmt.Println(<span class="hljs-string">&quot;Transaction succeeded&quot;</span>)<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TransactionManager)</span></span> Cancel() &#123;<br>	<span class="hljs-comment">// Cancel 阶段</span><br>	<span class="hljs-keyword">for</span> _, rm := <span class="hljs-keyword">range</span> tm.rms &#123;<br>		<span class="hljs-keyword">if</span> err := rm.Cancel(); err != <span class="hljs-literal">nil</span> &#123;<br>			fmt.Printf(<span class="hljs-string">&quot;Error during Cancel phase: %v\n&quot;</span>, err)<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行示例</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 创建资源管理器</span><br>	inventoryManager := NewInventoryManager(<span class="hljs-number">10</span>)<br>	balanceManager := NewBalanceManager(<span class="hljs-number">10</span>)<br><br>	<span class="hljs-comment">// 创建事务管理器</span><br>	rms := []RM&#123;inventoryManager, balanceManager&#125;<br>	transactionManager := NewTransactionManager(rms)<br><br>	<span class="hljs-comment">// 执行事务</span><br>	<span class="hljs-keyword">if</span> err := transactionManager.Execute(); err != <span class="hljs-literal">nil</span> &#123;<br>		fmt.Printf(<span class="hljs-string">&quot;Transaction failed: %v\n&quot;</span>, err)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个示例展示了一个简单的 TCC 模型实现，其中包括事务管理器（TM）、资源管理器（RM）和事务协调器（TC）。通过这种方式，可以确保分布式事务的一致性和完整性。</p>
]]></content>
      <categories>
        <category>系统设计方案</category>
      </categories>
      <tags>
        <tag>系统设计方案</tag>
      </tags>
  </entry>
  <entry>
    <title>Google SRE弹性熔断算法（Client-Side Throttling）原理分析</title>
    <url>/2024/08/25/SystemDesign/throttling/</url>
    <content><![CDATA[<p>在微服务架构中，单个服务故障可能引发雪崩效应。传统熔断器（如Hystrix）通过固定阈值触发熔断，虽然能防止系统崩溃，但也存在两大痛点：</p>
<ul>
<li>过度熔断：静态阈值无法适应动态负载，可能误伤健康服务</li>
<li>恢复震荡：从熔断状态恢复时易出现流量突刺，导致二次熔断</li>
</ul>
<p>Google SRE弹性熔断算法（Client-Side Throttling）是一种基于请求成功率动态调整熔断策略的自适应算法，相比传统熔断器的固定阈值模式，其核心思想是通过请求成功率动态计算丢弃概率，实现更平滑的流量控制。以下是其实现逻辑的详细分析：</p>
<blockquote>
<p><a href="https://sre.google/sre-book/handling-overload/#eq2101">Google SRE</a></p>
</blockquote>
<h2 id="一、算法核心思想"><a href="#一、算法核心思想" class="headerlink" title="一、算法核心思想"></a>一、算法核心思想</h2><p>1.1 数学模型：用概率说话<br>算法的核心公式：</p>
<p>$P &#x3D; \max\left(0, \frac{\text{Requests} - K \times \text{Accepts}}{\text{Requests} + 1}\right)$</p>
<ul>
<li>Requests：客户端总请求数（成功+失败）</li>
<li>Accepts：服务端成功处理的请求数</li>
<li>K值：敏感系数（通常1.5-2.0），控制熔断激进程度</li>
</ul>
<p>当 P &gt; 0, 时，每个请求以概率P被丢弃，而非传统熔断器的”全开全关”模式。</p>
<p>该公式的解释如下： 当 requests−K∗accepts&gt;&#x3D;0时，概率 p&#x3D;&#x3D;0，客户端不会主动丢弃请求；反之，则概率 p，会随着 accepts值的变小而增加，即成功接受的请求数越少，本地丢弃请求的概率就越高。通俗点说，Client 可以发送请求直到 requests&#x3D;K∗accepts， 一旦超过限制， 按照概率进行截流。</p>
<p>算法动态调节过程模拟: </p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># 示例：K=2</span>时的状态变化<br>时间轴   请求状态      Requests  Accepts  P值计算      丢弃概率<br>------------------------------------------------------------<br>t<span class="hljs-number">1</span>     成功          <span class="hljs-number">1</span>         <span class="hljs-number">1</span>       <span class="hljs-comment">(1-2*1)</span>/<span class="hljs-comment">(1+1)</span>= <span class="hljs-number">-0.5</span> → <span class="hljs-number">0</span><span class="hljs-meta">%</span><br>t<span class="hljs-number">2</span>     失败          <span class="hljs-number">2</span>         <span class="hljs-number">1</span>       <span class="hljs-comment">(2-2*1)</span>/<span class="hljs-comment">(2+1)</span>= <span class="hljs-number">0</span>/<span class="hljs-number">3</span> → <span class="hljs-number">0</span><span class="hljs-meta">%</span><br>t<span class="hljs-number">3</span>     失败          <span class="hljs-number">3</span>         <span class="hljs-number">1</span>       <span class="hljs-comment">(3-2*1)</span>/<span class="hljs-comment">(3+1)</span>= <span class="hljs-number">0.25</span> → <span class="hljs-number">25</span><span class="hljs-meta">%</span><br>t<span class="hljs-number">4</span>     成功          <span class="hljs-number">4</span>         <span class="hljs-number">2</span>       <span class="hljs-comment">(4-2*2)</span>/<span class="hljs-comment">(4+1)</span>= <span class="hljs-number">0</span> → <span class="hljs-number">0</span><span class="hljs-meta">%</span><br></code></pre></td></tr></table></figure>

<p>从 Google 的文档描述中，该算法在实际中使用效果极为良好，可以使整体上保持一个非常稳定的请求速率。对于后端而言，调整 K 值可以使得自适应限流算法适配不同的后端。</p>
<ul>
<li>降低 K 值会使自适应限流算法更加激进（允许客户端在算法启动时拒绝更多本地请求）</li>
<li>增加 K 值会使自适应限流算法不再那么激进（允许服务端在算法启动时尝试接收更多的请求，与上面相反）</li>
</ul>
<h2 id="二、工程实现"><a href="#二、工程实现" class="headerlink" title="二、工程实现"></a>二、工程实现</h2><ol>
<li>滑动窗口代码实现<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ================== 滑动窗口实现 ==================</span><br><span class="hljs-keyword">type</span> RollingWindow <span class="hljs-keyword">struct</span> &#123;<br>	buckets []<span class="hljs-type">int64</span>     <span class="hljs-comment">// 桶数组（存储成功数）</span><br>	size    <span class="hljs-type">int</span>         <span class="hljs-comment">// 桶数量</span><br>	width   <span class="hljs-type">int64</span>       <span class="hljs-comment">// 单个桶时间宽度（秒）</span><br>	lastPos <span class="hljs-type">int</span>         <span class="hljs-comment">// 当前桶位置</span><br>	mu      sync.Mutex  <span class="hljs-comment">// 互斥锁</span><br>	stopCh  <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRollingWindow</span><span class="hljs-params">(size <span class="hljs-type">int</span>, windowDuration time.Duration)</span></span> *RollingWindow &#123;<br>	rw := &amp;RollingWindow&#123;<br>		size:    size,<br>		buckets: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int64</span>, size),<br>		width: <span class="hljs-type">int64</span>(windowDuration.Seconds()) / <span class="hljs-type">int64</span>(size),<br>		stopCh:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;),<br>	&#125;<br>	<span class="hljs-keyword">go</span> rw.backgroundUpdater()<br>	<span class="hljs-keyword">return</span> rw<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RollingWindow)</span></span> backgroundUpdater() &#123;<br>	ticker := time.NewTicker(time.Duration(rw.width))<br>	<span class="hljs-keyword">defer</span> ticker.Stop()<br><br>	<span class="hljs-keyword">for</span> &#123;<br>		<span class="hljs-keyword">select</span> &#123;<br>		<span class="hljs-keyword">case</span> &lt;-ticker.C:<br>			rw.mu.Lock()<br>			rw.lastPos = (rw.lastPos + <span class="hljs-number">1</span>) % rw.size<br>			atomic.StoreInt64(&amp;rw.buckets[rw.lastPos], <span class="hljs-number">0</span>)<br>			rw.mu.Unlock()<br>		<span class="hljs-keyword">case</span> &lt;-rw.stopCh:<br>			<span class="hljs-keyword">return</span><br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RollingWindow)</span></span> AddSuccess() &#123;<br>	atomic.AddInt64(&amp;rw.buckets[rw.lastPos], <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RollingWindow)</span></span> Sum() <span class="hljs-type">int64</span> &#123;<br>	sum := <span class="hljs-type">int64</span>(<span class="hljs-number">0</span>)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; rw.size; i++ &#123;<br>		sum += atomic.LoadInt64(&amp;rw.buckets[i])<br>	&#125;<br>	<span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>熔断器实现<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ================== 熔断器实现 ==================</span><br><span class="hljs-keyword">type</span> GoogleBreaker <span class="hljs-keyword">struct</span> &#123;<br>	k          <span class="hljs-type">float64</span> <span class="hljs-comment">// 敏感系数</span><br>	requests   <span class="hljs-type">int64</span>   <span class="hljs-comment">// 总请求数（原子操作）</span><br>	window     *RollingWindow<br>	rand       *rand.Rand<br>	probaGuard sync.Mutex<br>&#125;<br><br><span class="hljs-keyword">var</span> ErrServiceUnavailable = errors.New(<span class="hljs-string">&quot;service unavailable&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGoogleBreaker</span><span class="hljs-params">(k <span class="hljs-type">float64</span>, windowSize <span class="hljs-type">int</span>, windowDuration time.Duration)</span></span> *GoogleBreaker &#123;<br>	<span class="hljs-keyword">return</span> &amp;GoogleBreaker&#123;<br>		k:      k,<br>		window: NewRollingWindow(windowSize, windowDuration),<br>		rand:   rand.New(rand.NewSource(time.Now().UnixNano())),<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *GoogleBreaker)</span></span> Do(req <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) <span class="hljs-type">error</span> &#123;<br>	<span class="hljs-comment">// 1. 检查是否触发熔断</span><br>	<span class="hljs-keyword">if</span> err := b.accept(); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> err<br>	&#125;<br><br>	<span class="hljs-comment">// 2. 执行请求并统计结果</span><br>	atomic.AddInt64(&amp;b.requests, <span class="hljs-number">1</span>)<br>	err := req()<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; isFailure(err) &#123;<br>		<span class="hljs-keyword">return</span> err<br>	&#125;<br><br>	<span class="hljs-comment">// 3. 请求成功时更新滑动窗口</span><br>	b.window.AddSuccess()<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *GoogleBreaker)</span></span> accept() <span class="hljs-type">error</span> &#123;<br>	<span class="hljs-comment">// 获取当前统计值</span><br>	accepts := b.window.Sum()<br>	requests := atomic.LoadInt64(&amp;b.requests)<br><br>	<span class="hljs-comment">// 计算丢弃概率</span><br>	ratio := <span class="hljs-type">float64</span>(requests-<span class="hljs-type">int64</span>(b.k*<span class="hljs-type">float64</span>(accepts))) / <span class="hljs-type">float64</span>(requests+<span class="hljs-number">1</span>)<br>	<span class="hljs-keyword">if</span> ratio &lt;= <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br><br>	<span class="hljs-comment">// 概率判断</span><br>	b.probaGuard.Lock()<br>	<span class="hljs-keyword">defer</span> b.probaGuard.Unlock()<br>	<span class="hljs-keyword">if</span> b.rand.Float64() &lt; ratio &#123;<br>		<span class="hljs-keyword">return</span> ErrServiceUnavailable<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// ================== 辅助函数 ==================</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isFailure</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>	<span class="hljs-comment">// 根据业务需求定义哪些错误需要触发熔断</span><br>	<span class="hljs-comment">// 示例：仅网络错误触发熔断</span><br>	_, ok := err.(net.Error)<br>	<span class="hljs-keyword">return</span> ok<br>&#125;<br><br><span class="hljs-comment">// ================== 测试用例 ==================</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestBreaker</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>	breaker := NewGoogleBreaker(<span class="hljs-number">1.5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>*time.Second)<br><br>	<span class="hljs-comment">// 正常请求</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>		err := breaker.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>			<span class="hljs-comment">// 模拟业务逻辑</span><br>			<span class="hljs-keyword">if</span> rand.Intn(<span class="hljs-number">100</span>) &lt; <span class="hljs-number">20</span> &#123; <span class="hljs-comment">// 20%错误率</span><br>				<span class="hljs-keyword">return</span> &amp;net.OpError&#123;&#125;<br>			&#125;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>		&#125;)<br>		t.Logf(<span class="hljs-string">&quot;Request %d: %v&quot;</span>, i, err)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>系统设计方案</category>
      </categories>
      <tags>
        <tag>系统设计方案</tag>
        <tag>Golang</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang服务GC优化</title>
    <url>/2024/09/15/GoNote/GC%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在上半年的服务性能优化项目中，主要针对业务代码不合理的地方进行了瘦身与优化。优化后压测的cpu pprof显示：gc消耗的cpu占比几乎达到25%，gc次数也比较多，因此在优化业务系统后，Golang GC是另一个性能瓶颈，存在很大的优化空间。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先确定问题：在压测过程中GC CPU占比过大，GC次数较多；</p>
<p>初步解决思路：减少GC CPU占比 → <code>减少GC单次耗时</code>或者<code>减少GC次数</code></p>
<p>调研业内常用方案：减少GC单次耗时：减少堆内对象生成；GC次数：减少堆内对象生成、调整GC参数</p>
<p>方案试验及原理探究：详见GC原理分析与GC优化方案</p>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p>Golang 采用了基于并发标记与清扫算法的三色标记法</p>
<p>简单的说就是：GC开始时从根集合对可能需要回收的对象进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。</p>
<h3 id="GC流程"><a href="#GC流程" class="headerlink" title="GC流程"></a>GC流程</h3><ol>
<li><p>Mark Prepare - STW<br>做标记阶段的准备工作，需要停止所有正在运行的goroutine(即STW)，标记根对象，启用内存屏障，内存屏障有点像内存读写钩子，它用于在后续并发标记的过程中，维护三色标记的完备性(三色不变性)，这个过程通常很快，大概在10-30微秒。</p>
</li>
<li><p>Marking - Concurrent<br>标记阶段会将大概25%(gcBackgroundUtilization)的P用于标记对象，逐个扫描所有G的堆栈，执行三色标记，在这个过程中，所有新分配的对象都是黑色，被扫描的G会被暂停，扫描完成后恢复，这部分工作叫后台标记(gcBgMarkWorker)。这会降低系统大概25%的吞吐量，比如MAXPROCS&#x3D;6，那么GC P期望使用率为6*0.25&#x3D;1.5，这150%P会通过专职(Dedicated)&#x2F;兼职(Fractional)&#x2F;懒散(Idle)三种工作模式的Worker共同来完成。<br>这还没完，为了保证在Marking过程中，其它G分配堆内存太快，导致Mark跟不上Allocate的速度，还需要其它G配合做一部分标记的工作，这部分工作叫辅助标记(mutator assists)。在Marking期间，每次G分配内存都会更新它的”负债指数”(gcAssistBytes)，分配得越快，gcAssistBytes越大，这个指数乘以全局的”负载汇率”(assistWorkPerByte)，就得到这个G需要帮忙Marking的内存大小(这个计算过程叫revise)，也就是它在本次分配的mutator assists工作量(gcAssistAlloc)。</p>
</li>
<li><p>Mark Termination - STW<br>标记阶段的最后工作是Mark Termination，关闭内存屏障，停止后台标记以及辅助标记，做一些清理工作，整个过程也需要STW，大概需要60-90微秒。在此之后，所有的P都能继续为应用程序G服务了。</p>
</li>
<li><p>Sweeping - Concurrent<br>在标记工作完成之后，剩下的就是清理过程了，清理过程的本质是将没有被使用的内存块整理回收给上一个内存管理层级(mcache -&gt; mcentral -&gt; mheap -&gt; OS)，清理回收的开销被平摊到应用程序的每次内存分配操作中，直到所有内存都Sweeping完成。当然每个层级不会全部将待清理内存都归还给上一级，避免下次分配再申请的开销，比如Go1.12对mheap归还OS内存做了优化，使用NADV_FREE延迟归还内存。</p>
</li>
</ol>
<h3 id="GC的触发时机"><a href="#GC的触发时机" class="headerlink" title="GC的触发时机"></a>GC的触发时机</h3><p>在 Go 中主要会在三个地方触发 GC：</p>
<ol>
<li>监控线程 runtime.sysmon 定时调用(2min)；</li>
<li>手动调用 runtime.GC 函数进行垃圾收集；</li>
<li>申请内存时 runtime.mallocgc 会根据堆大小判断是否调用；</li>
</ol>
<h2 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h2><h3 id="降低-GC-频率；"><a href="#降低-GC-频率；" class="headerlink" title="降低 GC 频率；"></a>降低 GC 频率；</h3><p>为什么降低GC频率有用呢？<br>因为:</p>
<ol>
<li>一般情况下，mark 耗时要比 sweep 大很多，相比 mark，sweep 更轻量级 (free)</li>
<li>gc 三色标记的时间复杂度，一般是和当前存活 object 总数有关，和当前 unused object 总 数无太大关系</li>
<li>降低 gc 频率意味 unused objects 个数增加，当前存活的 object 总数不会有太大变化，所 以当 gc 真正来临时即使系统中已经积压很多 unused object 也不会让 gc 付出太多代价</li>
</ol>
<p>对于gc频率， cpu， mem的关系，Go官方在稳态下有一个比较简单的兑换比例： doubling GOGC doubles heap memory overheads and halves GC CPU costs</p>
<h3 id="减少堆上对象数量；"><a href="#减少堆上对象数量；" class="headerlink" title="减少堆上对象数量；"></a>减少堆上对象数量；</h3><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="对象池化-减少堆上的对象数量"><a href="#对象池化-减少堆上的对象数量" class="headerlink" title="对象池化(减少堆上的对象数量)"></a>对象池化(减少堆上的对象数量)</h3><p>对象池化：sync.pool</p>
<p>原理： 使用 sync.pool() 缓存对象，减少堆上对象分配数；</p>
<p>sync.pool 是全局对象，读写存在竞争问题，因此在这方面会消耗一定的 CPU，但之所以通常用它优化后 CPU 会有提升，是因为它的对象复用功能对 GC 和内存分配带来的优化，因此 sync.pool 的优化效果取决于锁竞争增加的 CPU 消耗与优化 GC 与内存分配减少的 CPU 消耗这两者的差值；</p>
<h3 id="调整GOGC参数"><a href="#调整GOGC参数" class="headerlink" title="调整GOGC参数"></a>调整GOGC参数</h3><p>原理： GOGC 默认值是 100，也就是下次 GC 触发的 heap 的大小是这次 GC 之后的 heap 的一倍，通过调大 GOGC 值（gcpercent）的方式，达到减少 GC 次数的目的；</p>
<p>公式（go 1.19之前）：gc_trigger &#x3D; heap_marked * (1+gcpercent&#x2F;100)<br>heap_marked：上一个 GC 中被标记的(存活的)字节数；<br>gcpercent：通过 GOGC 来设置，默认是 100，也就是当前内存分配到达上次存活堆内存 2 倍时，触发 GC；</p>
<p>在 go 1.19 及之后，这个公式变为了 heap_marked + (heap_marked + GC roots) * gcpercent &#x2F; 100<br>GC roots：全局变量和goroutine的栈</p>
<p>存在问题： GOGC 参数不易控制，设置较小提升有限，设置较大容易有 OOM 风险，因为堆大小本身是在实时变化的，在任何流量下都设置一个固定值，是一件有风险的事情。</p>
<h3 id="ballast-内存控制"><a href="#ballast-内存控制" class="headerlink" title="ballast 内存控制"></a>ballast 内存控制</h3><p>原理： 仍然是从利用了下次 GC 触发的 heap 的大小是这次 GC 之后的 heap 的一倍这一原理，初始化一个生命周期贯穿整个 Go 应用生命周期的超大 slice，用于内存占位，增大 heap_marked 值降低 GC 频率；实际操作有以下两种方式</p>
<p>相比于设置 GOGC 的优势：</p>
<p>安全性更高，OOM 风险小；<br>是当前业内较为成熟的方案，有很多项目已采用该方案；</p>
<h3 id="GCTuner"><a href="#GCTuner" class="headerlink" title="GCTuner"></a>GCTuner</h3><p>简述： 同上文讲到的设置 GOGC 参数的思路相同，但增加了自动调整的设计，而非在程序初始设置一个固定值，可以有效避免高峰期的 OOM 问题。<br>优点： 不需要修改 GO 源码，通用性较强；<br>缺点： 对内存的控制不够精准。</p>
<h3 id="GO-SetMemoryLimit（go-1-19-及之后）"><a href="#GO-SetMemoryLimit（go-1-19-及之后）" class="headerlink" title="GO SetMemoryLimit（go 1.19 及之后）"></a>GO SetMemoryLimit（go 1.19 及之后）</h3><p>原理：通过对 Go 使用的内存总量设置软内存限制来调整 Go 垃圾收集器的行为。<br>此选项有两种形式：runtime&#x2F;debug调用的新函数SetMemoryLimit和GOMEMLIMIT环境变量，通过设置GOGC&#x3D;off，Go 运行时将始终将堆增长到满内存限制。</p>
<h3 id="Bigcache"><a href="#Bigcache" class="headerlink" title="Bigcache"></a>Bigcache</h3><p>会在内存中分配大数组用以达到 0 GC 的目的，并使用 map[int]int，维护对对象的引用；</p>
<p>（当 map 中的 key 和 value 都是基础类型时，GC 就不会扫到 map 里的 key 和 value）</p>
<p>类似ballast 内存控制手段的效果</p>
<h3 id="堆外分配"><a href="#堆外分配" class="headerlink" title="堆外分配"></a>堆外分配</h3><p>绕过 Go runtime 直接分配内存，使 runtime 感知不到此块内存，从而不增加 GC 开销。</p>
<p>fastcache：直接调用 syscall.mmap 申请堆外内存使用；<br>offheap：使用 cgo 管理堆外内存；<br>问题：管理成本高，灵活性低；</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://segmentfault.com/a/1190000042910688">Golang GC 从原理到优化</a></p>
]]></content>
      <categories>
        <category>Go学习笔记</category>
      </categories>
      <tags>
        <tag>GC优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka Reblance问题排查</title>
    <url>/2025/02/13/Kafka/reblance/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当我们的服务用Golang重构完成后，在发布Kafka Consumer服务过程中遇到一个奇怪的问题就是发布后的一个小时内出现了大量的数据积压，一小时后恢复正常消费。</p>
<p>经过排查发现，服务在这一小时以内频繁进行Reblance，需要排查原因。</p>
<h2 id="Reblance的触发条件"><a href="#Reblance的触发条件" class="headerlink" title="Reblance的触发条件"></a>Reblance的触发条件</h2><ol>
<li>有新的consumer加入</li>
<li>有consumer下线</li>
<li>topic内partition数量变更</li>
<li>consumer client拉取消息后长时间没消费（max.poll.interval.ms，这个时间这个参数，这个是java client里的参数，golang sarama没有这个参数，我们的rebalance不是这个引起的）</li>
</ol>
<p>原因1有这些场景可以引发：服务发布（新服务加入消费者组），consumer被踢下线后重新加入</p>
<p>原因2有这些场景可以引发：服务发布（发布完后旧的服务被删除），心跳连接失败持续一段时间后被Kafka踢下线</p>
<p>原因3需要平台SRE操作，一般情况下不会触发</p>
<p>原因4是java client的参数，golang的sarama组件未使用这个参数，所以我们服务的rebalance不是这个原因导致的</p>
<h2 id="Reblance的执行逻辑"><a href="#Reblance的执行逻辑" class="headerlink" title="Reblance的执行逻辑"></a>Reblance的执行逻辑</h2><p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20250418160734.png" alt="kafka Reblance"></p>
<p>Consumer设置的<code>Config.Consumer.Group.Rebalance.Timeout</code>参数会上传给Coordinator, Coordinator在触发Reblance的时候根据这个设置进行等待，如果未在这个时间内重新加入group，则Reblance流程不会继续等待，会按此时已加入的Consumer进行分配。(如果多个Consumer的设置不一致，会自动使用最小的timeout值)</p>
<h2 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h2><p>结合Reblance的逻辑以及官方文档中提到的一个可能导致无限Reblance的一个错误用法，服务出现长时间Reblance问题的根因如下:</p>
<ol>
<li><p>服务发布的时候，有新的消费服务加入consumer group，触发上述条件1，引发第一次rebalance</p>
</li>
<li><p>在rebalance期间（config.Consumer.Group.Rebalance.Timeout 默认值为 60s），消费者可以处理已经拉取的消息，Kafka topic中新产生的消息不会被消费者拉取，rebalance期间topic中新的消息会被积压</p>
</li>
<li><p>等rebalance完成后，在这一轮rebalance过程中完成rebalance的消费者开始批量拉取消息，进行消费，由于上述步骤2的rebalance过程中，有消息积压，这次拉取的消息会比较多</p>
</li>
<li><p>服务部署的时候，容器是逐步替换并下线的（如果同时发布多个region，整个容器替换的过程时间会更久），就会导致在上述步骤3后还有新的consumer加入consumer group，此时又会触发rebalance的原因1，发起新的一轮rebalance</p>
</li>
<li><p>新一轮rebalance的时候，步骤3中的部分consumer因为拉取到了之前积压的消息，消息比较多，未消费完，就不能加入当前轮次的rebalance，同样的，本轮rebalance过程中，新的Kafka消息也不会被消费者拉取，会被积压</p>
</li>
<li><p>步骤5中rebalance完成后，完成rebalance的消费者拉取消息进行消费</p>
</li>
<li><p>步骤5中，有部分consumer因为消息积压，未能及时处理完消息，没有加入rebalance，等这些consumer处理完拉取的消息，会重新加入consumer group，发起新的一轮rebalance，此时又有一部分consumer因为在消费存量的消息，没能加入本轮的rebalance</p>
</li>
</ol>
<p>重复上述步骤的5~7，消费者consumer group就会持续rebalance，直到topic中存量积压的消息消费完，在某一轮rebalance过程中，全部consumer加入rebalance后，才会停止rebalance</p>
<p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20250418161128.png"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>消费者在消费每条Kafka消息前，判断是否发生rebalance，如果发生了rebalance，就直接返回，不再消费消息，快速加入当前轮次的rebalance，尽快稳定下来。避免因为未消费完拉取的消息，没有加入rebalance而导致不断被Kafka集群下线又不断加入的过程</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(consumer *Consumer)</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// exit as soon as possible once rebalance happens</span><br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-session.Context().Done():<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">default</span>:<br>        &#125;<br><br>        message, ok := &lt;-claim.Messages():<br>        <span class="hljs-keyword">if</span> !ok &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        process(message)<br>        session.MarkMessage(message, <span class="hljs-string">&quot;&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://ekl.shopee.io/guideline/sarama_consumer_usage">How to avoid the infinite rebalance issue on Sarama consumer usage</a></p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>疑难问题排查</tag>
      </tags>
  </entry>
</search>
