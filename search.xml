<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 搭建 &amp; 使用指南</title>
    <url>/2022/05/17/Deploy/hexo/</url>
    <content><![CDATA[<h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><blockquote>
<p>Hexo 是一个可以易于上手、部署的静态博客架构。使用node.js作为构建引擎，插件库丰富，可扩展性好。支持MarkDown作为书写语言，可以满足日常博客编写需求</p>
</blockquote>
<h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>安装Hexo前，需要本地环境已经安装有这两个东西:</p>
<ul>
<li>Node.js</li>
<li>Git</li>
</ul>
<p>(这二者的安装就不在这里单独赘述了)</p>
<p>如果你的环境没有问题了，那么就可以开始安装Hexo了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>安装完成后，进入要作为博客资源的目录，执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog  <span class="comment"># 初始化配置</span></span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install  <span class="comment"># 安装依赖包</span></span><br><span class="line">hexo server  <span class="comment"># 在本地启动一个临时服务，可以用来预览和调试</span></span><br></pre></td></tr></table></figure>

<h2 id="撰写博文"><a href="#撰写博文" class="headerlink" title="撰写博文"></a>撰写博文</h2><p>撰写博文也非常简单，在<code>blog</code>目录下执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>例如想要创建一篇名为<code>hello</code>的博文:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post hello</span><br></pre></td></tr></table></figure>

<p>生成的文件路径是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO Created: &lt;blog-dir&gt;/source/_posts/hello.md</span><br></pre></td></tr></table></figure>

<p>打开文件，我们可以post模板已经自动帮我们生成了<code>yaml</code>文件头。其中<code>title</code>是文章的标题，<code>tags</code>是文章的标签。</p>
<p>编辑好文章内容后，执行<code>hexo server</code>就可以看见这篇文章已经发布到博客中了</p>
<h2 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h2><p>上文提到的<code>hexo server</code>的方式，只是在本地搭建了一个临时服务器，只能在本地访问。Hexo本身是一个静态页面的博客系统，因此对服务器的要求极低，Github免费提供的<code>Github Pages</code>就足以满足需求</p>
<h3 id="1-创建托管仓库"><a href="#1-创建托管仓库" class="headerlink" title="1.创建托管仓库"></a>1.创建托管仓库</h3><p>这里建议创建一个名为<code>&lt;username&gt;.github.io</code>的仓库来托管我们的网页(因为正常情况下，我们创建的仓库的github page的url是<code>&lt;username&gt;.github.io/&lt;repo name&gt;/</code>, 在域名之后会有一级仓库名称，这会导致很多页面、主题的相对路径功能出现问题；而使用这种仓库名和域名相同的方式创建的仓库的page的url中就不会包含仓库名)</p>
<h3 id="2-部署配置"><a href="#2-部署配置" class="headerlink" title="2. 部署配置"></a>2. 部署配置</h3><p>在博客的根目录下有一个<code>_config.yml</code>文件，这是博客的主配置文件。最后的<code>Deployment</code>配置项代表我们要使用的部署方式，如果我们要使用Git方式部署，那么需要安装一个hexo-deployer-git插件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后编辑这里的配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: &lt;repo url&gt;  <span class="comment"># 建议使用ssh的方式</span></span><br><span class="line">  branch: [branch]  <span class="comment"># 默认可不填</span></span><br><span class="line">  message: [message]  <span class="comment"># 默认可不填</span></span><br></pre></td></tr></table></figure>

<p>保存配置文件后，执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>上述命令可以简化成:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>现在已经将博客部署到Github了。可以用过<code>http://&lt;username&gt;.github.io</code>来访问自己的博客了</p>
<h2 id="Hexo-配置"><a href="#Hexo-配置" class="headerlink" title="Hexo 配置"></a>Hexo 配置</h2><p>在博客的主配置文件中除了配置部署相关的内容，还可以配置一些自定义的配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: <span class="string">&#x27;&#x27;</span>  <span class="comment"># 站名</span></span><br><span class="line">subtitle: <span class="string">&#x27;&#x27;</span>  <span class="comment"># 副标题</span></span><br><span class="line">description: <span class="string">&#x27;&#x27;</span>  <span class="comment"># 对搜索引擎收录博客会有帮助</span></span><br><span class="line">author: <span class="string">&#x27;&#x27;</span></span><br><span class="line">language: zh-Hans  <span class="comment"># 配置中文显示或者英文显示</span></span><br><span class="line">timezone: <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line">url: https://yoursite.com/ </span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  trailing_html: <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure>
<p>这部分配置只需要将url配置成自己的博客地址即可，例如部署在github page，就可以填 <code>https://&lt;username&gt;.github.io/project</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: ayer  </span><br></pre></td></tr></table></figure>
<p>主题配置，Hexo社区有大量的主题可供选择, 可以参考<a href="https://hexo.io/themes/">官方列表</a></p>
<h2 id="Hexo-主题"><a href="#Hexo-主题" class="headerlink" title="Hexo 主题"></a>Hexo 主题</h2><p>主题的使用也非常简单，这里以<code>AYER</code>主题为例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</span><br></pre></td></tr></table></figure>

<p>把你想要的主题<code>git clone</code>下来，放到<code>themes/</code>下对应的目录中，然后我们修改博客主配置中<code>theme</code>配置，保存后，再次执行<code>hexo server</code>命令，预览一下变化</p>
<p>主题的配置一般放在<code>themes/&lt;themename&gt;/_config.yml</code>文件下，具体配置参考<a href="https://shen-yu.gitee.io/2019/ayer/">官方文档</a>即可</p>
]]></content>
      <categories>
        <category>服务搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus | PromQL</title>
    <url>/2022/07/05/Alert/prometheus-pql/</url>
    <content><![CDATA[<h2 id="0-什么是PromQL"><a href="#0-什么是PromQL" class="headerlink" title="0. 什么是PromQL"></a>0. 什么是PromQL</h2><blockquote>
<p>PromQL（Prometheus Query Language）是 Prometheus 内置的数据查询语言，它能实现对事件序列数据的查询、聚合、逻辑运算等。它并且被广泛应用在 Prometheus 的日常应用当中，包括对数据查询、可视化、告警处理当中。简单地说，PromQL 广泛存在于以 Prometheus 为核心的监控体系中。所以需要用到数据筛选的地方，就会用到 PromQL。例如：监控指标的设置、报警指标的设置等等。</p>
</blockquote>
<h2 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1. 基础用法"></a>1. 基础用法</h2><p>当我们直接使用监控指标名称查询时，可以查询该指标下的所有时间序列。<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220705202637.png"><br>可以看到我们查询出了所有指标名称为 <code>prometheus_http_requests_total</code> 的数据。<br>PromQL 支持户根据时间序列的标签匹配模式来对时间序列进行过滤，目前主要支持两种匹配模式：完全匹配和正则匹配。</p>
<h3 id="1-1-完全匹配"><a href="#1-1-完全匹配" class="headerlink" title="1.1 完全匹配"></a>1.1 完全匹配</h3><p>PromQL 支持使用 &#x3D; 和 !&#x3D; 两种完全匹配模式。</p>
<ul>
<li>等于。通过使用 <code>label=value</code> 可以选择那些标签满足表达式定义的时间序列。</li>
<li>不等于。通过使用 <code>label!=value</code> 则可以根据标签匹配排除时间序列。</li>
</ul>
<p>例如我们上面查询出了所有指标名称为 <code>prometheus_http_requests_total</code> 的数据。这时候我们希望只查看错误的请求，即过滤掉所有 code 标签不是 200 的数据。</p>
<p>那么我们的 PromQL 表达式可以修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;code!=&quot;200&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-正则匹配"><a href="#1-2-正则匹配" class="headerlink" title="1.2 正则匹配"></a>1.2 正则匹配</h3><p>PromQL 还可以使用正则表达式作为匹配条件，并且可以使用多个匹配条件。</p>
<ul>
<li>正向匹配。使用 <code>label=~regx</code> 表示选择那些标签符合正则表达式定义的时间序列。</li>
<li>反向匹配。使用 <code>label!~regx</code> 进行排除。</li>
</ul>
<p>例如我想查询指标 <code>prometheus_http_requests_total</code> 中，所有 handler 标签以 &#x2F;api&#x2F;v1 开头的记录。</p>
<p>那么我的表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;handler=~&quot;/api/v1/.*&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-范围查询"><a href="#1-3-范围查询" class="headerlink" title="1.3 范围查询"></a>1.3 范围查询</h3><p>我们上面直接通过类似 <code>prometheus_http_requests_total</code> 表达式查询时间序列时，同一个指标同一标签只会返回一条数据。这样的表达式我们称之为<code>瞬间向量表达式</code>，返回的结果称之为<code>瞬间向量</code></p>
<p>而如果我们想查询一段时间范围内的样本数据，那么我们就需要用到<code>区间向量表达式</code>，其查询出来的结果称之为<code>区间向量</code>。</p>
<p>时间范围通过时间范围选择器 <code>[]</code> 进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;&#125;[5m]</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220705204103.png"><br>通过查询结果可以看到，此时我们查询出了所有的样本数据，而不再是一个样本数据的统计值。</p>
<p>PromQL的时间范围选择器支持其它时间单位: </p>
<ul>
<li>s - 秒</li>
<li>m - 分</li>
<li>h - 时</li>
<li>d - 天</li>
<li>w - 周</li>
<li>y - 年</li>
</ul>
<h3 id="1-4-时间偏移"><a href="#1-4-时间偏移" class="headerlink" title="1.4 时间偏移"></a>1.4 时间偏移</h3><p>在瞬时向量表达式或者区间向量表达式中，都是以当前时间为基准。如果我们想查询 5 分钟前的瞬时样本数据，或昨天一天的区间内的样本数据呢? 这个时候我们就可以使用位移操作，位移操作的关键字为 <code>offset</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询 5 分钟前的最新数据</span><br><span class="line">http_request_total&#123;&#125; offset 5m</span><br><span class="line"></span><br><span class="line"># 往前移动 1 天，查询 1 天前的数据</span><br><span class="line">http_request_total&#123;&#125;[1d] offset 1d</span><br></pre></td></tr></table></figure>

<h3 id="1-5-聚合查询"><a href="#1-5-聚合查询" class="headerlink" title="1.5 聚合查询"></a>1.5 聚合查询</h3><p>一般情况下，我们通过 PromQL 查询到的数据都是很多的。PromQL 提供的聚合操作可以用来对这些时间序列进行处理，形成一条新的时间序列。</p>
<p>以我们的 <code>prometheus_http_requests_total</code> 指标为例，不加任何条件我们查询到的数据为：<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220705204914.png"></p>
<ul>
<li><p>第一个表达式，计算一共有几条数据: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count(prometheus_http_requests_total)</span><br><span class="line"># 查询结果为8，代表总共有8条数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个表达式，计算所有数据的 value 总和:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(prometheus_http_requests_total)</span><br><span class="line"># 查询结果为307，代表所有数据的value之和为307</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-常用函数"><a href="#2-常用函数" class="headerlink" title="2. 常用函数"></a>2. 常用函数</h2><p>scalar(v instance-vector)是我们第一个见过的函数， 他将瞬时向量转化成标量。</p>
<blockquote>
<p>标量可以用于运算和可视化。例如和瞬时向量可以和标量进行加减乘除运算。只有一个时间序列的瞬时变量可以通过函数scalar()转化为标量。有时候在监控中，我们只需要知道当前的系统是不是健康的，当前磁盘空间是多少，只是后就可以用scalar()得到标量并在可视化工具中展示。</p>
</blockquote>
<p>abs(v instant-vector)可以将瞬时变量中的值转变为绝对值。</p>
<p>increase(v range-vector) 求区间向量的增长量（最新值减最旧值）并返回一个瞬时向量。</p>
]]></content>
      <categories>
        <category>监控告警</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
        <tag>PromQL</tag>
      </tags>
  </entry>
  <entry>
    <title>收藏从未停止 ⏹</title>
    <url>/2022/07/24/Other/%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>速查表</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td>MarkDown</td>
<td><a href="https://markdown.com.cn/">https://markdown.com.cn/</a></td>
</tr>
<tr>
<td>Go面试宝典</td>
<td><a href="https://golang.design/go-questions/slice/vs-array/">https://golang.design/go-questions/slice/vs-array/</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>速查</tag>
      </tags>
  </entry>
  <entry>
    <title>Python单元测试</title>
    <url>/2022/08/10/PythonNote/PythonUnitTest/</url>
    <content><![CDATA[<h2 id="1-PyTest安装"><a href="#1-PyTest安装" class="headerlink" title="1. PyTest安装:"></a>1. PyTest安装:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pip install pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用插件安装</span></span><br><span class="line">&gt;&gt;&gt; pip install pytest-mock  <span class="comment"># mocker插件</span></span><br><span class="line">&gt;&gt;&gt; pip install pytest-cov   <span class="comment"># 单测覆盖率插件</span></span><br></pre></td></tr></table></figure>

<h2 id="2-基础用法"><a href="#2-基础用法" class="headerlink" title="2. 基础用法"></a>2. 基础用法</h2><p>定义一个函数如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_sum</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;calling get_sum function&quot;</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>

<p>为了验证其功能，我们可以编写单测用例如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">test_sum</span>(<span class="params">self</span>):</span><br><span class="line">		result = get_sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">		<span class="built_in">print</span> result</span><br><span class="line">		<span class="keyword">assert</span> result == <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>运行用例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; python -m pytest -v test_tmp.py -s</span><br></pre></td></tr></table></figure>

<h3 id="2-1-命令行参数"><a href="#2-1-命令行参数" class="headerlink" title="2.1 命令行参数"></a>2.1 命令行参数</h3><p>可以通过<code>pytest -help</code> 查看支持的参数。以下是一些常用的参数:</p>
<ul>
<li><code>-v</code>: 输出更详细的用例执行信息, 不使用 -v 参数，运行时不会显示运行的具体测试用例名称；</li>
<li><code>-s</code>: 显示print内容 在运行测试用例时，为了调试或打印一些内容，我们会在代码中加一些print内容，但是这些内容默认不会显示出来。如果带上-s，就可以显示了。</li>
<li><code>-x</code>: 出现一条测试用例失败就退出测试。 </li>
<li><code>-m</code>: 用表达式指定多个标记名。 pytest 提供了一个装饰器 @pytest.mark.xxx，用于标记测试并分组，以便你快速选中并运行，各个分组直接用 and、or 来分割。</li>
</ul>
<h3 id="2-2-选择执行的测试用例-静态"><a href="#2-2-选择执行的测试用例-静态" class="headerlink" title="2.2 选择执行的测试用例(静态)"></a>2.2 选择执行的测试用例(静态)</h3><p>按文件夹执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行指定文件夹及子文件夹下的所有测试用例</span></span><br><span class="line">pytest ../tests</span><br></pre></td></tr></table></figure>

<p>按文件执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行test_tmp.py下的所有的测试用例</span></span><br><span class="line">pytest test_tmp.py</span><br></pre></td></tr></table></figure>

<p>按测试类执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pytest 文件名.py::测试类</span></span><br><span class="line">pytest test_tmp.py::TestTmp</span><br></pre></td></tr></table></figure>

<p>按测试方法执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pytest 文件名.py::测试类::测试方法</span></span><br><span class="line">pytest test_tmp.py::TestTmpFunction::test_sum</span><br></pre></td></tr></table></figure>

<h3 id="选择执行的测试用例-动态"><a href="#选择执行的测试用例-动态" class="headerlink" title="选择执行的测试用例(动态)"></a>选择执行的测试用例(动态)</h3><p>如要使用动态指定测试用例的方式，首先需要给测试用例打标签（mark），比如在 <code>class</code>、<code>method</code> 上加上如下装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.dev_test</span></span><br></pre></td></tr></table></figure>
<p>在运行时，可以根据标签来动态的选择哪些用例需要执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同时选中带有这两个标签的所有测试用例运行</span></span><br><span class="line">pytest -m &quot;mark1 and mark2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选中带有mark1的测试用例，不运行mark2的测试用例</span></span><br><span class="line">pytest -m &quot;mark1 and not mark2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选中带有mark1或 mark2标签的所有测试用例</span></span><br><span class="line">pytest -m &quot;mark1 or mark2&quot;</span><br></pre></td></tr></table></figure>

<p>除此之外还提供了一种通过模糊匹配的方式选择测试用例的方式:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-k 参数是按照文件名、类名、方法名、标签名来模糊匹配的</span></span><br><span class="line">pytest -k xxxPattern</span><br></pre></td></tr></table></figure>

<h2 id="3-mock使用"><a href="#3-mock使用" class="headerlink" title="3. mock使用"></a>3. mock使用</h2><p>pytest自带的unittest框架中默认集成了mock库，PyTest的mock支持是通过插件实现的。相对来讲PyTest使用起来更简单(PyTest的mocker是对原生mock的一个兼容，原生mock支持的功能mocker基本都可以支持)</p>
<h3 id="3-1-基础用法"><a href="#3-1-基础用法" class="headerlink" title="3.1 基础用法"></a>3.1 基础用法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_sum</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;calling get_sum function&quot;</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">test_sum_with_mock</span>(<span class="params">self, mocker</span>):</span><br><span class="line">		mocker.patch(<span class="string">&#x27;test_tmp.get_sum&#x27;</span>, return_value=<span class="number">3</span>)</span><br><span class="line">		result = get_sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">		<span class="built_in">print</span> result</span><br><span class="line">		<span class="keyword">assert</span> result == <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>运行后可以发现，原本<code>get_sum</code>的print内容并没有被打印出来，我们通过<code>mocker.patch</code>方法屏蔽掉了原函数，转而直接返回我们指定的返回结果</p>
<h3 id="3-2-其他用法"><a href="#3-2-其他用法" class="headerlink" title="3.2 其他用法"></a>3.2 其他用法</h3><p>mocker.patch的函数定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unittest.mock.patch(target, new=DEFAULT, spec=<span class="literal">None</span>, create=<span class="literal">False</span>, spec_set=<span class="literal">None</span>, autospec=<span class="literal">None</span>, new_callable=<span class="literal">None</span>, **kwargs)</span><br></pre></td></tr></table></figure>
<p>常用参数含义：</p>
<ul>
<li><code>target</code>: 模拟对象的路径，参数必须是一个str,格式为’package.module.ClassName’，注意这里的格式一定要写对。如果对象和mock函数在同一个文件中，路径要加文件名</li>
<li><code>return_value</code>: 模拟函数返回的结果</li>
<li><code>side_effect</code>: 调用mock时的返回值，可以是函数，异常类，可迭代对象。当设置了该方法时，如果该方法返回值是DEFAULT，那么返回return_value的值，如果不是，则返回该方法的值。 return_value 和 side_effect 同时存在，side_effect会返回。(如果 side_effect 是异常类或实例时，调用模拟程序时将引发异常。如果 side_effect 是可迭代对象，则每次调用 mock 都将返回可迭代对象的下一个值。如果设置为函数时其具体表现会替换被mock函数）</li>
</ul>
<h2 id="4-MagicMock"><a href="#4-MagicMock" class="headerlink" title="4. MagicMock"></a>4. MagicMock</h2><p>在mock的过程中，有时我们需要构造相对复杂的返回值，比如对db操作函数的mock，返回值往往是一个对象。这时候常规做法我们就需要定义一个类，并且将其实例化。<br>这种做法较为麻烦，且不够灵活。Python提供了一个MagicMock方法，我们可以较为方便的构造我们想要的数据类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">test_sum_with_magic_mock</span>(<span class="params">self, mocker</span>):</span><br><span class="line">		o1 = MagicMock(a=<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">print</span> o1.a</span><br><span class="line"></span><br><span class="line">		o2 = MagicMock()</span><br><span class="line">		<span class="built_in">print</span> <span class="built_in">list</span>(o2)</span><br><span class="line">		o2.__iter__.return_value = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">		<span class="built_in">print</span> <span class="built_in">list</span>(o2)</span><br></pre></td></tr></table></figure>
<p>在工程实践中，我们一般对MagicMock在进行一次封装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factory</span>(<span class="params">attrs=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">	kwargs[<span class="string">&#x27;return_value&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">	o = MagicMock(**kwargs)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> attrs:</span><br><span class="line">		<span class="keyword">return</span> o</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">		<span class="built_in">setattr</span>(o, k, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> o</span><br></pre></td></tr></table></figure>

<h2 id="5-数据驱动"><a href="#5-数据驱动" class="headerlink" title="5. 数据驱动"></a>5. 数据驱动</h2><p>某些时候，我们希望我们的单测可以覆盖多种逻辑分支，这时为每一种case都单独写一个测试明显也是不现实的。PyTest为单测提供了参数化功能，也就是数据驱动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">	@pytest.mark.parametrize(<span class="params"><span class="string">&#x27;a, b, sum_result&#x27;</span>, [</span></span></span><br><span class="line"><span class="params"><span class="meta">		(<span class="params"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">		(<span class="params"><span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">	]</span>)</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">test_sum_with_param</span>(<span class="params">self, mocker, a, b, sum_result</span>):</span><br><span class="line">		result = get_sum(a, b)</span><br><span class="line">		<span class="built_in">print</span> result</span><br><span class="line">		<span class="keyword">assert</span> result == sum_result</span><br></pre></td></tr></table></figure>

<h2 id="6-代码覆盖率"><a href="#6-代码覆盖率" class="headerlink" title="6. 代码覆盖率"></a>6. 代码覆盖率</h2><p>PyTest提供了pytest-cov插件来实现代码覆盖率的统计.</p>
<h3 id="6-1-基础用法"><a href="#6-1-基础用法" class="headerlink" title="6.1 基础用法"></a>6.1 基础用法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pytest --cov --cov-report=xml</span><br></pre></td></tr></table></figure>

<h3 id="6-2-生成差异报表"><a href="#6-2-生成差异报表" class="headerlink" title="6.2 生成差异报表"></a>6.2 生成差异报表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; diff-cover coverage.xml --compare-branch=origin/master --html-report report.html --fail-under=80</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法专题</title>
    <url>/2022/09/22/LeetCode/%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h2 id="二分法常见的几种题目类型"><a href="#二分法常见的几种题目类型" class="headerlink" title="二分法常见的几种题目类型"></a>二分法常见的几种题目类型</h2><ul>
<li>查找特定值</li>
<li>查找第一个大于(或等于)特定值的元素  – 「找下界」</li>
<li>查找最后一个小于(或等于)特定值的元素 – 「找上界」</li>
</ul>
<h2 id="二分法通用模板"><a href="#二分法通用模板" class="headerlink" title="二分法通用模板"></a>二分法通用模板</h2><p>二分查找无论是找下界、还是找上界、还是找特定值，都可以套用「找下界」的模板代码：</p>
<ul>
<li>循环条件为 left &lt;&#x3D; right，表示闭区间不为空</li>
<li>if 的判定条件和给定的比较规则是一致的：比如要找满足 x &gt;&#x3D; target 的第一个元素，就令 if nums[m] &gt;&#x3D; target；要找满足 x &gt; target 的第一个元素，就令 if nums[m] &gt; target</li>
<li>if 为真时，更新 right：right &#x3D; mid - 1；否则 left &#x3D; mid + 1</li>
<li>当循环结束时，left 就指向下界，right 指向「互补条件」的上界</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123;<br>        mid := (left + right) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= target &#123;  <span class="hljs-comment">// 此处需要条件与题目要求一致</span><br>            right = mid<span class="hljs-number">-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid+<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>互补条件: 上述模板中left代表的是大于等于target的第一个元素， right代表的是小于target的最后一个元素。因此可以将取上界问题转换为其互补的取下界问题，并将返回值改为right</p>
</blockquote>
<h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><table>
<thead>
<tr>
<th>题目链接</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode.cn/problems/kth-missing-positive-number/">1539. 第 k 个缺失的正整数</a></td>
<td>二分法取上界问题变形</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>Go逃逸分析</title>
    <url>/2022/10/04/GoNote/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-什么是逃逸分析"><a href="#1-什么是逃逸分析" class="headerlink" title="1. 什么是逃逸分析"></a>1. 什么是逃逸分析</h2><p>在C&#x2F;C++中，对内存的操作经常需要小心翼翼，比如下面这段代码就隐藏了一个陷阱: 函数内部定义的局部变量，其内存是在栈上分配的(静态内存分布)，函数执行完毕后内存会被销毁。因此这段代码会直接崩溃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//c++</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> &amp;t;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了避免这个问题，需要对这段代码做一点改进. 通过new创建的变量位于堆上，不会随着函数执行完成销毁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* t = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    *t = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是这样依旧有一个问题，调用者依旧需要记得在适当的时候删除这个对象，不然就会造成内存泄露。</p>
<p>综上，C&#x2F;C++等语言的内存分配有两个痛点:</p>
<ol>
<li>需要时刻注意内存的分配位置，是在栈上还是堆上</li>
<li>堆上的内存需要手动释放</li>
</ol>
<p>Go优雅的解决了这两个问题: 通过<code>逃逸分析</code>决定内存分配的位置； 通过<code>垃圾回收</code>自动释放堆上的内存。</p>
<blockquote>
<p>在编译原理中，分析指针动态范围的方法被称之为逃逸分析。当一个对象的指针被多个方法或线程引用时，则称这个指针发生了逃逸，逃逸分析决定一个变量分配在堆上还是栈上。</p>
</blockquote>
<h2 id="2-逃逸分析的作用"><a href="#2-逃逸分析的作用" class="headerlink" title="2. 逃逸分析的作用"></a>2. 逃逸分析的作用</h2><p>逃逸分析把变量合理的分配到它该去的地方。即使是new函数申请的内存，如果函数退出后就没有用了，那么就会将内存分配到栈上。反之，即使一个普通变量，发现函数退出之后依旧还有引用，那就分配到堆上。</p>
<p>如果变量都分配到堆上，堆上的内存分配速度较慢，并且因为堆无法像栈一样自动释放内存，就会引起频繁的垃圾回收，从而消耗较多的性能。</p>
<h2 id="3-逃逸分析的原则"><a href="#3-逃逸分析的原则" class="headerlink" title="3. 逃逸分析的原则"></a>3. 逃逸分析的原则</h2><p>编译器会分析代码的特征和生命周期，只有在编译器<code>可以证明函数返回后不会再被引用</code>的变量才会分配到栈上，其他情况下都是分配到堆。分配原则如下:</p>
<ol>
<li>如果变量在函数外部没有引用，则<code>优先</code>放到栈上</li>
<li>如果变量在函数外部存在引用，则<code>一定</code>放到堆上</li>
</ol>
<p>第一条原则中，为什么是优先，而不是一定呢? 加入我们申请了一个很大的数组，申请内存过大，超过了栈的存储能力，这时候就会放到堆上。</p>
<h2 id="4-如何确定发生逃逸"><a href="#4-如何确定发生逃逸" class="headerlink" title="4. 如何确定发生逃逸"></a>4. 如何确定发生逃逸</h2><p>Go提供了相关命令，可以查看是否发生逃逸</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build -gcflags <span class="hljs-string">&#x27;-m -I&#x27;</span> main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure>
<ul>
<li>-m 用于输出编译器的优化细节</li>
<li>-I 关闭内联优化，避免逃逸被编译器的内联优化抹除</li>
</ul>
<h2 id="5-Go的堆栈与C-x2F-C-的区别"><a href="#5-Go的堆栈与C-x2F-C-的区别" class="headerlink" title="5. Go的堆栈与C&#x2F;C++的区别"></a>5. Go的堆栈与C&#x2F;C++的区别</h2><p>C&#x2F;C++中提到的堆与栈本质上是<code>操作系统级别</code>的概念，在程序启动时，操作系统会自动维护一个程序消耗内存的地址空间，并从逻辑上划分为堆内存和栈内存。此时申请一个局部变量，会执行压栈，当离开作用域后自动释放(自动释放的本质是该位置可被下次压栈覆盖)；对于堆而言，每次申请会将所需的地址从维护的堆内存地址空间中分配出去，归还时再合并到所维护的地址空间中</p>
<p>Go既然也运行在操作系统上，自然也拥有上述堆与栈的概念。但是传统意义上的<code>栈</code>被Go的运行时全部消耗了，用于维护各个组件间的协调，例如调度器、垃圾回收等。对于用户态的Go代码，所消耗的堆和栈，实际上都是Go运行时向操作系统申请的堆内存，构成逻辑上的堆和栈。因此Go程序的栈空间相对只有1M的C&#x2F;C++而言大得多(1GB)</p>
]]></content>
      <categories>
        <category>Go学习笔记</category>
      </categories>
      <tags>
        <tag>逃逸分析</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2023/04/09/Redis/bloomFilter/</url>
    <content><![CDATA[<h2 id="一、布隆过滤器简介"><a href="#一、布隆过滤器简介" class="headerlink" title="一、布隆过滤器简介"></a>一、布隆过滤器简介</h2><p>布隆过滤器，英文叫BloomFilter，可以说是一个二进制向量和一系列随机映射函数实现。 可以用于检索一个元素是否在一个集合中。</p>
<p>下图是一个例子，来看一下布隆过滤器的工作流程<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20230409224818.png"></p>
<p>有三个hash函数和一个位数组，例如单词<code>oracle</code>经过三个hash函数，得到第1、4、5位为1，在初始化时将数组的1、4、5位置为1. 后续如果我们需要判断<code>oracle</code>是否在此位数组中，则通过hash函数判断位数组的1、4、5位是否均为1，如果均为1，则判断<code>oracle</code>在此位数组中。这就是布隆过滤器判断元素是否在集合中的原理。</p>
<h2 id="二、布隆过滤器存在的问题"><a href="#二、布隆过滤器存在的问题" class="headerlink" title="二、布隆过滤器存在的问题"></a>二、布隆过滤器存在的问题</h2><p>了解了原理之后，也很容易发现它存在的两个问题: 误判 &amp; 不可删除</p>
<h3 id="1-误判"><a href="#1-误判" class="headerlink" title="1. 误判"></a>1. 误判</h3><p>还是上面的例子，如果<code>bloom</code>经过三个hash算法，需要判断 1、5、10位是否为1，恰好因为位数组中添加<code>oracle</code>和<code>database</code>导致1、5、10位为1，则布隆过滤器会判断<code>bloom</code>在集合中，导致误判。</p>
<p>因此，高效插入和查询的代价就是，它是一个基于概率的数据结构，<em>只能告诉我们一个元素绝对不在集合内，对于存在集合内有一定的误判率。</em></p>
<p>但是布隆过滤器的空间效率和查询时间都远远高于一般的算法，使得这个缺点在某些应用场景中是可以接受的</p>
<h3 id="2-不可删除"><a href="#2-不可删除" class="headerlink" title="2. 不可删除"></a>2. 不可删除</h3><p>布隆过滤器判断一个元素存在就是判断对应位置是否为 1 来确定的，但是如果要删除掉一个元素是不能直接把 1 改成 0 的，因为这个位置可能存在其他元素，直接删除会对其他元素的判定结果产生影响。</p>
<h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><ul>
<li>网页黑名单过滤：由于互联网上存在大量的恶意网站和垃圾网站，为了保护用户的隐私和安全，很多网站都会采用布隆过滤器来过滤黑名单中的网站。</li>
<li>垃圾邮件过滤：在邮件服务器中，需要对接收到的邮件进行分类，将垃圾邮件过滤掉，保证用户只接收到有用的邮件。布隆过滤器可以对邮件进行快速过滤，提高过滤的效率。</li>
<li>缓存过滤：在缓存中，需要快速判断某个键值对是否存在。如果缓存中的键值对非常多，使用线性搜索的方式会非常耗时。这时可以使用布隆过滤器对键进行过滤，减少无用的搜索。</li>
<li>URL去重：爬虫在爬取网页时需要去重，防止重复下载同一个页面。布隆过滤器可以快速判断URL是否已经被爬取过。</li>
</ul>
<h2 id="四、实践中遇到的问题"><a href="#四、实践中遇到的问题" class="headerlink" title="四、实践中遇到的问题"></a>四、实践中遇到的问题</h2><h3 id="1-如何降低误判率-fpp-？"><a href="#1-如何降低误判率-fpp-？" class="headerlink" title="1.如何降低误判率(fpp)？"></a>1.如何降低误判率(fpp)？</h3><p>我们可以提高数组长度以及 hash 计算次数来降低误报率，但是相应的 CPU、内存的消耗也会相应的提高；这需要我们根据自己的业务需要去权衡选择。</p>
<h4 id="1-1-布隆过滤器应该设计为多大？"><a href="#1-1-布隆过滤器应该设计为多大？" class="headerlink" title="1.1 布隆过滤器应该设计为多大？"></a>1.1 布隆过滤器应该设计为多大？</h4><p>假设在布隆过滤器里面有 k 个哈希函数，m 个比特位（也就是位数组长度），以及 n 个已插入元素，错误率会近似于 (1-ekn&#x2F;m)k，所以你只需要先确定可能插入的数据集的容量大小 n，然后再调整 k 和 m 来为你的应用配置过滤器。</p>
<h4 id="1-2-布隆过滤器应该使用多少个哈希函数？"><a href="#1-2-布隆过滤器应该使用多少个哈希函数？" class="headerlink" title="1.2 布隆过滤器应该使用多少个哈希函数？"></a>1.2 布隆过滤器应该使用多少个哈希函数？</h4><p>对于给定的 m（比特位个数）和 n（集合元素个数），最优的 k（哈希函数个数）值为: (m&#x2F;n)ln(2)</p>
<h3 id="2-如何支持删除"><a href="#2-如何支持删除" class="headerlink" title="2.如何支持删除"></a>2.如何支持删除</h3><p>如果要支持删除，最简单的做法就是加一个计数器，就是说位数组的每个位如果不存在就是 0，存在几个元素就存具体的数字，而不仅仅只是存 1。<br>那么这就有一个问题，本来存 1 就是一位就可以满足了，但是如果要存具体的数字比如说 2，那就需要 2 位了，所以带有计数器的布隆过滤器会<code>占用更大的空间</code>。</p>
]]></content>
      <categories>
        <category>Redis学习笔记</category>
      </categories>
      <tags>
        <tag>高性能开发</tag>
      </tags>
  </entry>
  <entry>
    <title>TCC的基本原理与常见问题</title>
    <url>/2024/05/13/SystemDesign/tcc/</url>
    <content><![CDATA[<h2 id="一、TCC基础介绍"><a href="#一、TCC基础介绍" class="headerlink" title="一、TCC基础介绍"></a>一、TCC基础介绍</h2><p>TCC 模式是最经典的分布式事务解决方案，它将分布式事务分为两个阶段来执行，try 阶段对每个分支事务进行预留资源，如果所有分支事务都预留资源成功，则进入 commit 阶段提交全局事务，如果有一个节点预留资源失败则进入 cancel 阶段回滚全局事务。</p>
<p>以传统的订单、库存、账户服务为例，在 try 阶段尝试预留资源，插入订单、扣减库存、扣减金额，这三个服务都是要提交本地事务的，这里可以把资源转入中间表。在 commit 阶段，再把 try 阶段预留的资源转入最终表。而在 cancel 阶段，把 try 阶段预留的资源进行释放，比如把账户金额返回给客户的账户。</p>
<p>注意：try 阶段必须是要提交本地事务的，比如扣减订单金额，必须把钱从客户账户扣掉，如果不扣掉，在 commit 阶段客户账户钱不够了，就会出问题。</p>
<h2 id="二、TCC模型的工作流程"><a href="#二、TCC模型的工作流程" class="headerlink" title="二、TCC模型的工作流程"></a>二、TCC模型的工作流程</h2><p>在分布式事务中，TCC（Try-Confirm-Cancel）是一种常见的事务控制机制，用于确保在分布式系统中事务的一致性和完整性。TCC 模型主要由以下三个角色组成：</p>
<p>TM（Transaction Manager）：事务管理器<br>RM（Resource Manager）：资源管理器<br>TC（Transaction Coordinator）：事务协调器</p>
<h3 id="1-TM（Transaction-Manager）-事务管理器"><a href="#1-TM（Transaction-Manager）-事务管理器" class="headerlink" title="1. TM（Transaction Manager）- 事务管理器"></a>1. TM（Transaction Manager）- 事务管理器</h3><p>事务管理器负责管理整个事务的生命周期。它主要负责以下任务：</p>
<ul>
<li>启动事务</li>
<li>协调事务的执行</li>
<li>决定事务的提交或回滚</li>
</ul>
<p>在 TCC 模型中，事务管理器会调用各个资源管理器的 Try、Confirm 和 Cancel 接口来控制事务的执行。</p>
<h3 id="2-RM（Resource-Manager）-资源管理器"><a href="#2-RM（Resource-Manager）-资源管理器" class="headerlink" title="2. RM（Resource Manager）- 资源管理器"></a>2. RM（Resource Manager）- 资源管理器</h3><p>资源管理器负责具体资源的管理和操作。它主要负责以下任务：</p>
<ul>
<li>实现 Try、Confirm 和 Cancel 接口</li>
<li>执行实际的业务操作</li>
</ul>
<p>在 TCC 模型中，每个资源管理器负责一个或多个资源（例如数据库、文件系统等）的操作，并通过 Try、Confirm 和 Cancel 接口来参与事务的控制。</p>
<h3 id="3-TC（Transaction-Coordinator）-事务协调器"><a href="#3-TC（Transaction-Coordinator）-事务协调器" class="headerlink" title="3. TC（Transaction Coordinator）- 事务协调器"></a>3. TC（Transaction Coordinator）- 事务协调器</h3><p>事务协调器负责协调多个资源管理器，以确保分布式事务的一致性和完整性。它主要负责以下任务：</p>
<ul>
<li>协调各个资源管理器的操作</li>
<li>确保所有资源管理器成功执行 Try 操作后，才能执行 Confirm 操作</li>
<li>如果任何一个资源管理器的 Try 操作失败，则执行 Cancel 操作</li>
</ul>
<h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><p>假设有一个分布式事务，需要在两个系统中分别扣减库存和扣减余额。以下是 TCC 模型的工作流程：</p>
<h3 id="Try-阶段："><a href="#Try-阶段：" class="headerlink" title="Try 阶段："></a>Try 阶段：</h3><ul>
<li>事务管理器（TM）调用库存系统的 Try 接口，预留库存。</li>
<li>事务管理器（TM）调用余额系统的 Try 接口，预留余额。</li>
</ul>
<h3 id="Confirm-阶段："><a href="#Confirm-阶段：" class="headerlink" title="Confirm 阶段："></a>Confirm 阶段：</h3><ul>
<li>如果库存系统和余额系统的 Try 操作都成功，事务管理器（TM）调用库存系统的 Confirm 接口，正式扣减库存。</li>
<li>事务管理器（TM）调用余额系统的 Confirm 接口，正式扣减余额。</li>
</ul>
<h3 id="Cancel-阶段："><a href="#Cancel-阶段：" class="headerlink" title="Cancel 阶段："></a>Cancel 阶段：</h3><ul>
<li>如果库存系统或余额系统的 Try 操作失败，事务管理器（TM）调用库存系统的 Cancel 接口，取消预留的库存。</li>
<li>事务管理器（TM）调用余额系统的 Cancel 接口，取消预留的余额。</li>
</ul>
<h3 id="Demo代码"><a href="#Demo代码" class="headerlink" title="Demo代码"></a>Demo代码</h3><h4 id="1-定义资源管理器（RM）"><a href="#1-定义资源管理器（RM）" class="headerlink" title="1. 定义资源管理器（RM）"></a>1. 定义资源管理器（RM）</h4><figure class="highlight golang"><table><tr><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// RM 接口定义了资源管理器的 Try、Confirm 和 Cancel 操作</span><br><span class="hljs-keyword">type</span> RM <span class="hljs-keyword">interface</span> &#123;<br>	Try() <span class="hljs-type">error</span><br>	Confirm() <span class="hljs-type">error</span><br>	Cancel() <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">// InventoryManager 模拟库存管理器</span><br><span class="hljs-keyword">type</span> InventoryManager <span class="hljs-keyword">struct</span> &#123;<br>	mu      sync.Mutex<br>	stock   <span class="hljs-type">int</span><br>	reserve <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewInventoryManager</span><span class="hljs-params">(stock <span class="hljs-type">int</span>)</span></span> *InventoryManager &#123;<br>	<span class="hljs-keyword">return</span> &amp;InventoryManager&#123;stock: stock&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(im *InventoryManager)</span></span> Try() <span class="hljs-type">error</span> &#123;<br>	im.mu.Lock()<br>	<span class="hljs-keyword">defer</span> im.mu.Unlock()<br>	<span class="hljs-keyword">if</span> im.stock &gt; <span class="hljs-number">0</span> &#123;<br>		im.reserve++<br>		im.stock--<br>		fmt.Println(<span class="hljs-string">&quot;Inventory Try: reserved 1 item&quot;</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Inventory Try: out of stock&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(im *InventoryManager)</span></span> Confirm() <span class="hljs-type">error</span> &#123;<br>	im.mu.Lock()<br>	<span class="hljs-keyword">defer</span> im.mu.Unlock()<br>	<span class="hljs-keyword">if</span> im.reserve &gt; <span class="hljs-number">0</span> &#123;<br>		im.reserve--<br>		fmt.Println(<span class="hljs-string">&quot;Inventory Confirm: confirmed 1 item&quot;</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Inventory Confirm: no item to confirm&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(im *InventoryManager)</span></span> Cancel() <span class="hljs-type">error</span> &#123;<br>	im.mu.Lock()<br>	<span class="hljs-keyword">defer</span> im.mu.Unlock()<br>	<span class="hljs-keyword">if</span> im.reserve &gt; <span class="hljs-number">0</span> &#123;<br>		im.reserve--<br>		im.stock++<br>		fmt.Println(<span class="hljs-string">&quot;Inventory Cancel: canceled 1 item&quot;</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Inventory Cancel: no item to cancel&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// BalanceManager 模拟余额管理器</span><br><span class="hljs-keyword">type</span> BalanceManager <span class="hljs-keyword">struct</span> &#123;<br>	mu      sync.Mutex<br>	balance <span class="hljs-type">int</span><br>	reserve <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBalanceManager</span><span class="hljs-params">(balance <span class="hljs-type">int</span>)</span></span> *BalanceManager &#123;<br>	<span class="hljs-keyword">return</span> &amp;BalanceManager&#123;balance: balance&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bm *BalanceManager)</span></span> Try() <span class="hljs-type">error</span> &#123;<br>	bm.mu.Lock()<br>	<span class="hljs-keyword">defer</span> bm.mu.Unlock()<br>	<span class="hljs-keyword">if</span> bm.balance &gt; <span class="hljs-number">0</span> &#123;<br>		bm.reserve++<br>		bm.balance--<br>		fmt.Println(<span class="hljs-string">&quot;Balance Try: reserved 1 unit&quot;</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Balance Try: insufficient balance&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bm *BalanceManager)</span></span> Confirm() <span class="hljs-type">error</span> &#123;<br>	bm.mu.Lock()<br>	<span class="hljs-keyword">defer</span> bm.mu.Unlock()<br>	<span class="hljs-keyword">if</span> bm.reserve &gt; <span class="hljs-number">0</span> &#123;<br>		bm.reserve--<br>		fmt.Println(<span class="hljs-string">&quot;Balance Confirm: confirmed 1 unit&quot;</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Balance Confirm: no unit to confirm&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bm *BalanceManager)</span></span> Cancel() <span class="hljs-type">error</span> &#123;<br>	bm.mu.Lock()<br>	<span class="hljs-keyword">defer</span> bm.mu.Unlock()<br>	<span class="hljs-keyword">if</span> bm.reserve &gt; <span class="hljs-number">0</span> &#123;<br>		bm.reserve--<br>		bm.balance++<br>		fmt.Println(<span class="hljs-string">&quot;Balance Cancel: canceled 1 unit&quot;</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Balance Cancel: no unit to cancel&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-定义事务管理器（TM）和事务协调器（TC）"><a href="#2-定义事务管理器（TM）和事务协调器（TC）" class="headerlink" title="2. 定义事务管理器（TM）和事务协调器（TC）"></a>2. 定义事务管理器（TM）和事务协调器（TC）</h4><figure class="highlight golang"><table><tr><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// TransactionManager 负责管理事务的生命周期</span><br><span class="hljs-keyword">type</span> TransactionManager <span class="hljs-keyword">struct</span> &#123;<br>	rms []RM<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTransactionManager</span><span class="hljs-params">(rms []RM)</span></span> *TransactionManager &#123;<br>	<span class="hljs-keyword">return</span> &amp;TransactionManager&#123;rms: rms&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TransactionManager)</span></span> Execute() <span class="hljs-type">error</span> &#123;<br>	<span class="hljs-comment">// Try 阶段</span><br>	<span class="hljs-keyword">for</span> _, rm := <span class="hljs-keyword">range</span> tm.rms &#123;<br>		<span class="hljs-keyword">if</span> err := rm.Try(); err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-comment">// 如果 Try 失败，执行 Cancel 阶段</span><br>			tm.Cancel()<br>			<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Transaction failed in Try phase: %v&quot;</span>, err)<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// Confirm 阶段</span><br>	<span class="hljs-keyword">for</span> _, rm := <span class="hljs-keyword">range</span> tm.rms &#123;<br>		<span class="hljs-keyword">if</span> err := rm.Confirm(); err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-comment">// 如果 Confirm 失败，执行 Cancel 阶段</span><br>			tm.Cancel()<br>			<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Transaction failed in Confirm phase: %v&quot;</span>, err)<br>		&#125;<br>	&#125;<br><br>	fmt.Println(<span class="hljs-string">&quot;Transaction succeeded&quot;</span>)<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TransactionManager)</span></span> Cancel() &#123;<br>	<span class="hljs-comment">// Cancel 阶段</span><br>	<span class="hljs-keyword">for</span> _, rm := <span class="hljs-keyword">range</span> tm.rms &#123;<br>		<span class="hljs-keyword">if</span> err := rm.Cancel(); err != <span class="hljs-literal">nil</span> &#123;<br>			fmt.Printf(<span class="hljs-string">&quot;Error during Cancel phase: %v\n&quot;</span>, err)<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行示例</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 创建资源管理器</span><br>	inventoryManager := NewInventoryManager(<span class="hljs-number">10</span>)<br>	balanceManager := NewBalanceManager(<span class="hljs-number">10</span>)<br><br>	<span class="hljs-comment">// 创建事务管理器</span><br>	rms := []RM&#123;inventoryManager, balanceManager&#125;<br>	transactionManager := NewTransactionManager(rms)<br><br>	<span class="hljs-comment">// 执行事务</span><br>	<span class="hljs-keyword">if</span> err := transactionManager.Execute(); err != <span class="hljs-literal">nil</span> &#123;<br>		fmt.Printf(<span class="hljs-string">&quot;Transaction failed: %v\n&quot;</span>, err)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个示例展示了一个简单的 TCC 模型实现，其中包括事务管理器（TM）、资源管理器（RM）和事务协调器（TC）。通过这种方式，可以确保分布式事务的一致性和完整性。</p>
]]></content>
      <categories>
        <category>系统设计方案</category>
      </categories>
      <tags>
        <tag>系统设计方案</tag>
      </tags>
  </entry>
  <entry>
    <title>Google SRE弹性熔断算法（Client-Side Throttling）原理分析</title>
    <url>/2024/08/24/SystemDesign/throttling/</url>
    <content><![CDATA[<p>在微服务架构中，单个服务故障可能引发雪崩效应。传统熔断器（如Hystrix）通过固定阈值触发熔断，虽然能防止系统崩溃，但也存在两大痛点：</p>
<ul>
<li>过度熔断：静态阈值无法适应动态负载，可能误伤健康服务</li>
<li>恢复震荡：从熔断状态恢复时易出现流量突刺，导致二次熔断</li>
</ul>
<p>Google SRE弹性熔断算法（Client-Side Throttling）是一种基于请求成功率动态调整熔断策略的自适应算法，相比传统熔断器的固定阈值模式，其核心思想是通过请求成功率动态计算丢弃概率，实现更平滑的流量控制。以下是其实现逻辑的详细分析：</p>
<blockquote>
<p><a href="https://sre.google/sre-book/handling-overload/#eq2101">Google SRE</a></p>
</blockquote>
<h2 id="一、算法核心思想"><a href="#一、算法核心思想" class="headerlink" title="一、算法核心思想"></a>一、算法核心思想</h2><p>1.1 数学模型：用概率说话<br>算法的核心公式：</p>
<p>$P &#x3D; \max\left(0, \frac{\text{Requests} - K \times \text{Accepts}}{\text{Requests} + 1}\right)$</p>
<ul>
<li>Requests：客户端总请求数（成功+失败）</li>
<li>Accepts：服务端成功处理的请求数</li>
<li>K值：敏感系数（通常1.5-2.0），控制熔断激进程度</li>
</ul>
<p>当 P &gt; 0, 时，每个请求以概率P被丢弃，而非传统熔断器的”全开全关”模式。</p>
<p>该公式的解释如下： 当 requests−K∗accepts&gt;&#x3D;0时，概率 p&#x3D;&#x3D;0，客户端不会主动丢弃请求；反之，则概率 p，会随着 accepts值的变小而增加，即成功接受的请求数越少，本地丢弃请求的概率就越高。通俗点说，Client 可以发送请求直到 requests&#x3D;K∗accepts， 一旦超过限制， 按照概率进行截流。</p>
<p>算法动态调节过程模拟: </p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># 示例：K=2</span>时的状态变化<br>时间轴   请求状态      Requests  Accepts  P值计算      丢弃概率<br>------------------------------------------------------------<br>t<span class="hljs-number">1</span>     成功          <span class="hljs-number">1</span>         <span class="hljs-number">1</span>       <span class="hljs-comment">(1-2*1)</span>/<span class="hljs-comment">(1+1)</span>= <span class="hljs-number">-0.5</span> → <span class="hljs-number">0</span><span class="hljs-meta">%</span><br>t<span class="hljs-number">2</span>     失败          <span class="hljs-number">2</span>         <span class="hljs-number">1</span>       <span class="hljs-comment">(2-2*1)</span>/<span class="hljs-comment">(2+1)</span>= <span class="hljs-number">0</span>/<span class="hljs-number">3</span> → <span class="hljs-number">0</span><span class="hljs-meta">%</span><br>t<span class="hljs-number">3</span>     失败          <span class="hljs-number">3</span>         <span class="hljs-number">1</span>       <span class="hljs-comment">(3-2*1)</span>/<span class="hljs-comment">(3+1)</span>= <span class="hljs-number">0.25</span> → <span class="hljs-number">25</span><span class="hljs-meta">%</span><br>t<span class="hljs-number">4</span>     成功          <span class="hljs-number">4</span>         <span class="hljs-number">2</span>       <span class="hljs-comment">(4-2*2)</span>/<span class="hljs-comment">(4+1)</span>= <span class="hljs-number">0</span> → <span class="hljs-number">0</span><span class="hljs-meta">%</span><br></code></pre></td></tr></table></figure>

<p>从 Google 的文档描述中，该算法在实际中使用效果极为良好，可以使整体上保持一个非常稳定的请求速率。对于后端而言，调整 K 值可以使得自适应限流算法适配不同的后端。</p>
<ul>
<li>降低 K 值会使自适应限流算法更加激进（允许客户端在算法启动时拒绝更多本地请求）</li>
<li>增加 K 值会使自适应限流算法不再那么激进（允许服务端在算法启动时尝试接收更多的请求，与上面相反）</li>
</ul>
<h2 id="二、工程实现"><a href="#二、工程实现" class="headerlink" title="二、工程实现"></a>二、工程实现</h2><ol>
<li>滑动窗口代码实现<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ================== 滑动窗口实现 ==================</span><br><span class="hljs-keyword">type</span> RollingWindow <span class="hljs-keyword">struct</span> &#123;<br>	buckets []<span class="hljs-type">int64</span>     <span class="hljs-comment">// 桶数组（存储成功数）</span><br>	size    <span class="hljs-type">int</span>         <span class="hljs-comment">// 桶数量</span><br>	width   <span class="hljs-type">int64</span>       <span class="hljs-comment">// 单个桶时间宽度（秒）</span><br>	lastPos <span class="hljs-type">int</span>         <span class="hljs-comment">// 当前桶位置</span><br>	mu      sync.Mutex  <span class="hljs-comment">// 互斥锁</span><br>	stopCh  <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewRollingWindow</span><span class="hljs-params">(size <span class="hljs-type">int</span>, windowDuration time.Duration)</span></span> *RollingWindow &#123;<br>	rw := &amp;RollingWindow&#123;<br>		size:    size,<br>		buckets: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int64</span>, size),<br>		width: <span class="hljs-type">int64</span>(windowDuration.Seconds()) / <span class="hljs-type">int64</span>(size),<br>		stopCh:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;),<br>	&#125;<br>	<span class="hljs-keyword">go</span> rw.backgroundUpdater()<br>	<span class="hljs-keyword">return</span> rw<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RollingWindow)</span></span> backgroundUpdater() &#123;<br>	ticker := time.NewTicker(time.Duration(rw.width))<br>	<span class="hljs-keyword">defer</span> ticker.Stop()<br><br>	<span class="hljs-keyword">for</span> &#123;<br>		<span class="hljs-keyword">select</span> &#123;<br>		<span class="hljs-keyword">case</span> &lt;-ticker.C:<br>			rw.mu.Lock()<br>			rw.lastPos = (rw.lastPos + <span class="hljs-number">1</span>) % rw.size<br>			atomic.StoreInt64(&amp;rw.buckets[rw.lastPos], <span class="hljs-number">0</span>)<br>			rw.mu.Unlock()<br>		<span class="hljs-keyword">case</span> &lt;-rw.stopCh:<br>			<span class="hljs-keyword">return</span><br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RollingWindow)</span></span> AddSuccess() &#123;<br>	atomic.AddInt64(&amp;rw.buckets[rw.lastPos], <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rw *RollingWindow)</span></span> Sum() <span class="hljs-type">int64</span> &#123;<br>	sum := <span class="hljs-type">int64</span>(<span class="hljs-number">0</span>)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; rw.size; i++ &#123;<br>		sum += atomic.LoadInt64(&amp;rw.buckets[i])<br>	&#125;<br>	<span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>熔断器实现<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ================== 熔断器实现 ==================</span><br><span class="hljs-keyword">type</span> GoogleBreaker <span class="hljs-keyword">struct</span> &#123;<br>	k          <span class="hljs-type">float64</span> <span class="hljs-comment">// 敏感系数</span><br>	requests   <span class="hljs-type">int64</span>   <span class="hljs-comment">// 总请求数（原子操作）</span><br>	window     *RollingWindow<br>	rand       *rand.Rand<br>	probaGuard sync.Mutex<br>&#125;<br><br><span class="hljs-keyword">var</span> ErrServiceUnavailable = errors.New(<span class="hljs-string">&quot;service unavailable&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGoogleBreaker</span><span class="hljs-params">(k <span class="hljs-type">float64</span>, windowSize <span class="hljs-type">int</span>, windowDuration time.Duration)</span></span> *GoogleBreaker &#123;<br>	<span class="hljs-keyword">return</span> &amp;GoogleBreaker&#123;<br>		k:      k,<br>		window: NewRollingWindow(windowSize, windowDuration),<br>		rand:   rand.New(rand.NewSource(time.Now().UnixNano())),<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *GoogleBreaker)</span></span> Do(req <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) <span class="hljs-type">error</span> &#123;<br>	<span class="hljs-comment">// 1. 检查是否触发熔断</span><br>	<span class="hljs-keyword">if</span> err := b.accept(); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> err<br>	&#125;<br><br>	<span class="hljs-comment">// 2. 执行请求并统计结果</span><br>	atomic.AddInt64(&amp;b.requests, <span class="hljs-number">1</span>)<br>	err := req()<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; isFailure(err) &#123;<br>		<span class="hljs-keyword">return</span> err<br>	&#125;<br><br>	<span class="hljs-comment">// 3. 请求成功时更新滑动窗口</span><br>	b.window.AddSuccess()<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *GoogleBreaker)</span></span> accept() <span class="hljs-type">error</span> &#123;<br>	<span class="hljs-comment">// 获取当前统计值</span><br>	accepts := b.window.Sum()<br>	requests := atomic.LoadInt64(&amp;b.requests)<br><br>	<span class="hljs-comment">// 计算丢弃概率</span><br>	ratio := <span class="hljs-type">float64</span>(requests-<span class="hljs-type">int64</span>(b.k*<span class="hljs-type">float64</span>(accepts))) / <span class="hljs-type">float64</span>(requests+<span class="hljs-number">1</span>)<br>	<span class="hljs-keyword">if</span> ratio &lt;= <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br><br>	<span class="hljs-comment">// 概率判断</span><br>	b.probaGuard.Lock()<br>	<span class="hljs-keyword">defer</span> b.probaGuard.Unlock()<br>	<span class="hljs-keyword">if</span> b.rand.Float64() &lt; ratio &#123;<br>		<span class="hljs-keyword">return</span> ErrServiceUnavailable<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// ================== 辅助函数 ==================</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isFailure</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>	<span class="hljs-comment">// 根据业务需求定义哪些错误需要触发熔断</span><br>	<span class="hljs-comment">// 示例：仅网络错误触发熔断</span><br>	_, ok := err.(net.Error)<br>	<span class="hljs-keyword">return</span> ok<br>&#125;<br><br><span class="hljs-comment">// ================== 测试用例 ==================</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestBreaker</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>	breaker := NewGoogleBreaker(<span class="hljs-number">1.5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>*time.Second)<br><br>	<span class="hljs-comment">// 正常请求</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>		err := breaker.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>			<span class="hljs-comment">// 模拟业务逻辑</span><br>			<span class="hljs-keyword">if</span> rand.Intn(<span class="hljs-number">100</span>) &lt; <span class="hljs-number">20</span> &#123; <span class="hljs-comment">// 20%错误率</span><br>				<span class="hljs-keyword">return</span> &amp;net.OpError&#123;&#125;<br>			&#125;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>		&#125;)<br>		t.Logf(<span class="hljs-string">&quot;Request %d: %v&quot;</span>, i, err)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>系统设计方案</category>
      </categories>
      <tags>
        <tag>系统设计方案</tag>
        <tag>Golang</tag>
        <tag>限流</tag>
      </tags>
  </entry>
</search>
