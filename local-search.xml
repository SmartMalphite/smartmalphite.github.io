<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TCC的基本原理与常见问题</title>
    <link href="/2024/05/13/SystemDesign/bloomFilter/"/>
    <url>/2024/05/13/SystemDesign/bloomFilter/</url>
    
    <content type="html"><![CDATA[<h2 id="一、TCC基础介绍"><a href="#一、TCC基础介绍" class="headerlink" title="一、TCC基础介绍"></a>一、TCC基础介绍</h2><p>TCC 模式是最经典的分布式事务解决方案，它将分布式事务分为两个阶段来执行，try 阶段对每个分支事务进行预留资源，如果所有分支事务都预留资源成功，则进入 commit 阶段提交全局事务，如果有一个节点预留资源失败则进入 cancel 阶段回滚全局事务。</p><p>以传统的订单、库存、账户服务为例，在 try 阶段尝试预留资源，插入订单、扣减库存、扣减金额，这三个服务都是要提交本地事务的，这里可以把资源转入中间表。在 commit 阶段，再把 try 阶段预留的资源转入最终表。而在 cancel 阶段，把 try 阶段预留的资源进行释放，比如把账户金额返回给客户的账户。</p><p>注意：try 阶段必须是要提交本地事务的，比如扣减订单金额，必须把钱从客户账户扣掉，如果不扣掉，在 commit 阶段客户账户钱不够了，就会出问题。</p><h2 id="二、TCC模型的工作流程"><a href="#二、TCC模型的工作流程" class="headerlink" title="二、TCC模型的工作流程"></a>二、TCC模型的工作流程</h2><p>在分布式事务中，TCC（Try-Confirm-Cancel）是一种常见的事务控制机制，用于确保在分布式系统中事务的一致性和完整性。TCC 模型主要由以下三个角色组成：</p><p>TM（Transaction Manager）：事务管理器<br>RM（Resource Manager）：资源管理器<br>TC（Transaction Coordinator）：事务协调器</p><h3 id="1-TM（Transaction-Manager）-事务管理器"><a href="#1-TM（Transaction-Manager）-事务管理器" class="headerlink" title="1. TM（Transaction Manager）- 事务管理器"></a>1. TM（Transaction Manager）- 事务管理器</h3><p>事务管理器负责管理整个事务的生命周期。它主要负责以下任务：</p><ul><li>启动事务</li><li>协调事务的执行</li><li>决定事务的提交或回滚</li></ul><p>在 TCC 模型中，事务管理器会调用各个资源管理器的 Try、Confirm 和 Cancel 接口来控制事务的执行。</p><h3 id="2-RM（Resource-Manager）-资源管理器"><a href="#2-RM（Resource-Manager）-资源管理器" class="headerlink" title="2. RM（Resource Manager）- 资源管理器"></a>2. RM（Resource Manager）- 资源管理器</h3><p>资源管理器负责具体资源的管理和操作。它主要负责以下任务：</p><ul><li>实现 Try、Confirm 和 Cancel 接口</li><li>执行实际的业务操作</li></ul><p>在 TCC 模型中，每个资源管理器负责一个或多个资源（例如数据库、文件系统等）的操作，并通过 Try、Confirm 和 Cancel 接口来参与事务的控制。</p><h3 id="3-TC（Transaction-Coordinator）-事务协调器"><a href="#3-TC（Transaction-Coordinator）-事务协调器" class="headerlink" title="3. TC（Transaction Coordinator）- 事务协调器"></a>3. TC（Transaction Coordinator）- 事务协调器</h3><p>事务协调器负责协调多个资源管理器，以确保分布式事务的一致性和完整性。它主要负责以下任务：</p><ul><li>协调各个资源管理器的操作</li><li>确保所有资源管理器成功执行 Try 操作后，才能执行 Confirm 操作</li><li>如果任何一个资源管理器的 Try 操作失败，则执行 Cancel 操作</li></ul><h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><p>假设有一个分布式事务，需要在两个系统中分别扣减库存和扣减余额。以下是 TCC 模型的工作流程：</p><h3 id="Try-阶段："><a href="#Try-阶段：" class="headerlink" title="Try 阶段："></a>Try 阶段：</h3><ul><li>事务管理器（TM）调用库存系统的 Try 接口，预留库存。</li><li>事务管理器（TM）调用余额系统的 Try 接口，预留余额。</li></ul><h3 id="Confirm-阶段："><a href="#Confirm-阶段：" class="headerlink" title="Confirm 阶段："></a>Confirm 阶段：</h3><ul><li>如果库存系统和余额系统的 Try 操作都成功，事务管理器（TM）调用库存系统的 Confirm 接口，正式扣减库存。</li><li>事务管理器（TM）调用余额系统的 Confirm 接口，正式扣减余额。</li></ul><h3 id="Cancel-阶段："><a href="#Cancel-阶段：" class="headerlink" title="Cancel 阶段："></a>Cancel 阶段：</h3><ul><li>如果库存系统或余额系统的 Try 操作失败，事务管理器（TM）调用库存系统的 Cancel 接口，取消预留的库存。</li><li>事务管理器（TM）调用余额系统的 Cancel 接口，取消预留的余额。</li></ul><h3 id="Demo代码"><a href="#Demo代码" class="headerlink" title="Demo代码"></a>Demo代码</h3><h4 id="1-定义资源管理器（RM）"><a href="#1-定义资源管理器（RM）" class="headerlink" title="1. 定义资源管理器（RM）"></a>1. 定义资源管理器（RM）</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">// RM 接口定义了资源管理器的 Try、Confirm 和 Cancel 操作</span><br><span class="hljs-keyword">type</span> RM <span class="hljs-keyword">interface</span> &#123;<br>Try() <span class="hljs-type">error</span><br>Confirm() <span class="hljs-type">error</span><br>Cancel() <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">// InventoryManager 模拟库存管理器</span><br><span class="hljs-keyword">type</span> InventoryManager <span class="hljs-keyword">struct</span> &#123;<br>mu      sync.Mutex<br>stock   <span class="hljs-type">int</span><br>reserve <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewInventoryManager</span><span class="hljs-params">(stock <span class="hljs-type">int</span>)</span></span> *InventoryManager &#123;<br><span class="hljs-keyword">return</span> &amp;InventoryManager&#123;stock: stock&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(im *InventoryManager)</span></span> Try() <span class="hljs-type">error</span> &#123;<br>im.mu.Lock()<br><span class="hljs-keyword">defer</span> im.mu.Unlock()<br><span class="hljs-keyword">if</span> im.stock &gt; <span class="hljs-number">0</span> &#123;<br>im.reserve++<br>im.stock--<br>fmt.Println(<span class="hljs-string">&quot;Inventory Try: reserved 1 item&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Inventory Try: out of stock&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(im *InventoryManager)</span></span> Confirm() <span class="hljs-type">error</span> &#123;<br>im.mu.Lock()<br><span class="hljs-keyword">defer</span> im.mu.Unlock()<br><span class="hljs-keyword">if</span> im.reserve &gt; <span class="hljs-number">0</span> &#123;<br>im.reserve--<br>fmt.Println(<span class="hljs-string">&quot;Inventory Confirm: confirmed 1 item&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Inventory Confirm: no item to confirm&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(im *InventoryManager)</span></span> Cancel() <span class="hljs-type">error</span> &#123;<br>im.mu.Lock()<br><span class="hljs-keyword">defer</span> im.mu.Unlock()<br><span class="hljs-keyword">if</span> im.reserve &gt; <span class="hljs-number">0</span> &#123;<br>im.reserve--<br>im.stock++<br>fmt.Println(<span class="hljs-string">&quot;Inventory Cancel: canceled 1 item&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Inventory Cancel: no item to cancel&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// BalanceManager 模拟余额管理器</span><br><span class="hljs-keyword">type</span> BalanceManager <span class="hljs-keyword">struct</span> &#123;<br>mu      sync.Mutex<br>balance <span class="hljs-type">int</span><br>reserve <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBalanceManager</span><span class="hljs-params">(balance <span class="hljs-type">int</span>)</span></span> *BalanceManager &#123;<br><span class="hljs-keyword">return</span> &amp;BalanceManager&#123;balance: balance&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bm *BalanceManager)</span></span> Try() <span class="hljs-type">error</span> &#123;<br>bm.mu.Lock()<br><span class="hljs-keyword">defer</span> bm.mu.Unlock()<br><span class="hljs-keyword">if</span> bm.balance &gt; <span class="hljs-number">0</span> &#123;<br>bm.reserve++<br>bm.balance--<br>fmt.Println(<span class="hljs-string">&quot;Balance Try: reserved 1 unit&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Balance Try: insufficient balance&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bm *BalanceManager)</span></span> Confirm() <span class="hljs-type">error</span> &#123;<br>bm.mu.Lock()<br><span class="hljs-keyword">defer</span> bm.mu.Unlock()<br><span class="hljs-keyword">if</span> bm.reserve &gt; <span class="hljs-number">0</span> &#123;<br>bm.reserve--<br>fmt.Println(<span class="hljs-string">&quot;Balance Confirm: confirmed 1 unit&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Balance Confirm: no unit to confirm&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bm *BalanceManager)</span></span> Cancel() <span class="hljs-type">error</span> &#123;<br>bm.mu.Lock()<br><span class="hljs-keyword">defer</span> bm.mu.Unlock()<br><span class="hljs-keyword">if</span> bm.reserve &gt; <span class="hljs-number">0</span> &#123;<br>bm.reserve--<br>bm.balance++<br>fmt.Println(<span class="hljs-string">&quot;Balance Cancel: canceled 1 unit&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Balance Cancel: no unit to cancel&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-定义事务管理器（TM）和事务协调器（TC）"><a href="#2-定义事务管理器（TM）和事务协调器（TC）" class="headerlink" title="2. 定义事务管理器（TM）和事务协调器（TC）"></a>2. 定义事务管理器（TM）和事务协调器（TC）</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// TransactionManager 负责管理事务的生命周期</span><br><span class="hljs-keyword">type</span> TransactionManager <span class="hljs-keyword">struct</span> &#123;<br>rms []RM<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTransactionManager</span><span class="hljs-params">(rms []RM)</span></span> *TransactionManager &#123;<br><span class="hljs-keyword">return</span> &amp;TransactionManager&#123;rms: rms&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TransactionManager)</span></span> Execute() <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// Try 阶段</span><br><span class="hljs-keyword">for</span> _, rm := <span class="hljs-keyword">range</span> tm.rms &#123;<br><span class="hljs-keyword">if</span> err := rm.Try(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果 Try 失败，执行 Cancel 阶段</span><br>tm.Cancel()<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Transaction failed in Try phase: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Confirm 阶段</span><br><span class="hljs-keyword">for</span> _, rm := <span class="hljs-keyword">range</span> tm.rms &#123;<br><span class="hljs-keyword">if</span> err := rm.Confirm(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果 Confirm 失败，执行 Cancel 阶段</span><br>tm.Cancel()<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Transaction failed in Confirm phase: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;Transaction succeeded&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TransactionManager)</span></span> Cancel() &#123;<br><span class="hljs-comment">// Cancel 阶段</span><br><span class="hljs-keyword">for</span> _, rm := <span class="hljs-keyword">range</span> tm.rms &#123;<br><span class="hljs-keyword">if</span> err := rm.Cancel(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Error during Cancel phase: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行示例</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建资源管理器</span><br>inventoryManager := NewInventoryManager(<span class="hljs-number">10</span>)<br>balanceManager := NewBalanceManager(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">// 创建事务管理器</span><br>rms := []RM&#123;inventoryManager, balanceManager&#125;<br>transactionManager := NewTransactionManager(rms)<br><br><span class="hljs-comment">// 执行事务</span><br><span class="hljs-keyword">if</span> err := transactionManager.Execute(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Transaction failed: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个示例展示了一个简单的 TCC 模型实现，其中包括事务管理器（TM）、资源管理器（RM）和事务协调器（TC）。通过这种方式，可以确保分布式事务的一致性和完整性。</p>]]></content>
    
    
    <categories>
      
      <category>系统设计方案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2023/04/09/Redis/bloomFilter/"/>
    <url>/2023/04/09/Redis/bloomFilter/</url>
    
    <content type="html"><![CDATA[<h2 id="一、布隆过滤器简介"><a href="#一、布隆过滤器简介" class="headerlink" title="一、布隆过滤器简介"></a>一、布隆过滤器简介</h2><p>布隆过滤器，英文叫BloomFilter，可以说是一个二进制向量和一系列随机映射函数实现。 可以用于检索一个元素是否在一个集合中。</p><p>下图是一个例子，来看一下布隆过滤器的工作流程<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20230409224818.png"></p><p>有三个hash函数和一个位数组，例如单词<code>oracle</code>经过三个hash函数，得到第1、4、5位为1，在初始化时将数组的1、4、5位置为1. 后续如果我们需要判断<code>oracle</code>是否在此位数组中，则通过hash函数判断位数组的1、4、5位是否均为1，如果均为1，则判断<code>oracle</code>在此位数组中。这就是布隆过滤器判断元素是否在集合中的原理。</p><h2 id="二、布隆过滤器存在的问题"><a href="#二、布隆过滤器存在的问题" class="headerlink" title="二、布隆过滤器存在的问题"></a>二、布隆过滤器存在的问题</h2><p>了解了原理之后，也很容易发现它存在的两个问题: 误判 &amp; 不可删除</p><h3 id="1-误判"><a href="#1-误判" class="headerlink" title="1. 误判"></a>1. 误判</h3><p>还是上面的例子，如果<code>bloom</code>经过三个hash算法，需要判断 1、5、10位是否为1，恰好因为位数组中添加<code>oracle</code>和<code>database</code>导致1、5、10位为1，则布隆过滤器会判断<code>bloom</code>在集合中，导致误判。</p><p>因此，高效插入和查询的代价就是，它是一个基于概率的数据结构，<em>只能告诉我们一个元素绝对不在集合内，对于存在集合内有一定的误判率。</em></p><p>但是布隆过滤器的空间效率和查询时间都远远高于一般的算法，使得这个缺点在某些应用场景中是可以接受的</p><h3 id="2-不可删除"><a href="#2-不可删除" class="headerlink" title="2. 不可删除"></a>2. 不可删除</h3><p>布隆过滤器判断一个元素存在就是判断对应位置是否为 1 来确定的，但是如果要删除掉一个元素是不能直接把 1 改成 0 的，因为这个位置可能存在其他元素，直接删除会对其他元素的判定结果产生影响。</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><ul><li>网页黑名单过滤：由于互联网上存在大量的恶意网站和垃圾网站，为了保护用户的隐私和安全，很多网站都会采用布隆过滤器来过滤黑名单中的网站。</li><li>垃圾邮件过滤：在邮件服务器中，需要对接收到的邮件进行分类，将垃圾邮件过滤掉，保证用户只接收到有用的邮件。布隆过滤器可以对邮件进行快速过滤，提高过滤的效率。</li><li>缓存过滤：在缓存中，需要快速判断某个键值对是否存在。如果缓存中的键值对非常多，使用线性搜索的方式会非常耗时。这时可以使用布隆过滤器对键进行过滤，减少无用的搜索。</li><li>URL去重：爬虫在爬取网页时需要去重，防止重复下载同一个页面。布隆过滤器可以快速判断URL是否已经被爬取过。</li></ul><h2 id="四、实践中遇到的问题"><a href="#四、实践中遇到的问题" class="headerlink" title="四、实践中遇到的问题"></a>四、实践中遇到的问题</h2><h3 id="1-如何降低误判率-fpp-？"><a href="#1-如何降低误判率-fpp-？" class="headerlink" title="1.如何降低误判率(fpp)？"></a>1.如何降低误判率(fpp)？</h3><p>我们可以提高数组长度以及 hash 计算次数来降低误报率，但是相应的 CPU、内存的消耗也会相应的提高；这需要我们根据自己的业务需要去权衡选择。</p><h4 id="1-1-布隆过滤器应该设计为多大？"><a href="#1-1-布隆过滤器应该设计为多大？" class="headerlink" title="1.1 布隆过滤器应该设计为多大？"></a>1.1 布隆过滤器应该设计为多大？</h4><p>假设在布隆过滤器里面有 k 个哈希函数，m 个比特位（也就是位数组长度），以及 n 个已插入元素，错误率会近似于 (1-ekn&#x2F;m)k，所以你只需要先确定可能插入的数据集的容量大小 n，然后再调整 k 和 m 来为你的应用配置过滤器。</p><h4 id="1-2-布隆过滤器应该使用多少个哈希函数？"><a href="#1-2-布隆过滤器应该使用多少个哈希函数？" class="headerlink" title="1.2 布隆过滤器应该使用多少个哈希函数？"></a>1.2 布隆过滤器应该使用多少个哈希函数？</h4><p>对于给定的 m（比特位个数）和 n（集合元素个数），最优的 k（哈希函数个数）值为: (m&#x2F;n)ln(2)</p><h3 id="2-如何支持删除"><a href="#2-如何支持删除" class="headerlink" title="2.如何支持删除"></a>2.如何支持删除</h3><p>如果要支持删除，最简单的做法就是加一个计数器，就是说位数组的每个位如果不存在就是 0，存在几个元素就存具体的数字，而不仅仅只是存 1。<br>那么这就有一个问题，本来存 1 就是一位就可以满足了，但是如果要存具体的数字比如说 2，那就需要 2 位了，所以带有计数器的布隆过滤器会<code>占用更大的空间</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Redis学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高性能开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL日志模块</title>
    <link href="/2022/10/10/MySQL/2.MySQL%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/10/10/MySQL/2.MySQL%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-的日志模块"><a href="#MySQL-的日志模块" class="headerlink" title="MySQL 的日志模块"></a>MySQL 的日志模块</h2><h3 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1. redo log"></a>1. redo log</h3><h4 id="1-1-为什么需要-redo-log"><a href="#1-1-为什么需要-redo-log" class="headerlink" title="1.1 为什么需要 redo log"></a>1.1 为什么需要 redo log</h4><p>如果数据更新的过程采用”来一条写入一条”的方式进行更新，会因为数据库的查询&#x2F;写入是随机IO导致时间成本较高；因此记录会先写入redo log(顺序IO)，并在适当的时候写入磁盘，这样就会提升mysql的吞吐性能</p><h4 id="1-2-redo-log的具体如何工作-WAL"><a href="#1-2-redo-log的具体如何工作-WAL" class="headerlink" title="1.2 redo log的具体如何工作(WAL)"></a>1.2 redo log的具体如何工作(WAL)</h4><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。这样的一套流程也就是MySQL经常提到的WAL技术(Write-Ahead Logging)</p><h4 id="1-3-redo-log的大小以及写满后如何操作"><a href="#1-3-redo-log的大小以及写满后如何操作" class="headerlink" title="1.3 redo log的大小以及写满后如何操作"></a>1.3 redo log的大小以及写满后如何操作</h4><p>redo log是循环写且固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写；write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p><img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/image-20210606175307845.png" style="zoom: 50%;" /><h3 id="2-binlog"><a href="#2-binlog" class="headerlink" title="2. binlog"></a>2. binlog</h3><h4 id="2-1-为什么同时有两套日志"><a href="#2-1-为什么同时有两套日志" class="headerlink" title="2.1 为什么同时有两套日志"></a>2.1 为什么同时有两套日志</h4><p> redo log 是InnoDB引擎独有的日志，而binlog是MySQL的Server层独有的日志</p><h4 id="2-2-与redo-log的区别"><a href="#2-2-与redo-log的区别" class="headerlink" title="2.2 与redo log的区别"></a>2.2 与redo log的区别</h4><ol><li><p>redo log是物理日志，记录的是在某个数据页上做了什么修改，而binlog是逻辑日志，记录的是语句的原始逻辑，比如给id&#x3D;2的这一行某字段+1； </p></li><li><p>redo log是循环写的，binlog是追加写的</p></li></ol><h3 id="3-两阶段提交"><a href="#3-两阶段提交" class="headerlink" title="3.两阶段提交"></a>3.两阶段提交</h3><p>以 update T set c&#x3D;c+1 where ID&#x3D;1; 语句为例</p><h4 id="3-1-内部流程描述"><a href="#3-1-内部流程描述" class="headerlink" title="3.1 内部流程描述"></a>3.1 内部流程描述</h4><ul><li>执行器调用存储引擎取到ID&#x3D;1的记录，如果记录本来就在内存中则直接返回，否则先从磁盘读到内存再返回</li><li>执行器拿到数据，将对应值+1，调用存储引擎接口将新的数据写入</li><li>存储引擎拿到数据后将其更新到内存同时记录到redo log中,并告知执行器执行完成，可以提交(此时redo log的日志状态处于prepare状态)</li><li>执行器生成binlog，并写入磁盘</li><li>调用事务提交接口，将redolog的日志状态改为commit状态</li></ul><img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/image-20210606175813038.png" alt="image-20210606175813038" style="zoom:50%;" /><h4 id="3-2-为什么需要两阶段提交"><a href="#3-2-为什么需要两阶段提交" class="headerlink" title="3.2 为什么需要两阶段提交"></a>3.2 为什么需要两阶段提交</h4><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。</p><p>这里可以用反证法进行解释，由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题：</p><p>假设当前故障如下，update过程中写完第一个日志，在写第二个日志之前发生crash，会出现什么问题呢?</p><ol><li><strong>先写redo log 后写binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。</li><li><strong>先写binlog后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li></ol><p>那么两阶段提交下的工作模式，在异常发生时是怎么保证一致性的呢？</p><h4 id="3-3-两阶段提交是如何保证一致性的"><a href="#3-3-两阶段提交是如何保证一致性的" class="headerlink" title="3.3 两阶段提交是如何保证一致性的"></a>3.3 两阶段提交是如何保证一致性的</h4><p>已知log的写入顺序可简化为: 写redo log(prepare) -&gt; 写binlog -&gt; 写redo log(commit)</p><ol><li>在第一步、第二步之间crash: redo log有记录(prepare状态), binlog无记录。此时数据库重启恢复后发现redo log中对应数据未commit因此会回滚，并不会执行更新。而使用binlog恢复备份数据时，因为没有记录因此更新也没有生效。数据一致</li><li>在第二步、第三步之间crash: redo log有记录(prepare状态), binlog有记录。此时数据库重启恢复后发现redo log中对应数据未commit但有完整的binlog记录，因此会自动commit，数据最终更新入db。使用binlog恢复备份时，因为有对应的记录所以数据同样更新成功。数据一致</li></ol>]]></content>
    
    
    <categories>
      
      <category>MySQL学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL日志模块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础架构</title>
    <link href="/2022/10/09/MySQL/1.MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/10/09/MySQL/1.MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h2><h3 id="1-MySQL基本架构梳理"><a href="#1-MySQL基本架构梳理" class="headerlink" title="1. MySQL基本架构梳理"></a>1. MySQL基本架构梳理</h3><p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" style="zoom: 33%;" /><h3 id="2-各模块细分特性"><a href="#2-各模块细分特性" class="headerlink" title="2.各模块细分特性"></a>2.各模块细分特性</h3><h4 id="2-1-连接器"><a href="#2-1-连接器" class="headerlink" title="2.1 连接器"></a>2.1 连接器</h4><p>验证完用户名密码后会查询拥有的权限，之后该连接中所有的权限判断逻辑都依赖此时读到的权限(也就是说修改权限之后重新登陆才会生效)</p><h4 id="2-2-查询缓存"><a href="#2-2-查询缓存" class="headerlink" title="2.2 查询缓存"></a>2.2 查询缓存</h4><p>查询请求会优先在缓存中查找数据，之前执行过的语句与结果会以key-value的形式储存在内存中；</p><p>不建议使用，一个表上主要有更新，所有的查询缓存都会被清空，对于更新频率较高的表性价比很低，可以设置为显示指定是否使用缓存；</p><p>MySQL 8.0已整体移除；</p><h4 id="2-3-分析器"><a href="#2-3-分析器" class="headerlink" title="2.3 分析器"></a>2.3 分析器</h4><p>词法解析+语法解析</p><h4 id="2-4-优化器"><a href="#2-4-优化器" class="headerlink" title="2.4 优化器"></a>2.4 优化器</h4><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><h4 id="2-5-执行器"><a href="#2-5-执行器" class="headerlink" title="2.5 执行器"></a>2.5 执行器</h4><p>鉴权并根据表的引擎定义，去使用这个引擎提供的接口。</p><ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol>]]></content>
    
    
    <categories>
      
      <category>MySQL学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL基础架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引模型</title>
    <link href="/2022/10/09/MySQL/3.MySQL%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/10/09/MySQL/3.MySQL%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL的索引模型"><a href="#MySQL的索引模型" class="headerlink" title="MySQL的索引模型"></a>MySQL的索引模型</h2><blockquote><p>索引的出现其实就是为了提高数据查询的效率，就像字典的目录一样。一本 500 页的字典，如果你想快速找到其中的某一个汉子的内容，在不借助目录的情况下，只能慢慢的翻阅很浪费时间，而使用拼音查找目录就会快很多。同样，对于数据库的表而言，索引其实就是它的“目录”。</p></blockquote><h3 id="1-索引的常见模型"><a href="#1-索引的常见模型" class="headerlink" title="1.索引的常见模型"></a>1.索引的常见模型</h3><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里先介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。</p><h4 id="1-1-哈希表"><a href="#1-1-哈希表" class="headerlink" title="1.1 哈希表"></a>1.1 哈希表</h4><p>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p><p>不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p><p>需要注意的是，在哈希表中插入新的key点位是直接追加的，而不是有序的，因此新增节点的速度会很快，但是区间查询的速度会很慢，因此这种模型适用于只有等值查询的场景(Memcached 及其他一些 NoSQL 引擎)。</p><h4 id="1-2-有序数组"><a href="#1-2-有序数组" class="headerlink" title="1.2 有序数组"></a>1.2 有序数组</h4><p>有序数组顾名思义，就是一个排好序列表，这种模型的等值查询和范围查询性能都很好(根据二分法找到对应的值或范围的起点)，但是因为每次插入都要保证数组是有序的，所以更新性能较差。</p><h4 id="1-3-搜索树"><a href="#1-3-搜索树" class="headerlink" title="1.3 搜索树"></a>1.3 搜索树</h4><p>二叉搜索树同时拥有较高的查询和更新性能，但是如果数据量较大，树的层级会比较深，一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><h3 id="2-Innodb的索引模型"><a href="#2-Innodb的索引模型" class="headerlink" title="2.Innodb的索引模型"></a>2.Innodb的索引模型</h3><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。</p><p>假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。索引的组织结构的示意图如下</p><img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/dcda101051f28502bd5c4402b292e38d.png" alt="img" style="zoom:50%;" /><p>索引类型可分为主键索引和非主键索引:</p><ul><li><p>主键索引的叶子节点存的是整行数据，在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</p></li><li><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p></li></ul><p>根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？</p><ol><li><p>如果语句是 select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</p></li><li><p>如果语句是 select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</p></li></ol><p>可以看出，使用主键索引可以尽量减少扫描次数，提高查询速度</p><h3 id="3-索引的维护"><a href="#3-索引的维护" class="headerlink" title="3.索引的维护"></a>3.索引的维护</h3><blockquote><p> B+树为了维护索引的有序，插入新值是需要做相应的维护工作，如果依次向后增加数据，逻辑和成本都相对简单。但以上面索引结构的示意图为例，如果要在300和500之间插入数据，则会影响后面的节点，在某些场景下，则还会发生”页分裂”，对性能产生较大影响；同样如果要删除某些数据，也可能会出现”页合并”。</p></blockquote><h4 id="3-1-MySQL数据表存储结构"><a href="#3-1-MySQL数据表存储结构" class="headerlink" title="3.1 MySQL数据表存储结构"></a>3.1 MySQL数据表存储结构</h4><p>假设你已经装好了MySQL最新的5.7版本，并且你创建了一个<code>windmills</code>库（schema）和<code>wmills</code>表。在文件目录（通常是<code>/var/lib/mysql/</code>）你会看到以下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">data/<br>  windmills/<br>      wmills.ibd<br>      wmills.frm<br></code></pre></td></tr></table></figure><p>目录下要注意的是这个叫<code>wmills.ibd</code>的文件。这个文件由多个段（segments）组成，每个段和一个索引相关。段则由更小一级单位–区 组成，每个区的默认大小为1M，页则是区的下一级构成单位，默认体积为16KB。<strong>页是MySQL的最小存储单元</strong></p><p>按这样算，一个区可以容纳最多64个页，一个页可以容纳2-N个行。行的数量取决于它的大小，由你的表结构定义 (InnoDB要求页至少要有两个行)</p><img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/image-20210630235552804-20210630235741726.png" style="zoom:50%;" /><h4 id="3-2-InnoDB中的一颗B-树能存储多少行数据"><a href="#3-2-InnoDB中的一颗B-树能存储多少行数据" class="headerlink" title="3.2 InnoDB中的一颗B+树能存储多少行数据"></a>3.2 InnoDB中的一颗B+树能存储多少行数据</h4><p>这里以一颗高度为3的B+树为例(B+树中每行的完整数据都存储在叶子节点，非叶子结点只存储<strong>索引键值</strong>和指向孩子节点的<strong>指针</strong>)</p><p>假设主键ID为bigint类型，长度8字节，指针在InnoDB中设置为6字节，这样一个单元总共14字节，一页中可以存储16384&#x2F;14&#x3D;1170个指针，换而言之，<strong>每个非叶子节点中最多可以存储约1200个指针</strong>。</p><p>假设一行记录的大小约为1K，一页中则可以存储16&#x2F;1&#x3D;16行数据。</p><p>因此可以得出，一颗高度为3的B+树，在行数据为1K左右时，最多可以存储 1200 * 1200 * 16 约 2000万条数据。</p><p><img src="https://raw.githubusercontent.com/enbo-wang/new_picbed/master/img/image-20210701000330687.png" alt="image-20210701000330687"></p><p>参考链接 : <a href="https://zhuanlan.zhihu.com/p/86137284">如何查看根页的Page No以及树高</a></p><h4 id="3-3-行数据溢出"><a href="#3-3-行数据溢出" class="headerlink" title="3.3 行数据溢出"></a>3.3 行数据溢出</h4><p>Innodb页的默认大小是16kb, 并且要求一页最少有两行数据(如果只有一行数据, B+TREE就失去了意义，退化成了一条双向链表)，因此一行数据的最大长度是8k;</p><p>为了尽量保证一页能存储两行数据，innodb自动将字段中超过768字节的部分存储到另外页中并指向溢出页；但需要注意的是，假如有20个大字段，20 * 768 &gt; 8000，此时依旧超过了一行8k的限制，因此会产生报错</p><h4 id="3-4-页分裂和页合并"><a href="#3-4-页分裂和页合并" class="headerlink" title="3.4 页分裂和页合并"></a>3.4 页分裂和页合并</h4><p>根据B+树的特性，为了维护索引的有序性，如果我们插入数据的是有序的，那么只需依次写满数据页，并在写满后切换到下一页继续写入；而当我们不按顺序随机插入数据时，如果插在多条记录之间，则会导致此页内后面的<code>数据依次向后移动</code>，甚至如果页已经满了，则会发生<code>页分裂</code>(例如当前页记录主键id为10、12、14的3条数据且已写满，这时插入一个11，则会在此页之后再增加一个页并改变相邻页之间的指针指向，并将部分数据移动到新页 )，而顺序写入写满页后就不会有移动数据以及页分裂的问题；</p><p>与之对应的还有页合并操作，当我们删除一定数量的数据使相邻页的数据分别低于一定比例之后为了节省空间则会发生<code>页合并</code>，移动数据并改变相邻页之间的指针指向，类似于活页本把本页内容摘抄到上一页并将此页拿掉，也是比较消耗性能的；</p><blockquote><p>因此建议使用自增主键id避免页分裂，使用逻辑删除代替物理删除避免页合并</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>MySQL学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>索引模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL缓存机制</title>
    <link href="/2022/10/09/MySQL/4.MySQL%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/10/09/MySQL/4.MySQL%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-BufferPool"><a href="#1-BufferPool" class="headerlink" title="1. BufferPool"></a>1. BufferPool</h2><h3 id="1-1-什么是BufferPool"><a href="#1-1-什么是BufferPool" class="headerlink" title="1.1 什么是BufferPool"></a>1.1 什么是BufferPool</h3><p>buffer pool 就是内存中的一块缓冲池，用来缓存表和索引的数据。MySQL的数据都是存储在磁盘上的，因此如果每次读写数据都去和磁盘交互的话性能开销较大，所以 innodb 自己维护了一个 buffer pool，在读取数据的时候，会把数据加载到缓冲池中，这样下次再获取就不需要从磁盘读了，直接访问内存中的 buffer pool 即可。更新数据也是一样，直接修改内存中的数据，然后到一定时机才会将这些脏数据刷到磁盘上。</p><p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20221011222909.png"></p><h3 id="1-2-BufferPool如何保证数据不丢"><a href="#1-2-BufferPool如何保证数据不丢" class="headerlink" title="1.2 BufferPool如何保证数据不丢"></a>1.2 BufferPool如何保证数据不丢</h3><p>在更新内存的同时会将更新操作写入redolog, 这样即使在数据落盘前宕机，数据也可以通过redolog恢复</p><h3 id="1-3-BufferPool如何维护数据"><a href="#1-3-BufferPool如何维护数据" class="headerlink" title="1.3 BufferPool如何维护数据"></a>1.3 BufferPool如何维护数据</h3><p>缓冲池维护的是页数据，也就是说，即使你只想从磁盘中获取一条数据，但是 innodb 也会加载一页的数据到缓冲池中，一页默认是 16k。</p><p>正常情况下，内存放不下全部的数据库数据，那说明缓冲池需要有淘汰机制，淘汰那些不常被访问的数据页。</p><p>按照这个需求，我们很容易想到 <code>LRU</code> 机制，最近最少使用的页面将被淘汰，即维护一个链表，被访问的页面移动到头部，新加的页面也加到头部，同时根据内存使用情况淘汰尾部的页面。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL缓存机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go延迟语句</title>
    <link href="/2022/10/05/GoNote/%E5%BB%B6%E8%BF%9F%E8%AF%AD%E5%8F%A5/"/>
    <url>/2022/10/05/GoNote/%E5%BB%B6%E8%BF%9F%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="1-延迟语句是什么"><a href="#1-延迟语句是什么" class="headerlink" title="1.延迟语句是什么"></a>1.延迟语句是什么</h2><p><code>defer</code>语句是Go语言提供的一种用于注册延迟调用的机制: 让函数或语句可以在当前函数执行完成后(包括return和panic)执行。可以借助defer的特性方便的在函数结束前做一些清理操作(例如释放数据库连接等)</p><p>defer的使用也可以解决一些异常场景下的资源释放问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">t.mu.Lock()<br>rand.Intn(param)<br>r.mu.Unlock()<br></code></pre></td></tr></table></figure><p>在正常情况下，不使用defer没什么问题。但是当rand函数发生panic时，Unlock将不会被执行，进而导致程序异常。</p><h2 id="2-延迟语句的执行"><a href="#2-延迟语句的执行" class="headerlink" title="2.延迟语句的执行"></a>2.延迟语句的执行</h2><p>每次遇到defer语句时，会把函数压栈，函数参数会被复制下来，当外层函数退出时，defer函数会按照定义的顺序<code>逆序执行</code>。</p><blockquote><p>注意，在return后定义的defer不会起作用</p></blockquote><p>defer函数定义时，对外部变量有两种引用方式:</p><ol><li>函数参数: 定义时就把参数传递给defer，并cache起来。相当于快照机制</li><li>闭包引用: 真正执行的时候根据上下文确定具体的值。是动态变化的</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br>  <span class="hljs-keyword">defer</span> fmt.Println(n)  <span class="hljs-comment">// 函数传参</span><br>  <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;fmt.Println(n)&#125;()  <span class="hljs-comment">// 闭包引用</span><br><br>  n = <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>0<br></code></pre></td></tr></table></figure><h2 id="3-延迟语句拆解"><a href="#3-延迟语句拆解" class="headerlink" title="3. 延迟语句拆解"></a>3. 延迟语句拆解</h2><p>想要理解defer语句的执行时机，需要先理解下面这条语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">return</span> xxx<br></code></pre></td></tr></table></figure><p>上面这条语句编译之后，实际上执变成了三条语句</p><ol><li>返回值 &#x3D; xxx</li><li>调用defer</li><li>空的return</li></ol><p>通过一个例子来具体解释下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>)&#123;<br>  t := <span class="hljs-number">5</span><br>  <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;t = t + <span class="hljs-number">5</span>&#125;()<br>  <span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><p>拆解后代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>)&#123;<br>  t := <span class="hljs-number">5</span><br><br>  <span class="hljs-comment">// 1. 赋值指令</span><br>  r = t<br><br>  <span class="hljs-comment">// 2. defer语句被插入其中</span><br>  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    t = t + <span class="hljs-number">5</span><br>  &#125;()<br><br>  <span class="hljs-comment">// 3. 空的return</span><br>  <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-延迟语句与recover配合使用"><a href="#4-延迟语句与recover配合使用" class="headerlink" title="4. 延迟语句与recover配合使用"></a>4. 延迟语句与recover配合使用</h2><p>当我们的程序在遇到严重问题导致panic时，会停掉当前正在执行的程序(不只是出问题的线程)，他会有序的执行完当前线程的defer语句，其他线程的defer不做保证。所以需要在线程或协程的defer语句中增加<code>revocer</code>语句，防止程序直接挂掉(类似Python的try语句)。</p><blockquote><p>需要注意的是，recover语句只在defer函数中调用才有效</p></blockquote><p>使用方法如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">defer</span> f()<br>  <span class="hljs-built_in">panic</span>&#123;<span class="hljs-number">1</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); e != <span class="hljs-literal">nil</span>&#123;<br>    fmt.Println(<span class="hljs-string">&quot;recover&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>延迟语句</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go逃逸分析</title>
    <link href="/2022/10/04/GoNote/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    <url>/2022/10/04/GoNote/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是逃逸分析"><a href="#1-什么是逃逸分析" class="headerlink" title="1. 什么是逃逸分析"></a>1. 什么是逃逸分析</h2><p>在C&#x2F;C++中，对内存的操作经常需要小心翼翼，比如下面这段代码就隐藏了一个陷阱: 函数内部定义的局部变量，其内存是在栈上分配的(静态内存分布)，函数执行完毕后内存会被销毁。因此这段代码会直接崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//c++</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> &amp;t;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了避免这个问题，需要对这段代码做一点改进. 通过new创建的变量位于堆上，不会随着函数执行完成销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* t = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    *t = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样依旧有一个问题，调用者依旧需要记得在适当的时候删除这个对象，不然就会造成内存泄露。</p><p>综上，C&#x2F;C++等语言的内存分配有两个痛点:</p><ol><li>需要时刻注意内存的分配位置，是在栈上还是堆上</li><li>堆上的内存需要手动释放</li></ol><p>Go优雅的解决了这两个问题: 通过<code>逃逸分析</code>决定内存分配的位置； 通过<code>垃圾回收</code>自动释放堆上的内存。</p><blockquote><p>在编译原理中，分析指针动态范围的方法被称之为逃逸分析。当一个对象的指针被多个方法或线程引用时，则称这个指针发生了逃逸，逃逸分析决定一个变量分配在堆上还是栈上。</p></blockquote><h2 id="2-逃逸分析的作用"><a href="#2-逃逸分析的作用" class="headerlink" title="2. 逃逸分析的作用"></a>2. 逃逸分析的作用</h2><p>逃逸分析把变量合理的分配到它该去的地方。即使是new函数申请的内存，如果函数退出后就没有用了，那么就会将内存分配到栈上。反之，即使一个普通变量，发现函数退出之后依旧还有引用，那就分配到堆上。</p><p>如果变量都分配到堆上，堆上的内存分配速度较慢，并且因为堆无法像栈一样自动释放内存，就会引起频繁的垃圾回收，从而消耗较多的性能。</p><h2 id="3-逃逸分析的原则"><a href="#3-逃逸分析的原则" class="headerlink" title="3. 逃逸分析的原则"></a>3. 逃逸分析的原则</h2><p>编译器会分析代码的特征和生命周期，只有在编译器<code>可以证明函数返回后不会再被引用</code>的变量才会分配到栈上，其他情况下都是分配到堆。分配原则如下:</p><ol><li>如果变量在函数外部没有引用，则<code>优先</code>放到栈上</li><li>如果变量在函数外部存在引用，则<code>一定</code>放到堆上</li></ol><p>第一条原则中，为什么是优先，而不是一定呢? 加入我们申请了一个很大的数组，申请内存过大，超过了栈的存储能力，这时候就会放到堆上。</p><h2 id="4-如何确定发生逃逸"><a href="#4-如何确定发生逃逸" class="headerlink" title="4. 如何确定发生逃逸"></a>4. 如何确定发生逃逸</h2><p>Go提供了相关命令，可以查看是否发生逃逸</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build -gcflags <span class="hljs-string">&#x27;-m -I&#x27;</span> main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><ul><li>-m 用于输出编译器的优化细节</li><li>-I 关闭内联优化，避免逃逸被编译器的内联优化抹除</li></ul><h2 id="5-Go的堆栈与C-x2F-C-的区别"><a href="#5-Go的堆栈与C-x2F-C-的区别" class="headerlink" title="5. Go的堆栈与C&#x2F;C++的区别"></a>5. Go的堆栈与C&#x2F;C++的区别</h2><p>C&#x2F;C++中提到的堆与栈本质上是<code>操作系统级别</code>的概念，在程序启动时，操作系统会自动维护一个程序消耗内存的地址空间，并从逻辑上划分为堆内存和栈内存。此时申请一个局部变量，会执行压栈，当离开作用域后自动释放(自动释放的本质是该位置可被下次压栈覆盖)；对于堆而言，每次申请会将所需的地址从维护的堆内存地址空间中分配出去，归还时再合并到所维护的地址空间中</p><p>Go既然也运行在操作系统上，自然也拥有上述堆与栈的概念。但是传统意义上的<code>栈</code>被Go的运行时全部消耗了，用于维护各个组件间的协调，例如调度器、垃圾回收等。对于用户态的Go代码，所消耗的堆和栈，实际上都是Go运行时向操作系统申请的堆内存，构成逻辑上的堆和栈。因此Go程序的栈空间相对只有1M的C&#x2F;C++而言大得多(1GB)</p>]]></content>
    
    
    <categories>
      
      <category>Go学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逃逸分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法专题</title>
    <link href="/2022/09/22/LeetCode/%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%93%E9%A2%98/"/>
    <url>/2022/09/22/LeetCode/%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="二分法常见的几种题目类型"><a href="#二分法常见的几种题目类型" class="headerlink" title="二分法常见的几种题目类型"></a>二分法常见的几种题目类型</h2><ul><li>查找特定值</li><li>查找第一个大于(或等于)特定值的元素  – 「找下界」</li><li>查找最后一个小于(或等于)特定值的元素 – 「找上界」</li></ul><h2 id="二分法通用模板"><a href="#二分法通用模板" class="headerlink" title="二分法通用模板"></a>二分法通用模板</h2><p>二分查找无论是找下界、还是找上界、还是找特定值，都可以套用「找下界」的模板代码：</p><ul><li>循环条件为 left &lt;&#x3D; right，表示闭区间不为空</li><li>if 的判定条件和给定的比较规则是一致的：比如要找满足 x &gt;&#x3D; target 的第一个元素，就令 if nums[m] &gt;&#x3D; target；要找满足 x &gt; target 的第一个元素，就令 if nums[m] &gt; target</li><li>if 为真时，更新 right：right &#x3D; mid - 1；否则 left &#x3D; mid + 1</li><li>当循环结束时，left 就指向下界，right 指向「互补条件」的上界</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123;<br>        mid := (left + right) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= target &#123;  <span class="hljs-comment">// 此处需要条件与题目要求一致</span><br>            right = mid<span class="hljs-number">-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid+<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>互补条件: 上述模板中left代表的是大于等于target的第一个元素， right代表的是小于target的最后一个元素。因此可以将取上界问题转换为其互补的取下界问题，并将返回值改为right</p></blockquote><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><table><thead><tr><th>题目链接</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/kth-missing-positive-number/">1539. 第 k 个缺失的正整数</a></td><td>二分法取上界问题变形</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的哈希表</title>
    <link href="/2022/09/06/GoNote/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2022/09/06/GoNote/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="map-的底层实现"><a href="#map-的底层实现" class="headerlink" title="map 的底层实现"></a>map 的底层实现</h2><p>在源码中，表示 map 的结构体是 hmap，它是 hashmap 的“缩写”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A header for a Go map.</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 元素个数，调用 len(map) 时，直接返回此值</span><br>count     <span class="hljs-type">int</span><br>flags     <span class="hljs-type">uint8</span><br><span class="hljs-comment">// buckets 的对数 log_2</span><br>B         <span class="hljs-type">uint8</span><br><span class="hljs-comment">// overflow 的 bucket 近似数</span><br>noverflow <span class="hljs-type">uint16</span><br><span class="hljs-comment">// 计算 key 的哈希的时候会传入哈希函数</span><br>hash0     <span class="hljs-type">uint32</span><br>    <span class="hljs-comment">// 指向 buckets 数组，大小为 2^B</span><br>    <span class="hljs-comment">// 如果元素个数为0，就为 nil</span><br>buckets    unsafe.Pointer<br><span class="hljs-comment">// 等量扩容的时候，buckets 长度和 oldbuckets 相等</span><br><span class="hljs-comment">// 双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍</span><br>oldbuckets unsafe.Pointer<br><span class="hljs-comment">// 指示扩容进度，小于此地址的 buckets 迁移完成</span><br>nevacuate  <span class="hljs-type">uintptr</span><br>extra *mapextra <span class="hljs-comment">// optional fields</span><br>&#125;<br></code></pre></td></tr></table></figure><p>buckets 是一个指针，最终它指向的是一个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    topbits  [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span><br>    keys     [<span class="hljs-number">8</span>]keytype<br>    values   [<span class="hljs-number">8</span>]valuetype<br>    pad      <span class="hljs-type">uintptr</span><br>    overflow <span class="hljs-type">uintptr</span><br>&#125;<br></code></pre></td></tr></table></figure><p>bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。</p><p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220924231449.png"></p><p>每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 overflow 指针连接起来。</p><h2 id="Key的定位流程"><a href="#Key的定位流程" class="headerlink" title="Key的定位流程"></a>Key的定位流程</h2><p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220926131214.png"><br>上图中，假定 B &#x3D; 5，所以 bucket 总数就是 2^5 &#x3D; 32。首先计算出待查找 key 的哈希，使用低 5 位 00110，找到对应的 6 号 bucket，使用高 8 位 10010111，对应十进制 151，在 6 号 bucket 中寻找 tophash 值（HOB hash）为 151 的 key，找到了 2 号槽位，这样整个查找过程就结束了。</p><p>如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1-slice与map作为函数参数时的区别"><a href="#1-slice与map作为函数参数时的区别" class="headerlink" title="1. slice与map作为函数参数时的区别?"></a>1. slice与map作为函数参数时的区别?</h3><p>makemap返回的是一个指针，makeslice返回的是一个Slice结构体. 结合Go的参数传递是值传递这个特性，在函数内部操作map是会影响对原始map产生影响的。而Slice需要视情况分析(因为虽然值传递的特性使其在传参时copy了一个新的结构体，但是底层数据是一个指针，依旧指向同一个底层数组)</p><h3 id="2-topHash的偏移值"><a href="#2-topHash的偏移值" class="headerlink" title="2. topHash的偏移值"></a>2. topHash的偏移值</h3><p>topHash除了记录某一key的hash值的高八位外，还具备了标识状态的作用。为了和正常的哈希值区分开，会给 key 计算出来的哈希值一个增量：minTopHash。这样就能区分正常的 top hash 值和表示状态的哈希值。(状态标识的值分别为0-4，如果一个key的hash值高八位是1，那么为了区分开来，就会将其偏移为6)</p>]]></content>
    
    
    <categories>
      
      <category>Go学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GoLang数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的数组、切片</title>
    <link href="/2022/09/06/GoNote/%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"/>
    <url>/2022/09/06/GoNote/%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h2 id="数组与切片介绍"><a href="#数组与切片介绍" class="headerlink" title="数组与切片介绍"></a>数组与切片介绍</h2><p>slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。</p><p>数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。</p><p>而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。</p><p>数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime/slice.go</span><br><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>array unsafe.Pointer <span class="hljs-comment">// 元素指针</span><br><span class="hljs-built_in">len</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// 长度 </span><br><span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// 容量</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。</p></blockquote><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="问题1-3-int-和-4-int-是同一个类型吗？"><a href="#问题1-3-int-和-4-int-是同一个类型吗？" class="headerlink" title="问题1: [3]int 和 [4]int 是同一个类型吗？"></a>问题1: [3]int 和 [4]int 是同一个类型吗？</h3><p>不是。因为数组的长度是类型的一部分，这是与 slice 不同的一点。</p><h3 id="问题2-切片的长度与容量"><a href="#问题2-切片的长度与容量" class="headerlink" title="问题2: 切片的长度与容量?"></a>问题2: 切片的长度与容量?</h3><p>Go语言的切片拥有长度和容量。长度是他所包含的元素个数，容量是其底层数组的元素个数。append是切片的长度大于容量后，切片会自动扩容。</p><h4 id="问题2-1-下面的代码输出是什么？"><a href="#问题2-1-下面的代码输出是什么？" class="headerlink" title="问题2.1: 下面的代码输出是什么？"></a>问题2.1: 下面的代码输出是什么？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>s1 := slice[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>s2 := s1[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>:<span class="hljs-number">7</span>]<br><br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">100</span>)<br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">200</span>)<br><br>s1[<span class="hljs-number">2</span>] = <span class="hljs-number">20</span><br><br>fmt.Println(s1)<br>fmt.Println(s2)<br>fmt.Println(slice)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">20</span>]<br>[<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">100</span> <span class="hljs-number">200</span>]<br>[<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">20</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">100</span> <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>s1 从 slice 索引2（闭区间）到索引5（开区间，元素真正取到索引4），长度为3，容量默认到数组结尾，为8。 s2 从 s1 的索引2（闭区间）到索引6（开区间，元素真正取到索引5），容量到索引7（开区间，真正到索引6），为5。<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220906231135.png"></p><p>接着，向 s2 尾部追加一个元素 100.s2 容量刚好够，直接追加。不过，这会修改原始数组对应位置的元素。这一改动，数组和 s1 都可以看得到。<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220906231309.png"></p><p>再次向 s2 追加元素200. 这时，s2 的容量不够用，该扩容了。于是，s2 另起炉灶，将原来的元素复制新的位置，扩大自己的容量。并且为了应对未来可能的 append 带来的再一次扩容，s2 会在此次扩容的时候多留一些 buffer，将新的容量将扩大为原始容量的2倍，也就是10了。<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220906231411.png"></p><p>最后，修改 s1 索引为2位置的元素.这次只会影响原始数组相应位置的元素。它影响不到 s2 了，人家已经远走高飞了。<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220906231432.png"></p><p>总结:</p><ul><li>数组&#x2F;切片在截取时，如不显示指定容量，默认到数组结尾</li><li>截取得到的数组&#x2F;切片，只会打印和访问其长度以内的元素，但是实际底层数组可能不止这些元素(不可访问，但是可继续参与截取)</li></ul><h3 id="问题3-切片扩容策略"><a href="#问题3-切片扩容策略" class="headerlink" title="问题3: 切片扩容策略?"></a>问题3: 切片扩容策略?</h3><p>1.18版本以前: 当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。<br>1.18版本更新后: 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap &#x3D; oldcap+(oldcap+3*256)&#x2F;4</p><blockquote><p>在进行上述计算后，对长度又进行了一次内存对齐，所以实际容量会大于等于按上述方法计算出的数值。</p></blockquote><h4 id="问题3-1-下面的代码输出是什么？"><a href="#问题3-1-下面的代码输出是什么？" class="headerlink" title="问题3.1: 下面的代码输出是什么？"></a>问题3.1: 下面的代码输出是什么？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>&#125;<br>    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">7</span>)<br>    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">9</span>)<br>    x := <span class="hljs-built_in">append</span>(s, <span class="hljs-number">11</span>)<br>    y := <span class="hljs-built_in">append</span>(s, <span class="hljs-number">12</span>)<br>    fmt.Println(s, x, y)<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>代码</th><th>切片对应状态</th></tr></thead><tbody><tr><td>s:&#x3D;[]int{5}</td><td>s 只有一个元素，[5]</td></tr><tr><td>s&#x3D;append(s, 7)</td><td>s 扩容，容量变为2，[5, 7]</td></tr><tr><td>s&#x3D;append(s, 9)</td><td>s 扩容，容量变为4，[5, 7, 9]。注意，这时 s 长度是3，容量为4</td></tr><tr><td>x:&#x3D;append(s, 11)</td><td>由于 s 的底层数组仍然有空间，因此并不会扩容。这样，底层数组就变成了 [5, 7, 9, 11]。注意，此时 s &#x3D; [5, 7, 9]，容量为4；x &#x3D; [5, 7, 9, 11]，容量为4。这里 s 不变</td></tr><tr><td>y:&#x3D;append(s, 12)</td><td>这里还是在 s 元素的尾部追加元素，由于 s 的长度为3，容量为4，所以直接在底层数组索引为3的地方填上12。结果：s &#x3D; [5, 7, 9]，y &#x3D; [5, 7, 9, 12]，x &#x3D; [5, 7, 9, 12]，x，y 的长度均为4，容量也均为4</td></tr></tbody></table><blockquote><p>这里要注意的是，append函数执行完后，返回的是一个全新的 slice，并且对传入的 slice 并不影响。（但是底层数组是同一个）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Go学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GoLang数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python单元测试</title>
    <link href="/2022/08/10/PythonNote/PythonUnitTest/"/>
    <url>/2022/08/10/PythonNote/PythonUnitTest/</url>
    
    <content type="html"><![CDATA[<h2 id="1-PyTest安装"><a href="#1-PyTest安装" class="headerlink" title="1. PyTest安装:"></a>1. PyTest安装:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pip install pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用插件安装</span></span><br><span class="line">&gt;&gt;&gt; pip install pytest-mock  <span class="comment"># mocker插件</span></span><br><span class="line">&gt;&gt;&gt; pip install pytest-cov   <span class="comment"># 单测覆盖率插件</span></span><br></pre></td></tr></table></figure><h2 id="2-基础用法"><a href="#2-基础用法" class="headerlink" title="2. 基础用法"></a>2. 基础用法</h2><p>定义一个函数如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_sum</span>(<span class="params">a, b</span>):</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;calling get_sum function&quot;</span></span><br><span class="line"><span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>为了验证其功能，我们可以编写单测用例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_sum</span>(<span class="params">self</span>):</span><br><span class="line">result = get_sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> result</span><br><span class="line"><span class="keyword">assert</span> result == <span class="number">3</span></span><br></pre></td></tr></table></figure><p>运行用例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; python -m pytest -v test_tmp.py -s</span><br></pre></td></tr></table></figure><h3 id="2-1-命令行参数"><a href="#2-1-命令行参数" class="headerlink" title="2.1 命令行参数"></a>2.1 命令行参数</h3><p>可以通过<code>pytest -help</code> 查看支持的参数。以下是一些常用的参数:</p><ul><li><code>-v</code>: 输出更详细的用例执行信息, 不使用 -v 参数，运行时不会显示运行的具体测试用例名称；</li><li><code>-s</code>: 显示print内容 在运行测试用例时，为了调试或打印一些内容，我们会在代码中加一些print内容，但是这些内容默认不会显示出来。如果带上-s，就可以显示了。</li><li><code>-x</code>: 出现一条测试用例失败就退出测试。 </li><li><code>-m</code>: 用表达式指定多个标记名。 pytest 提供了一个装饰器 @pytest.mark.xxx，用于标记测试并分组，以便你快速选中并运行，各个分组直接用 and、or 来分割。</li></ul><h3 id="2-2-选择执行的测试用例-静态"><a href="#2-2-选择执行的测试用例-静态" class="headerlink" title="2.2 选择执行的测试用例(静态)"></a>2.2 选择执行的测试用例(静态)</h3><p>按文件夹执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行指定文件夹及子文件夹下的所有测试用例</span></span><br><span class="line">pytest ../tests</span><br></pre></td></tr></table></figure><p>按文件执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行test_tmp.py下的所有的测试用例</span></span><br><span class="line">pytest test_tmp.py</span><br></pre></td></tr></table></figure><p>按测试类执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pytest 文件名.py::测试类</span></span><br><span class="line">pytest test_tmp.py::TestTmp</span><br></pre></td></tr></table></figure><p>按测试方法执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pytest 文件名.py::测试类::测试方法</span></span><br><span class="line">pytest test_tmp.py::TestTmpFunction::test_sum</span><br></pre></td></tr></table></figure><h3 id="选择执行的测试用例-动态"><a href="#选择执行的测试用例-动态" class="headerlink" title="选择执行的测试用例(动态)"></a>选择执行的测试用例(动态)</h3><p>如要使用动态指定测试用例的方式，首先需要给测试用例打标签（mark），比如在 <code>class</code>、<code>method</code> 上加上如下装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.dev_test</span></span><br></pre></td></tr></table></figure><p>在运行时，可以根据标签来动态的选择哪些用例需要执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同时选中带有这两个标签的所有测试用例运行</span></span><br><span class="line">pytest -m &quot;mark1 and mark2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选中带有mark1的测试用例，不运行mark2的测试用例</span></span><br><span class="line">pytest -m &quot;mark1 and not mark2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选中带有mark1或 mark2标签的所有测试用例</span></span><br><span class="line">pytest -m &quot;mark1 or mark2&quot;</span><br></pre></td></tr></table></figure><p>除此之外还提供了一种通过模糊匹配的方式选择测试用例的方式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-k 参数是按照文件名、类名、方法名、标签名来模糊匹配的</span></span><br><span class="line">pytest -k xxxPattern</span><br></pre></td></tr></table></figure><h2 id="3-mock使用"><a href="#3-mock使用" class="headerlink" title="3. mock使用"></a>3. mock使用</h2><p>pytest自带的unittest框架中默认集成了mock库，PyTest的mock支持是通过插件实现的。相对来讲PyTest使用起来更简单(PyTest的mocker是对原生mock的一个兼容，原生mock支持的功能mocker基本都可以支持)</p><h3 id="3-1-基础用法"><a href="#3-1-基础用法" class="headerlink" title="3.1 基础用法"></a>3.1 基础用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_sum</span>(<span class="params">a, b</span>):</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;calling get_sum function&quot;</span></span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_sum_with_mock</span>(<span class="params">self, mocker</span>):</span><br><span class="line">mocker.patch(<span class="string">&#x27;test_tmp.get_sum&#x27;</span>, return_value=<span class="number">3</span>)</span><br><span class="line">result = get_sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> result</span><br><span class="line"><span class="keyword">assert</span> result == <span class="number">3</span></span><br></pre></td></tr></table></figure><p>运行后可以发现，原本<code>get_sum</code>的print内容并没有被打印出来，我们通过<code>mocker.patch</code>方法屏蔽掉了原函数，转而直接返回我们指定的返回结果</p><h3 id="3-2-其他用法"><a href="#3-2-其他用法" class="headerlink" title="3.2 其他用法"></a>3.2 其他用法</h3><p>mocker.patch的函数定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unittest.mock.patch(target, new=DEFAULT, spec=<span class="literal">None</span>, create=<span class="literal">False</span>, spec_set=<span class="literal">None</span>, autospec=<span class="literal">None</span>, new_callable=<span class="literal">None</span>, **kwargs)</span><br></pre></td></tr></table></figure><p>常用参数含义：</p><ul><li><code>target</code>: 模拟对象的路径，参数必须是一个str,格式为’package.module.ClassName’，注意这里的格式一定要写对。如果对象和mock函数在同一个文件中，路径要加文件名</li><li><code>return_value</code>: 模拟函数返回的结果</li><li><code>side_effect</code>: 调用mock时的返回值，可以是函数，异常类，可迭代对象。当设置了该方法时，如果该方法返回值是DEFAULT，那么返回return_value的值，如果不是，则返回该方法的值。 return_value 和 side_effect 同时存在，side_effect会返回。(如果 side_effect 是异常类或实例时，调用模拟程序时将引发异常。如果 side_effect 是可迭代对象，则每次调用 mock 都将返回可迭代对象的下一个值。如果设置为函数时其具体表现会替换被mock函数）</li></ul><h2 id="4-MagicMock"><a href="#4-MagicMock" class="headerlink" title="4. MagicMock"></a>4. MagicMock</h2><p>在mock的过程中，有时我们需要构造相对复杂的返回值，比如对db操作函数的mock，返回值往往是一个对象。这时候常规做法我们就需要定义一个类，并且将其实例化。<br>这种做法较为麻烦，且不够灵活。Python提供了一个MagicMock方法，我们可以较为方便的构造我们想要的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_sum_with_magic_mock</span>(<span class="params">self, mocker</span>):</span><br><span class="line">o1 = MagicMock(a=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> o1.a</span><br><span class="line"></span><br><span class="line">o2 = MagicMock()</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>(o2)</span><br><span class="line">o2.__iter__.return_value = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>(o2)</span><br></pre></td></tr></table></figure><p>在工程实践中，我们一般对MagicMock在进行一次封装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factory</span>(<span class="params">attrs=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">kwargs[<span class="string">&#x27;return_value&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">o = MagicMock(**kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> attrs:</span><br><span class="line"><span class="keyword">return</span> o</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line"><span class="built_in">setattr</span>(o, k, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> o</span><br></pre></td></tr></table></figure><h2 id="5-数据驱动"><a href="#5-数据驱动" class="headerlink" title="5. 数据驱动"></a>5. 数据驱动</h2><p>某些时候，我们希望我们的单测可以覆盖多种逻辑分支，这时为每一种case都单独写一个测试明显也是不现实的。PyTest为单测提供了参数化功能，也就是数据驱动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestTmpFunction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&#x27;a, b, sum_result&#x27;</span>, [</span></span></span><br><span class="line"><span class="params"><span class="meta">(<span class="params"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">(<span class="params"><span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_sum_with_param</span>(<span class="params">self, mocker, a, b, sum_result</span>):</span><br><span class="line">result = get_sum(a, b)</span><br><span class="line"><span class="built_in">print</span> result</span><br><span class="line"><span class="keyword">assert</span> result == sum_result</span><br></pre></td></tr></table></figure><h2 id="6-代码覆盖率"><a href="#6-代码覆盖率" class="headerlink" title="6. 代码覆盖率"></a>6. 代码覆盖率</h2><p>PyTest提供了pytest-cov插件来实现代码覆盖率的统计.</p><h3 id="6-1-基础用法"><a href="#6-1-基础用法" class="headerlink" title="6.1 基础用法"></a>6.1 基础用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pytest --cov --cov-report=xml</span><br></pre></td></tr></table></figure><h3 id="6-2-生成差异报表"><a href="#6-2-生成差异报表" class="headerlink" title="6.2 生成差异报表"></a>6.2 生成差异报表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; diff-cover coverage.xml --compare-branch=origin/master --html-report report.html --fail-under=80</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>收藏从未停止 ⏹</title>
    <link href="/2022/07/24/Other/%E9%80%9F%E6%9F%A5/"/>
    <url>/2022/07/24/Other/%E9%80%9F%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>速查表</th><th>链接</th></tr></thead><tbody><tr><td>MarkDown</td><td><a href="https://markdown.com.cn/">https://markdown.com.cn/</a></td></tr><tr><td>Go面试宝典</td><td><a href="https://golang.design/go-questions/slice/vs-array/">https://golang.design/go-questions/slice/vs-array/</a></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>速查</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的字符串:编码与操作</title>
    <link href="/2022/07/24/GoNote/Go%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/"/>
    <url>/2022/07/24/GoNote/Go%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="Go语言中字符串的编码"><a href="#Go语言中字符串的编码" class="headerlink" title="Go语言中字符串的编码:"></a>Go语言中字符串的编码:</h2><p>Go 语言在看待 Go 字符串组成这个问题上，有两种视角。</p><p>一种是<strong>字节视角</strong>，也就是和所有其它支持字符串的主流语言一样，Go 语言中的字符串值也是一个可空的字节序列，字节序列中的字节个数称为该字符串的长度。一个个的字节只是孤立数据，不表意</p><p>如果要表意，我们就需要从字符串的另外一个视角来看，也就是字符串是由一个可空的字符序列构成(即<strong>字符视角</strong>)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><br><span class="hljs-comment">// 字节视角</span><br>fmt.Printf(<span class="hljs-string">&quot;the length of s = %d\n&quot;</span>, <span class="hljs-built_in">len</span>(s)) <span class="hljs-comment">// 9</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, s[i]) <span class="hljs-comment">// 0xe4 0xb8 0xad 0xe5 0x9b 0xbd 0xe4 0xba 0xba</span><br>&#125;<br><br><br><span class="hljs-comment">// 字符视角</span><br>fmt.Println(<span class="hljs-string">&quot;the character count in s is&quot;</span>, utf8.RuneCountInString(s)) <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, c) <span class="hljs-comment">// 0x4e2d 0x56fd 0x4eba</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Go 采用的是 Unicode 字符集，每个字符都是一个 Unicode 字符，上述例子中字符视角下输出的 <code>0x4e2d</code>、<code>0x56fd</code> 和 <code>0x4eba</code> 就是 Unicode 字符的表示。以 <code>0x4e2d</code> 为例，它是汉字“中”在 Unicode 字符集表中的码点（Code Point）。Unicode字符集为绝大部分语言的字符提供了统一的编码集。</p><p>Unicode 字符集中的每个字符，都被分配了统一且唯一的字符编号。所谓 Unicode 码点，就是指将 Unicode 字符集中的所有字符“排成一队”，字符在这个“队伍”中的位次，就是它在 Unicode 字符集中的码点。也就说，一个码点唯一对应一个字符。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8 编码解决的是 Unicode 码点值在计算机中如何存储的问题。那么为什么不直接用unicode码点存储呢? 主要有如下几个问题:</p><ul><li>由于Unicode采用的是4个字节的固定长度编码，与ASCII无法兼容。</li><li>浪费存储空间</li></ul><p>UTF-8方案使用了变长设计，对Unicode的码点进行编码。其长度从1到4不等，并且前128个与ASCII兼容(即内存中如<code>A</code> <code>B</code> <code>C</code> 之类的字符时， ASCII字符编码可以被当做UTF-8编码直接使用)<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220724230323.png"></p><h3 id="Go语言如何表示一个码点"><a href="#Go语言如何表示一个码点" class="headerlink" title="Go语言如何表示一个码点"></a>Go语言如何表示一个码点</h3><p>Go 使用 rune 这个类型来表示一个 Unicode 码点。rune 本质上是 int32 类型的别名类型，它与 int32 类型是完全等价的</p><p>由于一个 Unicode 码点唯一对应一个 Unicode 字符。所以我们可以说，一个 rune 实例就是一个 Unicode 字符，一个 Go 字符串也可以被视为 rune 实例的集合。我们可以通过字符字面值来初始化一个 rune 变量。</p><p>那么现在我们就使用 Go 在标准库中提供的 UTF-8 包，对 Unicode 字符（rune）进行编解码试试看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// rune -&gt; []byte                                                                            </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">encodeRune</span><span class="hljs-params">()</span></span> &#123;                                                                          <br>    <span class="hljs-keyword">var</span> r <span class="hljs-type">rune</span> = <span class="hljs-number">0x4E2D</span>                                                                      <br>    fmt.Printf(<span class="hljs-string">&quot;the unicode charactor is %c\n&quot;</span>, r) <span class="hljs-comment">// 中                                     </span><br>    buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">3</span>)                                                                   <br>    _ = utf8.EncodeRune(buf, r) <span class="hljs-comment">// 对rune进行utf-8编码                                                           </span><br>    fmt.Printf(<span class="hljs-string">&quot;utf-8 representation is 0x%X\n&quot;</span>, buf) <span class="hljs-comment">// 0xE4B8AD                            </span><br>&#125;                                                                                            <br>                                                                                             <br><span class="hljs-comment">// []byte -&gt; rune                                                                            </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeRune</span><span class="hljs-params">()</span></span> &#123;                                                                          <br>    <span class="hljs-keyword">var</span> buf = []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">0xE4</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0xAD</span>&#125;                                                       <br>    r, _ := utf8.DecodeRune(buf) <span class="hljs-comment">// 对buf进行utf-8解码</span><br>    fmt.Printf(<span class="hljs-string">&quot;the unicode charactor after decoding [0xE4, 0xB8, 0xAD] is %s\n&quot;</span>, <span class="hljs-type">string</span>(r)) <span class="hljs-comment">// 中</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Go字符串类型的底层实现"><a href="#Go字符串类型的底层实现" class="headerlink" title="Go字符串类型的底层实现"></a>Go字符串类型的底层实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// $GOROOT/src/reflect/value.go</span><br><br><span class="hljs-comment">// StringHeader是一个string的运行时表示</span><br><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>    Data <span class="hljs-type">uintptr</span><br>    Len  <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从源码中和下面的图中可以看出string类型并不是单纯的”字符的数组”，而是有一个指向数据数据的指针和长度字段组成的结构体。<br>这也就很好的解释了string类型获取长度的时间复杂度是常数的原因。</p><p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220724230920.png"></p><h2 id="常用字符串操作"><a href="#常用字符串操作" class="headerlink" title="常用字符串操作"></a>常用字符串操作</h2><h3 id="下标操作"><a href="#下标操作" class="headerlink" title="下标操作"></a>下标操作</h3><p>在字符串的实现中，真正存储数据的是底层的数组。字符串的下标操作本质上等价于底层数组的下标操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;0x%x\n&quot;</span>, s[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 0xe4：字符“中” utf-8编码的第一个字节</span><br></code></pre></td></tr></table></figure><p>我们可以看到，通过下标操作，我们获取的是<strong>字符串中特定下标上的字节，而不是字符。</strong></p><h3 id="迭代操作"><a href="#迭代操作" class="headerlink" title="迭代操作"></a>迭代操作</h3><p>Go 有两种迭代形式：常规 for 迭代与 for range 迭代。需要注意的是，通过这两种形式的迭代对字符串进行操作得到的结果是不同的。<br>通过常规 for 迭代对字符串进行的操作是一种字节视角的迭代，而通过 for range 迭代，我们每轮迭代得到的是字符串中 Unicode 字符的码点值，以及该字符在字符串中的偏移值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><br><span class="hljs-comment">// for 迭代</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, s[i])<br>&#125;<br><br><span class="hljs-comment">// for range迭代</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, v)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行一下这段代码，我们得到:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// for 迭代</span><br>index: <span class="hljs-number">0</span>, value: <span class="hljs-number">0xe4</span><br>index: <span class="hljs-number">1</span>, value: <span class="hljs-number">0xb8</span><br>index: <span class="hljs-number">2</span>, value: <span class="hljs-number">0xad</span><br>index: <span class="hljs-number">3</span>, value: <span class="hljs-number">0xe5</span><br>index: <span class="hljs-number">4</span>, value: <span class="hljs-number">0x9b</span><br>index: <span class="hljs-number">5</span>, value: <span class="hljs-number">0xbd</span><br>index: <span class="hljs-number">6</span>, value: <span class="hljs-number">0xe4</span><br>index: <span class="hljs-number">7</span>, value: <span class="hljs-number">0xba</span><br>index: <span class="hljs-number">8</span>, value: <span class="hljs-number">0xba</span><br><br><span class="hljs-comment">// for range迭代</span><br>index: <span class="hljs-number">0</span>, value: <span class="hljs-number">0x4e2d</span><br>index: <span class="hljs-number">3</span>, value: <span class="hljs-number">0x56fd</span><br>index: <span class="hljs-number">6</span>, value: <span class="hljs-number">0x4eba</span><br></code></pre></td></tr></table></figure><h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><p>Go 原生支持通过 +&#x2F;+&#x3D; 操作符进行字符串连接</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;Rob Pike, &quot;</span><br>s = s + <span class="hljs-string">&quot;Robert Griesemer, &quot;</span><br>s += <span class="hljs-string">&quot; Ken Thompson&quot;</span><br><br>fmt.Println(s) <span class="hljs-comment">// Rob Pike, Robert Griesemer, Ken Thompson</span><br></code></pre></td></tr></table></figure><p>虽然通过 +&#x2F;+&#x3D; 进行字符串连接的开发体验是最好的, 但性能略差，Go 还提供了 strings.Builder、strings.Join、fmt.Sprintf 等函数来进行字符串连接操作以更好的解决性能问题</p><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>Go 字符串类型支持各种比较关系操作符，包括 &#x3D; &#x3D;、!&#x3D; 、&gt;&#x3D;、&lt;&#x3D;、&gt; 和 &lt;。在字符串的比较上，Go 采用字典序的比较策略，分别从每个字符串的起始处，开始逐个字节地对两个字符串类型变量进行比较。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// ==</span><br>        s1 := <span class="hljs-string">&quot;世界和平&quot;</span><br>        s2 := <span class="hljs-string">&quot;世界&quot;</span> + <span class="hljs-string">&quot;和平&quot;</span><br>        fmt.Println(s1 == s2) <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// !=</span><br>        s1 = <span class="hljs-string">&quot;Go&quot;</span><br>        s2 = <span class="hljs-string">&quot;C&quot;</span><br>        fmt.Println(s1 != s2) <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// &lt; and &lt;=</span><br>        s1 = <span class="hljs-string">&quot;12345&quot;</span><br>        s2 = <span class="hljs-string">&quot;23456&quot;</span><br>        fmt.Println(s1 &lt; s2)  <span class="hljs-comment">// true</span><br>        fmt.Println(s1 &lt;= s2) <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// &gt; and &gt;=</span><br>        s1 = <span class="hljs-string">&quot;12345&quot;</span><br>        s2 = <span class="hljs-string">&quot;123&quot;</span><br>        fmt.Println(s1 &gt; s2)  <span class="hljs-comment">// true</span><br>        fmt.Println(s1 &gt;= s2) <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h3><p>Go 支持字符串与字节切片、字符串与 rune 切片的双向转换，并且这种转换无需调用任何函数，只需使用显式类型转换即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;中国人&quot;</span><br>                      <br><span class="hljs-comment">// string -&gt; []rune</span><br>rs := []<span class="hljs-type">rune</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, rs) <span class="hljs-comment">// [4e2d 56fd 4eba]</span><br>                <br><span class="hljs-comment">// string -&gt; []byte</span><br>bs := []<span class="hljs-type">byte</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, bs) <span class="hljs-comment">// e4b8ade59bbde4baba</span><br>                <br><span class="hljs-comment">// []rune -&gt; string</span><br>s1 := <span class="hljs-type">string</span>(rs)<br>fmt.Println(s1) <span class="hljs-comment">// 中国人</span><br>                <br><span class="hljs-comment">// []byte -&gt; string</span><br>s2 := <span class="hljs-type">string</span>(bs)<br>fmt.Println(s2) <span class="hljs-comment">// 中国人</span><br></code></pre></td></tr></table></figure><h2 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h2><h3 id="UTF-8采用不定长的设计，如何辨别几个字节为一个字符"><a href="#UTF-8采用不定长的设计，如何辨别几个字节为一个字符" class="headerlink" title="UTF-8采用不定长的设计，如何辨别几个字节为一个字符?"></a>UTF-8采用不定长的设计，如何辨别几个字节为一个字符?</h3><table><thead><tr><th>unicode 符号范围</th><th>utf-8 编码方式</th></tr></thead><tbody><tr><td>00000000 ~ 0000007F</td><td>0xxxxxxx</td></tr><tr><td>00000080 ~ 000007FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>00000800 ~ 0000FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>00010000 ~ 0010FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>总结下来，针对UTF8，编码规则其实只有两条：</p><ol><li>单字节规则： 对于 单字节 的符号，字节的第一位（最高位）设为 0，后面 7 位为这个符号的 unicode 码。</li><li>n字节规则： 对于 n 字节的符号（n&gt;1），第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Go学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>编解码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Prometheus | PromQL</title>
    <link href="/2022/07/05/Alert/prometheus-pql/"/>
    <url>/2022/07/05/Alert/prometheus-pql/</url>
    
    <content type="html"><![CDATA[<h2 id="0-什么是PromQL"><a href="#0-什么是PromQL" class="headerlink" title="0. 什么是PromQL"></a>0. 什么是PromQL</h2><blockquote><p>PromQL（Prometheus Query Language）是 Prometheus 内置的数据查询语言，它能实现对事件序列数据的查询、聚合、逻辑运算等。它并且被广泛应用在 Prometheus 的日常应用当中，包括对数据查询、可视化、告警处理当中。简单地说，PromQL 广泛存在于以 Prometheus 为核心的监控体系中。所以需要用到数据筛选的地方，就会用到 PromQL。例如：监控指标的设置、报警指标的设置等等。</p></blockquote><h2 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1. 基础用法"></a>1. 基础用法</h2><p>当我们直接使用监控指标名称查询时，可以查询该指标下的所有时间序列。<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220705202637.png"><br>可以看到我们查询出了所有指标名称为 <code>prometheus_http_requests_total</code> 的数据。<br>PromQL 支持户根据时间序列的标签匹配模式来对时间序列进行过滤，目前主要支持两种匹配模式：完全匹配和正则匹配。</p><h3 id="1-1-完全匹配"><a href="#1-1-完全匹配" class="headerlink" title="1.1 完全匹配"></a>1.1 完全匹配</h3><p>PromQL 支持使用 &#x3D; 和 !&#x3D; 两种完全匹配模式。</p><ul><li>等于。通过使用 <code>label=value</code> 可以选择那些标签满足表达式定义的时间序列。</li><li>不等于。通过使用 <code>label!=value</code> 则可以根据标签匹配排除时间序列。</li></ul><p>例如我们上面查询出了所有指标名称为 <code>prometheus_http_requests_total</code> 的数据。这时候我们希望只查看错误的请求，即过滤掉所有 code 标签不是 200 的数据。</p><p>那么我们的 PromQL 表达式可以修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;code!=&quot;200&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-正则匹配"><a href="#1-2-正则匹配" class="headerlink" title="1.2 正则匹配"></a>1.2 正则匹配</h3><p>PromQL 还可以使用正则表达式作为匹配条件，并且可以使用多个匹配条件。</p><ul><li>正向匹配。使用 <code>label=~regx</code> 表示选择那些标签符合正则表达式定义的时间序列。</li><li>反向匹配。使用 <code>label!~regx</code> 进行排除。</li></ul><p>例如我想查询指标 <code>prometheus_http_requests_total</code> 中，所有 handler 标签以 &#x2F;api&#x2F;v1 开头的记录。</p><p>那么我的表达式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;handler=~&quot;/api/v1/.*&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-范围查询"><a href="#1-3-范围查询" class="headerlink" title="1.3 范围查询"></a>1.3 范围查询</h3><p>我们上面直接通过类似 <code>prometheus_http_requests_total</code> 表达式查询时间序列时，同一个指标同一标签只会返回一条数据。这样的表达式我们称之为<code>瞬间向量表达式</code>，返回的结果称之为<code>瞬间向量</code></p><p>而如果我们想查询一段时间范围内的样本数据，那么我们就需要用到<code>区间向量表达式</code>，其查询出来的结果称之为<code>区间向量</code>。</p><p>时间范围通过时间范围选择器 <code>[]</code> 进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;&#125;[5m]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220705204103.png"><br>通过查询结果可以看到，此时我们查询出了所有的样本数据，而不再是一个样本数据的统计值。</p><p>PromQL的时间范围选择器支持其它时间单位: </p><ul><li>s - 秒</li><li>m - 分</li><li>h - 时</li><li>d - 天</li><li>w - 周</li><li>y - 年</li></ul><h3 id="1-4-时间偏移"><a href="#1-4-时间偏移" class="headerlink" title="1.4 时间偏移"></a>1.4 时间偏移</h3><p>在瞬时向量表达式或者区间向量表达式中，都是以当前时间为基准。如果我们想查询 5 分钟前的瞬时样本数据，或昨天一天的区间内的样本数据呢? 这个时候我们就可以使用位移操作，位移操作的关键字为 <code>offset</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询 5 分钟前的最新数据</span><br><span class="line">http_request_total&#123;&#125; offset 5m</span><br><span class="line"></span><br><span class="line"># 往前移动 1 天，查询 1 天前的数据</span><br><span class="line">http_request_total&#123;&#125;[1d] offset 1d</span><br></pre></td></tr></table></figure><h3 id="1-5-聚合查询"><a href="#1-5-聚合查询" class="headerlink" title="1.5 聚合查询"></a>1.5 聚合查询</h3><p>一般情况下，我们通过 PromQL 查询到的数据都是很多的。PromQL 提供的聚合操作可以用来对这些时间序列进行处理，形成一条新的时间序列。</p><p>以我们的 <code>prometheus_http_requests_total</code> 指标为例，不加任何条件我们查询到的数据为：<br><img src="https://raw.githubusercontent.com/SmartMalphite/PicBed/master/img-hexo/20220705204914.png"></p><ul><li><p>第一个表达式，计算一共有几条数据: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count(prometheus_http_requests_total)</span><br><span class="line"># 查询结果为8，代表总共有8条数据</span><br></pre></td></tr></table></figure></li><li><p>第二个表达式，计算所有数据的 value 总和:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(prometheus_http_requests_total)</span><br><span class="line"># 查询结果为307，代表所有数据的value之和为307</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-常用函数"><a href="#2-常用函数" class="headerlink" title="2. 常用函数"></a>2. 常用函数</h2><p>scalar(v instance-vector)是我们第一个见过的函数， 他将瞬时向量转化成标量。</p><blockquote><p>标量可以用于运算和可视化。例如和瞬时向量可以和标量进行加减乘除运算。只有一个时间序列的瞬时变量可以通过函数scalar()转化为标量。有时候在监控中，我们只需要知道当前的系统是不是健康的，当前磁盘空间是多少，只是后就可以用scalar()得到标量并在可视化工具中展示。</p></blockquote><p>abs(v instant-vector)可以将瞬时变量中的值转变为绝对值。</p><p>increase(v range-vector) 求区间向量的增长量（最新值减最旧值）并返回一个瞬时向量。</p>]]></content>
    
    
    <categories>
      
      <category>监控告警</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Prometheus</tag>
      
      <tag>PromQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 搭建 &amp; 使用指南</title>
    <link href="/2022/05/17/Deploy/hexo/"/>
    <url>/2022/05/17/Deploy/hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><blockquote><p>Hexo 是一个可以易于上手、部署的静态博客架构。使用node.js作为构建引擎，插件库丰富，可扩展性好。支持MarkDown作为书写语言，可以满足日常博客编写需求</p></blockquote><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>安装Hexo前，需要本地环境已经安装有这两个东西:</p><ul><li>Node.js</li><li>Git</li></ul><p>(这二者的安装就不在这里单独赘述了)</p><p>如果你的环境没有问题了，那么就可以开始安装Hexo了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装完成后，进入要作为博客资源的目录，执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog  <span class="comment"># 初始化配置</span></span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install  <span class="comment"># 安装依赖包</span></span><br><span class="line">hexo server  <span class="comment"># 在本地启动一个临时服务，可以用来预览和调试</span></span><br></pre></td></tr></table></figure><h2 id="撰写博文"><a href="#撰写博文" class="headerlink" title="撰写博文"></a>撰写博文</h2><p>撰写博文也非常简单，在<code>blog</code>目录下执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &lt;title&gt;</span><br></pre></td></tr></table></figure><p>例如想要创建一篇名为<code>hello</code>的博文:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post hello</span><br></pre></td></tr></table></figure><p>生成的文件路径是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO Created: &lt;blog-dir&gt;/source/_posts/hello.md</span><br></pre></td></tr></table></figure><p>打开文件，我们可以post模板已经自动帮我们生成了<code>yaml</code>文件头。其中<code>title</code>是文章的标题，<code>tags</code>是文章的标签。</p><p>编辑好文章内容后，执行<code>hexo server</code>就可以看见这篇文章已经发布到博客中了</p><h2 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h2><p>上文提到的<code>hexo server</code>的方式，只是在本地搭建了一个临时服务器，只能在本地访问。Hexo本身是一个静态页面的博客系统，因此对服务器的要求极低，Github免费提供的<code>Github Pages</code>就足以满足需求</p><h3 id="1-创建托管仓库"><a href="#1-创建托管仓库" class="headerlink" title="1.创建托管仓库"></a>1.创建托管仓库</h3><p>这里建议创建一个名为<code>&lt;username&gt;.github.io</code>的仓库来托管我们的网页(因为正常情况下，我们创建的仓库的github page的url是<code>&lt;username&gt;.github.io/&lt;repo name&gt;/</code>, 在域名之后会有一级仓库名称，这会导致很多页面、主题的相对路径功能出现问题；而使用这种仓库名和域名相同的方式创建的仓库的page的url中就不会包含仓库名)</p><h3 id="2-部署配置"><a href="#2-部署配置" class="headerlink" title="2. 部署配置"></a>2. 部署配置</h3><p>在博客的根目录下有一个<code>_config.yml</code>文件，这是博客的主配置文件。最后的<code>Deployment</code>配置项代表我们要使用的部署方式，如果我们要使用Git方式部署，那么需要安装一个hexo-deployer-git插件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后编辑这里的配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: &lt;repo url&gt;  <span class="comment"># 建议使用ssh的方式</span></span><br><span class="line">  branch: [branch]  <span class="comment"># 默认可不填</span></span><br><span class="line">  message: [message]  <span class="comment"># 默认可不填</span></span><br></pre></td></tr></table></figure><p>保存配置文件后，执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>上述命令可以简化成:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>现在已经将博客部署到Github了。可以用过<code>http://&lt;username&gt;.github.io</code>来访问自己的博客了</p><h2 id="Hexo-配置"><a href="#Hexo-配置" class="headerlink" title="Hexo 配置"></a>Hexo 配置</h2><p>在博客的主配置文件中除了配置部署相关的内容，还可以配置一些自定义的配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: <span class="string">&#x27;&#x27;</span>  <span class="comment"># 站名</span></span><br><span class="line">subtitle: <span class="string">&#x27;&#x27;</span>  <span class="comment"># 副标题</span></span><br><span class="line">description: <span class="string">&#x27;&#x27;</span>  <span class="comment"># 对搜索引擎收录博客会有帮助</span></span><br><span class="line">author: <span class="string">&#x27;&#x27;</span></span><br><span class="line">language: zh-Hans  <span class="comment"># 配置中文显示或者英文显示</span></span><br><span class="line">timezone: <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line">url: https://yoursite.com/ </span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  trailing_html: <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure><p>这部分配置只需要将url配置成自己的博客地址即可，例如部署在github page，就可以填 <code>https://&lt;username&gt;.github.io/project</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: ayer  </span><br></pre></td></tr></table></figure><p>主题配置，Hexo社区有大量的主题可供选择, 可以参考<a href="https://hexo.io/themes/">官方列表</a></p><h2 id="Hexo-主题"><a href="#Hexo-主题" class="headerlink" title="Hexo 主题"></a>Hexo 主题</h2><p>主题的使用也非常简单，这里以<code>AYER</code>主题为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</span><br></pre></td></tr></table></figure><p>把你想要的主题<code>git clone</code>下来，放到<code>themes/</code>下对应的目录中，然后我们修改博客主配置中<code>theme</code>配置，保存后，再次执行<code>hexo server</code>命令，预览一下变化</p><p>主题的配置一般放在<code>themes/&lt;themename&gt;/_config.yml</code>文件下，具体配置参考<a href="https://shen-yu.gitee.io/2019/ayer/">官方文档</a>即可</p>]]></content>
    
    
    <categories>
      
      <category>服务搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
